! function (t, e) {
    "function" == typeof define && define.amd ? define([], e) : "object" == typeof module && module.exports ? module.exports = e() : t.echarts = e()
}(this, function () {
    var t, e;
    ! function () {
        function i(t, e) {
            if (!e) return t;
            if (0 === t.indexOf(".")) {
                var i = e.split("/"),
                    n = t.split("/"),
                    r = i.length - 1,
                    a = n.length,
                    o = 0,
                    s = 0;
                t: for (var l = 0; a > l; l++) switch (n[l]) {
                    case "..":
                        if (!(r > o)) break t;
                        o++, s++;
                        break;
                    case ".":
                        s++;
                        break;
                    default:
                        break t
                }
                return i.length = r - o, n = n.slice(s), i.concat(n).join("/")
            }
            return t
        }

        function n(t) {
            function e(e, o) {
                if ("string" == typeof e) {
                    var s = n[e];
                    return s || (s = a(i(e, t)), n[e] = s), s
                }
                e instanceof Array && (o = o || function () { }, o.apply(this, r(e, o, t)))
            }
            var n = {};
            return e
        }

        function r(e, n, r) {
            for (var s = [], l = o[r], u = 0, c = Math.min(e.length, n.length); c > u; u++) {
                var h, f = i(e[u], r);
                switch (f) {
                    case "require":
                        h = l && l.require || t;
                        break;
                    case "exports":
                        h = l.exports;
                        break;
                    case "module":
                        h = l;
                        break;
                    default:
                        h = a(f)
                }
                s.push(h)
            }
            return s
        }

        function a(t) {
            var e = o[t];
            if (!e) throw new Error("No " + t);
            if (!e.defined) {
                var i = e.factory,
                    n = i.apply(this, r(e.deps || [], i, t));
                "undefined" != typeof n && (e.exports = n), e.defined = 1
            }
            return e.exports
        }
        var o = {};
        e = function (t, e, i) {
            o[t] = {
                id: t,
                deps: e,
                factory: i,
                defined: 0,
                exports: {},
                require: n(t)
            }
        }, t = n("")
    }();
    var i = "moveTo",
        n = "../../util/graphic",
        r = "dataToPoint",
        a = "parsePercent",
        o = "getItemModel",
        s = "retrieve",
        l = "parent",
        u = "stroke",
        c = "applyTransform",
        h = "eachItemGraphicEl",
        f = "getItemGraphicEl",
        d = "getShallow",
        p = "ordinal",
        m = "ecModel",
        v = "concat",
        g = "undefined",
        y = "getTicks",
        _ = "getExtent",
        x = "contain",
        b = "opacity",
        w = "position",
        M = "center",
        T = "middle",
        S = "getBoundingRect",
        C = "getFont",
        A = "textStyle",
        P = "removeAll",
        k = "number",
        L = "function",
        z = "isArray",
        I = "replace",
        D = "zlevel",
        O = "setStyle",
        B = "traverse",
        E = "getDataParams",
        R = "seriesIndex",
        N = "mouseout",
        F = "splice",
        G = "trigger",
        V = "defaults",
        H = "extend",
        q = "remove",
        W = "series",
        Z = "eachSeries",
        j = "colorStops",
        U = "update",
        X = "create",
        Y = "getItemVisual",
        $ = "dataIndex",
        Q = "getData",
        K = "coordinateSystem",
        J = "indexOf",
        te = "length",
        ee = "bottom",
        ie = "ignore",
        ne = "getHeight",
        re = "getWidth",
        ae = "getModel",
        oe = "isObject",
        se = "silent",
        le = "animation",
        ue = "height",
        ce = "string",
        he = "prototype",
        fe = "toLowerCase",
        de = "zrender/core/util",
        pe = "zrender/core/env",
        me = "require";
    e("echarts/echarts", [me, pe, "./model/Global", "./ExtensionAPI", "./CoordinateSystem", "./model/OptionManager", "./model/Component", "./model/Series", "./view/Component", "./view/Chart", "./util/graphic", "./util/model", "./util/throttle", "zrender", de, "zrender/tool/color", "zrender/mixin/Eventful", "zrender/core/timsort", "./visual/seriesColor", "./preprocessor/backwardCompat", "./loading/default", "./data/List", "./model/Model", "./util/number", "./util/format", "zrender/core/matrix", "zrender/core/vector"], function (t) {
        function e(t) {
            return function (e, i, n) {
                e = e && e[fe](), xe[he][t].call(this, e, i, n)
            }
        }

        function i() {
            xe.call(this)
        }

        function n(t, e, n) {
            function r(t, e) {
                return t.prio - e.prio
            }
            n = n || {}, typeof e === ce && (e = qe[e]), this.id, this.group, this._dom = t;
            var a = this._zr = ge.init(t, {
                renderer: n.renderer || "canvas",
                devicePixelRatio: n.devicePixelRatio,
                width: n.width,
                height: n[ue]
            });
            this._throttledZrFlush = ve.throttle(ye.bind(a.flush, a), 17), this._theme = ye.clone(e), this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._api = new w(this), this._coordSysMgr = new M, xe.call(this), this._messageCenter = new i, this._initEvents(), this.resize = ye.bind(this.resize, this), this._pendingActions = [], be(He, r), be(Ge, r), a[le].on("frame", this._onframe, this)
        }

        function r(t, e, i) {
            var n, r = this._model,
                a = this._coordSysMgr.getCoordinateSystems();
            e = me.parseFinder(r, e);
            for (var o = 0; o < a[te]; o++) {
                var s = a[o];
                if (s[t] && null != (n = s[t](r, e, i))) return n
            }
        }

        function a(t, e, i, n, r) {
            var a = t._model,
                o = {};
            o[n + "Id"] = i[n + "Id"], o[n + "Index"] = i[n + "Index"], o[n + "Name"] = i[n + "Name"];
            var s = {
                mainType: n,
                query: o
            };
            r && (s.subType = r), a && a.eachComponent(s, function (r) {
                var o = t[n === W ? "_chartsMap" : "_componentsMap"][r.__viewId];
                o && o.__alive && o[e](r, a, t._api, i)
            }, t)
        }

        function o(t, e) {
            var i = t.type,
                n = Ne[i],
                r = n.actionInfo,
                o = (r[U] || U).split(":"),
                s = o.pop();
            o = o[0] && Me(o[0]), this[ze] = !0;
            var l = [t],
                u = !1;
            t.batch && (u = !0, l = ye.map(t.batch, function (e) {
                return e = ye[V](ye[H]({}, e), t), e.batch = null, e
            }));
            for (var c, h = [], f = "highlight" === i || "downplay" === i, d = 0; d < l[te]; d++) {
                var p = l[d];
                c = n.action(p, this._model), c = c || ye[H]({}, p), c.type = r.event || c.type, h.push(c), f ? a(this, s, p, W) : o && a(this, s, p, o.main, o.sub)
            }
            "none" === s || f || o || (this[De] ? (Ee.prepareAndUpdate.call(this, t), this[De] = !1) : Ee[s].call(this, t)), c = u ? {
                type: r.event || i,
                batch: h
            } : h[0], this[ze] = !1, !e && this._messageCenter[G](c.type, c)
        }

        function s(t) {
            for (var e = this._pendingActions; e[te];) {
                var i = e.shift();
                o.call(this, i, t)
            }
        }

        function l(t) {
            !t && this[G]("updated")
        }

        function u(t, e, i) {
            var n = this._api;
            we(this._componentsViews, function (r) {
                var a = r.__model;
                r[t](a, e, n, i), y(a, r)
            }, this), e[Z](function (r) {
                var a = this._chartsMap[r.__viewId];
                a[t](r, e, n, i), y(r, a), g(r, a)
            }, this), v(this._zr, e)
        }

        function c(t, e) {
            for (var i = "component" === t, n = i ? this._componentsViews : this._chartsViews, r = i ? this._componentsMap : this._chartsMap, a = this._zr, o = 0; o < n[te]; o++) n[o].__alive = !1;
            e[i ? "eachComponent" : Z](function (t, o) {
                if (i) {
                    if (t === W) return
                } else o = t;
                var s = o.id + "_" + o.type,
                    l = r[s];
                if (!l) {
                    var u = Me(o.type),
                        c = i ? A.getClass(u.main, u.sub) : P.getClass(u.sub);
                    if (!c) return;
                    l = new c, l.init(e, this._api), r[s] = l, n.push(l), a.add(l.group)
                }
                o.__viewId = s, l.__alive = !0, l.__id = s, l.__model = o
            }, this);
            for (var o = 0; o < n[te];) {
                var s = n[o];
                s.__alive ? o++ : (a[q](s.group), s.dispose(e, this._api), n[F](o, 1), delete r[s.__id])
            }
        }

        function h(t, e) {
            we(Ge, function (i) {
                i.func(t, e)
            })
        }

        function f(t) {
            var e = {};
            t[Z](function (t) {
                var i = t.get("stack"),
                    n = t[Q]();
                if (i && "list" === n.type) {
                    var r = e[i];
                    r && (n.stackedOn = r), e[i] = n
                }
            })
        }

        function d(t, e) {
            var i = this._api;
            we(He, function (n) {
                n.isLayout && n.func(t, i, e)
            })
        }

        function p(t, e, i) {
            var n = this._api;
            t.clearColorPalette(), t[Z](function (t) {
                t.clearColorPalette()
            }), we(He, function (r) {
                (!i || !r.isLayout) && r.func(t, n, e)
            })
        }

        function m(t, e) {
            var i = this._api;
            we(this._componentsViews, function (n) {
                var r = n.__model;
                n.render(r, t, i, e), y(r, n)
            }, this), we(this._chartsViews, function (t) {
                t.__alive = !1
            }, this), t[Z](function (n) {
                var r = this._chartsMap[n.__viewId];
                r.__alive = !0, r.render(n, t, i, e), r.group[se] = !!n.get(se), y(n, r), g(n, r)
            }, this), v(this._zr, t), we(this._chartsViews, function (e) {
                e.__alive || e[q](t, i)
            }, this)
        }

        function v(t, e) {
            var i = t.storage,
                n = 0;
            i[B](function (t) {
                t.isGroup || n++
            }), n > e.get("hoverLayerThreshold") && !x.node && i[B](function (t) {
                t.isGroup || (t.useHoverLayer = !0)
            })
        }

        function g(t, e) {
            var i = 0;
            e.group[B](function (t) {
                "group" === t.type || t[ie] || i++
            });
            var n = +t.get("progressive"),
                r = i > t.get("progressiveThreshold") && n && !x.node;
            r && e.group[B](function (t) {
                t.isGroup || (t.progressive = r ? Math.floor(i++ / n) : -1, r && t.stopAnimation(!0))
            }); var a = t.get("blendMode") || null; e.group[B](function (t) { t.isGroup || t[O]("blend", a) })
        } function y(t, e) { var i = t.get("z"), n = t.get(D); e.group[B](function (t) { "group" !== t.type && (null != i && (t.z = i), null != n && (t[D] = n)) }) } function _(t) { function e(t, e) { for (var i = 0; i < t[te]; i++) { var n = t[i]; n[a] = e } } var i = 0, n = 1, r = 2, a = "__connectUpdateStatus"; ye.each(Fe, function (o, s) { t._messageCenter.on(s, function (o) { if (je[t.group] && t[a] !== i) { var s = t.makeActionFromEvent(o), l = []; ye.each(Ze, function (e) { e !== t && e.group === t.group && l.push(e) }), e(l, i), we(l, function (t) { t[a] !== n && t.dispatchAction(s) }), e(l, r) } }) }) } var x = t(pe), b = t("./model / Global "), w = t(". / ExtensionAPI "), M = t(". / CoordinateSystem "), T = t(". / model / OptionManager "), S = t(". / model / Component "), C = t(". / model / Series "), A = t(". / view / Component "), P = t(". / view / Chart "), I = t(". / util / graphic "), me = t(". / util / model "), ve = t(". / util / throttle "), ge = t("
                                    zrender "),ye=t(de),_e=t("
                                    zrender / tool / color "),xe=t("
                                    zrender / mixin / Eventful "),be=t("
                                    zrender / core / timsort "),we=ye.each,Me=S.parseClassType,Te=1e3,Se=5e3,Ce=1e3,Ae=2e3,Pe=3e3,ke=4e3,Le=5e3,ze="
                                    __flagInMainProcess ",Ie="
                                    __hasGradientOrPatternBg ",De="
                                    __optionUpdated ",Oe=/^[a-zA-Z0-9_]+$/;i[he].on=e("
                                    on "),i[he].off=e("
                                    off "),i[he].one=e("
                                    one "),ye.mixin(i,xe);var Be=n[he];Be._onframe=function(){if(this[De]){var t=this[De][se];this[ze]=!0,Ee.prepareAndUpdate.call(this),this[ze]=!1,this[De]=!1,s.call(this,t),l.call(this,t)}},Be.getDom=function(){return this._dom},Be.getZr=function(){return this._zr},Be.setOption=function(t,e,i){var n;if(ye[oe](e)&&(i=e.lazyUpdate,n=e[se],e=e.notMerge),this[ze]=!0,!this._model||e){var r=new T(this._api),a=this._theme,o=this._model=new b(null,null,a,r);o.init(null,null,a,r)}this.__lastOnlyGraphic=!(!t||!t.graphic),ye.each(t,function(t,e){"
                                    graphic "!==e&&(this.__lastOnlyGraphic=!1)},this),this._model.setOption(t,Ve),i?(this[De]={silent:n},this[ze]=!1):(Ee.prepareAndUpdate.call(this),this._zr.flush(),this[De]=!1,this[ze]=!1,s.call(this,n),l.call(this,n))},Be.setTheme=function(){console.log("
                                    ECharts #setTheme() is DEPRECATED in ECharts 3.0 ")},Be[ae]=function(){return this._model},Be.getOption=function(){return this._model&&this._model.getOption()},Be[re]=function(){return this._zr[re]()},Be[ne]=function(){return this._zr[ne]()},Be.getRenderedCanvas=function(t){if(x.canvasSupported){t=t||{},t.pixelRatio=t.pixelRatio||1,t.backgroundColor=t.backgroundColor||this._model.get("
                                    backgroundColor ");var e=this._zr,i=e.storage.getDisplayList();return ye.each(i,function(t){t.stopAnimation(!0)}),e.painter.getRenderedCanvas(t)}},Be.getDataURL=function(t){t=t||{};var e=t.excludeComponents,i=this._model,n=[],r=this;we(e,function(t){i.eachComponent({mainType:t},function(t){var e=r._componentsMap[t.__viewId];e.group[ie]||(n.push(e),e.group[ie]=!0)})});var a=this.getRenderedCanvas(t).toDataURL("
                                    image / "+(t&&t.type||"
                                    png "));return we(n,function(t){t.group[ie]=!1}),a},Be.getConnectedDataURL=function(t){if(x.canvasSupported){var e=this.group,i=Math.min,n=Math.max,r=1/0;if(je[e]){var a=r,o=r,s=-r,l=-r,u=[],c=t&&t.pixelRatio||1;ye.each(Ze,function(r){if(r.group===e){var c=r.getRenderedCanvas(ye.clone(t)),h=r.getDom().getBoundingClientRect();a=i(h.left,a),o=i(h.top,o),s=n(h.right,s),l=n(h[ee],l),u.push({dom:c,left:h.left,top:h.top})}}),a*=c,o*=c,s*=c,l*=c;var h=s-a,f=l-o,d=ye.createCanvas();d.width=h,d[ue]=f;var p=ge.init(d);return we(u,function(t){var e=new I.Image({style:{x:t.left*c-a,y:t.top*c-o,image:t.dom}});p.add(e)}),p.refreshImmediately(),d.toDataURL("
                                    image / "+(t&&t.type||"
                                    png "))}return this.getDataURL(t)}},Be.convertToPixel=ye.curry(r,"
                                    convertToPixel "),Be.convertFromPixel=ye.curry(r,"
                                    convertFromPixel "),Be.containPixel=function(t,e){var i,n=this._model;return t=me.parseFinder(n,t),ye.each(t,function(t,n){n[J]("
                                    Models ")>=0&&ye.each(t,function(t){var r=t[K];if(r&&r.containPoint)i|=!!r.containPoint(e);else if("
                                    seriesModels "===n){var a=this._chartsMap[t.__viewId];a&&a.containPoint&&(i|=a.containPoint(e,t))}},this)},this),!!i},Be.getVisual=function(t,e){var i=this._model;t=me.parseFinder(i,t,{defaultMainType:"
                                    series "});var n=t.seriesModel,r=n[Q](),a=t.hasOwnProperty("
                                    dataIndexInside ")?t.dataIndexInside:t.hasOwnProperty($)?r.indexOfRawIndex(t[$]):null;return null!=a?r[Y](a,e):r.getVisual(e)};var Ee={update:function(t){var e=this._model,i=this._api,n=this._coordSysMgr,r=this._zr;if(e){e.restoreData(),n[X](this._model,this._api),h.call(this,e,i),f.call(this,e),n[U](e,i),p.call(this,e,t),m.call(this,e,t);var a=e.get("
                                    backgroundColor ")||"
                                    transparent ",o=r.painter;if(o.isSingleCanvas&&o.isSingleCanvas())r.configLayer(0,{clearColor:a});else{if(!x.canvasSupported){var s=_e.parse(a);a=_e.stringify(s,"
                                    rgb "),0===s[3]&&(a="
                                    transparent ")}a[j]||a.image?(r.configLayer(0,{clearColor:a}),this[Ie]=!0,this._dom.style.background="
                                    transparent "):(this[Ie]&&r.configLayer(0,{clearColor:null}),this[Ie]=!1,this._dom.style.background=a)}}},updateView:function(t){var e=this._model;e&&(e[Z](function(t){t[Q]().clearAllVisual()}),p.call(this,e,t),u.call(this,"
                                    updateView ",e,t))},updateVisual:function(t){var e=this._model;e&&(e[Z](function(t){t[Q]().clearAllVisual()}),p.call(this,e,t,!0),u.call(this,"
                                    updateVisual ",e,t))},updateLayout:function(t){var e=this._model;e&&(d.call(this,e,t),u.call(this,"
                                    updateLayout ",e,t))},prepareAndUpdate:function(t){var e=this._model;c.call(this,"
                                    component ",e),c.call(this,"
                                    chart ",e),this.__lastOnlyGraphic?(we(this._componentsViews,function(i){var n=i.__model;n&&"
                                    graphic "===n.mainType&&(i.render(n,e,this._api,t),y(n,i))},this),this.__lastOnlyGraphic=!1):Ee[U].call(this,t)}};Be.resize=function(t){this[ze]=!0,this._zr.resize(t);var e=this._model&&this._model.resetOption("
                                    media "),i=e?"
                                    prepareAndUpdate ":U;Ee[i].call(this),this._loadingFX&&this._loadingFX.resize(),this[ze]=!1;var n=t&&t[se];s.call(this,n),l.call(this,n)},Be.showLoading=function(t,e){if(ye[oe](t)&&(e=t,t="
                                    "),t=t||"
                                    default ",this.hideLoading(),We[t]){var i=We[t](this._api,e),n=this._zr;this._loadingFX=i,n.add(i)}},Be.hideLoading=function(){this._loadingFX&&this._zr[q](this._loadingFX),this._loadingFX=null},Be.makeActionFromEvent=function(t){var e=ye[H]({},t);return e.type=Fe[t.type],e},Be.dispatchAction=function(t,e){if(ye[oe](e)||(e={silent:!!e}),Ne[t.type]){if(this[ze])return void this._pendingActions.push(t);o.call(this,t,e[se]),e.flush?this._zr.flush(!0):e.flush!==!1&&x.browser.weChat&&this._throttledZrFlush(),s.call(this,e[se]),l.call(this,e[se])}},Be.on=e("
                                    on "),Be.off=e("
                                    off "),Be.one=e("
                                    one ");var Re=["
                                    click ","
                                    dblclick ","
                                    mouseover ",N,"
                                    mousemove ","
                                    mousedown ","
                                    mouseup ","
                                    globalout ","
                                    contextmenu "];Be._initEvents=function(){we(Re,function(t){this._zr.on(t,function(e){var i,n=this[ae](),r=e.target;if("
                                    globalout "===t)i={};else if(r&&null!=r[$]){var a=r.dataModel||n.getSeriesByIndex(r[R]);i=a&&a[E](r[$],r.dataType)||{}}else r&&r.eventData&&(i=ye[H]({},r.eventData));i&&(i.event=e,i.type=t,this[G](t,i))},this)},this),we(Fe,function(t,e){this._messageCenter.on(e,function(t){this[G](e,t)},this)},this)},Be.isDisposed=function(){return this._disposed},Be.clear=function(){this.setOption({series:[]},!0)},Be.dispose=function(){if(!this._disposed){this._disposed=!0;var t=this._api,e=this._model;we(this._componentsViews,function(i){i.dispose(e,t)}),we(this._chartsViews,function(i){i.dispose(e,t)}),this._zr.dispose(),delete Ze[this.id]}},ye.mixin(n,xe);var Ne=[],Fe={},Ge=[],Ve=[],He=[],qe={},We={},Ze={},je={},Ue=new Date-0,Xe=new Date-0,Ye="
                                    _echarts_instance_ ",$e={version:"
        3.4 .0 ",dependencies:{zrender:"
        3.3 .0 "}};return $e.init=function(t,e,i){var r=new n(t,e,i);return r.id="
                                    ec_ "+Ue++,Ze[r.id]=r,t.setAttribute&&t.setAttribute(Ye,r.id),_(r),r},$e.connect=function(t){if(ye[z](t)){var e=t;t=null,ye.each(e,function(e){null!=e.group&&(t=e.group)}),t=t||"
                                    g_ "+Xe++,ye.each(e,function(e){e.group=t})}return je[t]=!0,t},$e.disConnect=function(t){je[t]=!1},$e.dispose=function(t){ye.isDom(t)?t=$e.getInstanceByDom(t):typeof t===ce&&(t=Ze[t]),t instanceof n&&!t.isDisposed()&&t.dispose()},$e.getInstanceByDom=function(t){var e=t.getAttribute(Ye);return Ze[e]},$e.getInstanceById=function(t){return Ze[t]},$e.registerTheme=function(t,e){qe[t]=e},$e.registerPreprocessor=function(t){Ve.push(t)},$e.registerProcessor=function(t,e){typeof t===L&&(e=t,t=Te),Ge.push({prio:t,func:e})},$e.registerAction=function(t,e,i){typeof e===L&&(i=e,e="
        ");var n=ye[oe](t)?t.type:[t,t={event:e}][0];t.event=(t.event||n)[fe](),e=t.event,ye.assert(Oe.test(n)&&Oe.test(e)),Ne[n]||(Ne[n]={action:i,actionInfo:t}),Fe[e]=n},$e.registerCoordinateSystem=function(t,e){M.register(t,e)},$e.registerLayout=function(t,e){typeof t===L&&(e=t,t=Ce),He.push({prio:t,func:e,isLayout:!0})},$e.registerVisual=function(t,e){typeof t===L&&(e=t,t=Pe),He.push({prio:t,func:e})},$e.registerLoading=function(t,e){We[t]=e},$e.extendComponentModel=function(t){return S[H](t)},$e.extendComponentView=function(t){return A[H](t)},$e.extendSeriesModel=function(t){return C[H](t)},$e.extendChartView=function(t){return P[H](t)},$e.setCanvasCreator=function(t){ye.createCanvas=t},$e.registerVisual(Ae,t(". / visual / seriesColor ")),$e.registerPreprocessor(t(". / preprocessor / backwardCompat ")),$e.registerLoading("
                                    default ",t(". / loading /
                                    default ")),$e.registerAction({type:"
                                    highlight ",event:"
                                    highlight ",update:"
                                    highlight "},ye.noop),$e.registerAction({type:"
                                    downplay ",event:"
                                    downplay ",update:"
                                    downplay "},ye.noop),$e.List=t(". / data / List "),$e.Model=t(". / model / Model "),$e.graphic=t(". / util / graphic "),$e[k]=t(". / util / number "),$e.format=t(". / util / format "),$e.throttle=ve.throttle,$e.matrix=t("
        zrender / core / matrix "),$e.vector=t("
        zrender / core / vector "),$e.color=t("
        zrender / tool / color "),$e.util={},we(["
                                    map ","
                                    each ","
                                    filter ",J,"
                                    inherits ","
                                    reduce ","
                                    filter ","
                                    bind ","
                                    curry ",z,"
                                    isString ",oe,"
                                    isFunction ",H,V,"
                                    clone "],function(t){$e.util[t]=ye[t]}),$e.PRIORITY={PROCESSOR:{FILTER:Te,STATISTIC:Se},VISUAL:{LAYOUT:Ce,GLOBAL:Ae,CHART:Pe,COMPONENT:ke,BRUSH:Le}},$e}),e("
        echarts / chart / bar ",[me,de,".. / coord / cartesian / Grid ",". / bar / BarSeries ",". / bar / BarView ",".. / layout / barGrid ",".. / echarts ",".. / component / grid "],function(t){var e=t(de);t(".. / coord / cartesian / Grid "),t(". / bar / BarSeries "),t(". / bar / BarView ");var i=t(".. / layout / barGrid "),n=t(".. / echarts ");n.registerLayout(e.curry(i,"
                                    bar ")),n.registerVisual(function(t){t.eachSeriesByType("
                                    bar ",function(t){var e=t[Q]();e.setVisual("
                                    legendSymbol ","
                                    roundRect ")})}),t(".. / component / grid ")}),e("
        echarts / chart / line ",[me,de,".. / echarts ",". / line / LineSeries ",". / line / LineView ",".. / visual / symbol ",".. / layout / points ",".. / processor / dataSample ",".. / component / grid "],function(t){var e=t(de),i=t(".. / echarts "),n=i.PRIORITY;t(". / line / LineSeries "),t(". / line / LineView "),i.registerVisual(e.curry(t(".. / visual / symbol "),"
                                    line ","
                                    circle ","
                                    line ")),i.registerLayout(e.curry(t(".. / layout / points "),"
                                    line ")),i.registerProcessor(n.PROCESSOR.STATISTIC,e.curry(t(".. / processor / dataSample "),"
                                    line ")),t(".. / component / grid ")}),e("
        echarts / chart / gauge ",[me,". / gauge / GaugeSeries ",". / gauge / GaugeView "],function(t){t(". / gauge / GaugeSeries "),t(". / gauge / GaugeView ")}),e("
        echarts / component / grid ",[me,".. / util / graphic ",de,".. / echarts ",".. / coord / cartesian / Grid ",". / axis "],function(t){var e=t(".. / util / graphic "),i=t(de),n=t(".. / echarts ");t(".. / coord / cartesian / Grid "),t(". / axis "),n.extendComponentView({type:"
                                    grid ",render:function(t){this.group[P](),t.get("
                                    show ")&&this.group.add(new e.Rect({shape:t[K].getRect(),style:i[V]({fill:t.get("
                                    backgroundColor ")},t.getItemStyle()),silent:!0,z2:-1}))}}),n.registerPreprocessor(function(t){t.xAxis&&t.yAxis&&!t.grid&&(t.grid={})})}),e("
        echarts / component / title ",[me,".. / echarts ",".. / util / graphic ",".. / util / layout "],function(t){var e=t(".. / echarts "),i=t(".. / util / graphic "),n=t(".. / util / layout ");e.extendComponentModel({type:"
                                    title ",layoutMode:{type:"
                                    box ",ignoreSize:!0},defaultOption:{zlevel:0,z:6,show:!0,text:"
        ",target:"
                                    blank ",subtext:"
        ",subtarget:"
                                    blank ",left:0,top:0,backgroundColor:"
        rgba(0, 0, 0, 0)
        ",borderColor:"
        #ccc ",borderWidth:0,padding:5,itemGap:10,textStyle:{fontSize:18,fontWeight:"
                                    bolder ",color:"
                                    #333"},subtextStyle:{color:"# aaa "}}}),e.extendComponentView({type:"
                                    title ",render:function(t,e,r){if(this.group[P](),t.get("
                                    show ")){var a=this.group,o=t[ae](A),s=t[ae]("
                                    subtextStyle "),l=t.get("
                                    textAlign "),u=t.get("
                                    textBaseline "),c=new i.Text({style:{text:t.get("
                                    text "),textFont:o[C](),fill:o.getTextColor()},z2:10}),h=c[S](),f=t.get("
                                    subtext "),d=new i.Text({style:{text:f,textFont:s[C](),fill:s.getTextColor(),y:h[ue]+t.get("
                                    itemGap "),textBaseline:"
                                    top "},z2:10}),p=t.get("
                                    link "),m=t.get("
                                    sublink ");c[se]=!p,d[se]=!m,p&&c.on("
                                    click ",function(){window.open(p,"
                                    _ "+t.get("
                                    target "))}),m&&d.on("
                                    click ",function(){window.open(m,"
                                    _ "+t.get("
                                    subtarget "))}),a.add(c),f&&a.add(d);var v=a[S](),g=t.getBoxLayoutParams();g.width=v.width,g[ue]=v[ue];var y=n.getLayoutRect(g,{width:r[re](),height:r[ne]()},t.get("
                                    padding "));l||(l=t.get("
                                    left ")||t.get("
                                    right "),l===T&&(l=M),"
                                    right "===l?y.x+=y.width:l===M&&(y.x+=y.width/2)),u||(u=t.get("
                                    top ")||t.get(ee),u===M&&(u=T),u===ee?y.y+=y[ue]:u===T&&(y.y+=y[ue]/2),u=u||"
                                    top "),a.attr(w,[y.x,y.y]);var _={textAlign:l,textVerticalAlign:u};c[O](_),d[O](_),v=a[S]();var x=y.margin,k=t.getItemStyle(["
                                    color ",b]);k.fill=t.get("
                                    backgroundColor ");var L=new i.Rect({shape:{x:v.x-x[3],y:v.y-x[0],width:v.width+x[1]+x[3],height:v[ue]+x[0]+x[2]},style:k,silent:!0});i.subPixelOptimizeRect(L),a.add(L)}}})}),e("
        echarts / component / legend ",[me,". / legend / LegendModel ",". / legend / legendAction ",". / legend / LegendView ",".. / echarts ",". / legend / legendFilter "],function(t){t(". / legend / LegendModel "),t(". / legend / legendAction "),t(". / legend / LegendView ");var e=t(".. / echarts ");e.registerProcessor(t(". / legend / legendFilter "))}),e("
        echarts / component / tooltip ",[me,". / tooltip / TooltipModel ",". / tooltip / TooltipView ",".. / echarts "],function(t){t(". / tooltip / TooltipModel "),t(". / tooltip / TooltipView "),t(".. / echarts ").registerAction({type:"
                                    showTip ",event:"
                                    showTip ",update:"
        tooltip: manuallyShowTip "},function(){}),t(".. / echarts ").registerAction({type:"
                                    hideTip ",event:"
                                    hideTip ",update:"
        tooltip: manuallyHideTip "},function(){})}),e("
        echarts / component / markPoint ",[me,". / marker / MarkPointModel ",". / marker / MarkPointView ",".. / echarts "],function(t){t(". / marker / MarkPointModel "),t(". / marker / MarkPointView "),t(".. / echarts ").registerPreprocessor(function(t){t.markPoint=t.markPoint||{}})}),e("
        echarts / scale / Time ",[me,de,".. / util / number ",".. / util / format ",". / Interval "],function(t){var e=t(de),i=t(".. / util / number "),n=t(".. / util / format "),r=t(". / Interval "),a=r[he],o=Math.ceil,s=Math.floor,l=1e3,u=60*l,c=60*u,h=24*c,f=function(t,e,i,n){for(;n>i;){var r=i+n>>>1;t[r][2]<e?i=r+1:n=r}return i},d=r[H]({type:"
                                    time ",getLabel:function(t){var e=this._stepLvl,i=new Date(t);return n.formatTime(e[0],i)},niceExtent:function(t,e,n){var r=this._extent;if(r[0]===r[1]&&(r[0]-=h,r[1]+=h),r[1]===-1/0&&1/0===r[0]){var a=new Date;r[1]=new Date(a.getFullYear(),a.getMonth(),a.getDate()),r[0]=r[1]-h}this.niceTicks(t);var l=this._interval;e||(r[0]=i.round(s(r[0]/l)*l)),n||(r[1]=i.round(o(r[1]/l)*l))},niceTicks:function(t){t=t||10;var e=this._extent,n=e[1]-e[0],r=n/t,a=p[te],l=f(p,r,0,a),u=p[Math.min(l,a-1)],c=u[2];if("
                                    year "===u[0]){var h=n/c,d=i.nice(h/t,!0);c*=d}var m=[o(e[0]/c)*c,s(e[1]/c)*c];this._stepLvl=u,this._interval=c,this._niceExtent=m},parse:function(t){return+i.parseDate(t)}});e.each([x,"
                                    normalize "],function(t){d[he][t]=function(e){return a[t].call(this,this.parse(e))}});var p=[["
        hh: mm: ss ",1,l],["
        hh: mm: ss ",5,5*l],["
        hh: mm: ss ",10,10*l],["
        hh: mm: ss ",15,15*l],["
        hh: mm: ss ",30,30*l],["
        hh: mm\ nMM - dd ",1,u],["
        hh: mm\ nMM - dd ",5,5*u],["
        hh: mm\ nMM - dd ",10,10*u],["
        hh: mm\ nMM - dd ",15,15*u],["
        hh: mm\ nMM - dd ",30,30*u],["
        hh: mm\ nMM - dd ",1,c],["
        hh: mm\ nMM - dd ",2,2*c],["
        hh: mm\ nMM - dd ",6,6*c],["
        hh: mm\ nMM - dd ",12,12*c],["
        MM - dd\ nyyyy ",1,h],["
                                    week ",7,7*h],["
                                    month ",1,31*h],["
                                    quarter ",3,380*h/4],["
        half - year ",6,380*h/2],["
                                    year ",1,380*h]];return d[X]=function(){return new d},d}),e("
        echarts / scale / Log ",[me,de,". / Scale ",".. / util / number ",". / Interval "],function(t){function e(t,e){return u(t,l(e))}var i=t(de),n=t(". / Scale "),r=t(".. / util / number "),a=t(". / Interval "),o=n[he],s=a[he],l=r.getPrecisionSafe,u=r.round,c=Math.floor,h=Math.ceil,f=Math.pow,d=Math.log,p=n[H]({type:"
                                    log ",base:10,$constructor:function(){n.apply(this,arguments),this._originalScale=new a},getTicks:function(){var t=this._originalScale,n=this._extent,a=t[_]();return i.map(s[y].call(this),function(i){var o=r.round(f(this.base,i));return o=i===n[0]&&t.__fixMin?e(o,a[0]):o,o=i===n[1]&&t.__fixMax?e(o,a[1]):o},this)},getLabel:s.getLabel,scale:function(t){return t=o.scale.call(this,t),f(this.base,t)},setExtent:function(t,e){var i=this.base;t=d(t)/d(i),e=d(e)/d(i),s.setExtent.call(this,t,e)},getExtent:function(){var t=this.base,i=o[_].call(this);i[0]=f(t,i[0]),i[1]=f(t,i[1]);var n=this._originalScale,r=n[_]();return n.__fixMin&&(i[0]=e(i[0],r[0])),n.__fixMax&&(i[1]=e(i[1],r[1])),i},unionExtent:function(t){this._originalScale.unionExtent(t);var e=this.base;t[0]=d(t[0])/d(e),t[1]=d(t[1])/d(e),o.unionExtent.call(this,t)},unionExtentFromData:function(t,e){this.unionExtent(t.getDataExtent(e,!0,function(t){return t>0}))},niceTicks:function(t){t=t||10;var e=this._extent,i=e[1]-e[0];if(!(1/0===i||0>=i)){var n=r.quantity(i),a=t/i*n;for(.5>=a&&(n*=10);!isNaN(n)&&Math.abs(n)<1&&Math.abs(n)>0;)n*=10;var o=[r.round(h(e[0]/n)*n),r.round(c(e[1]/n)*n)];this._interval=n,this._niceExtent=o}},niceExtent:function(t,e,i){s.niceExtent.call(this,t,e,i);var n=this._originalScale;n.__fixMin=e,n.__fixMax=i}});return i.each([x,"
                                    normalize "],function(t){p[he][t]=function(e){return e=d(e)/d(this.base),o[t].call(this,e)}}),p[X]=function(){return new p},p}),e(pe,[],function(){function t(t){var e={},i={},n=t.match(/Firefox\/([\d.]+)/),r=t.match(/MSIE\s([\d.]+)/)||t.match(/Trident\/.+?rv:(([\d.]+))/),a=t.match(/Edge\/([\d.]+)/),o=/micromessenger/i.test(t);return n&&(i.firefox=!0,i.version=n[1]),r&&(i.ie=!0,i.version=r[1]),a&&(i.edge=!0,i.version=a[1]),o&&(i.weChat=!0),{browser:i,os:e,node:!1,canvasSupported:document.createElement("
                                    canvas ").getContext?!0:!1,touchEventsSupported:"
                                    ontouchstart "in window&&!i.ie&&!i.edge,pointerEventsSupported:"
                                    onpointerdown "in window&&(i.edge||i.ie&&i.version>=11)}}var e={};return e=typeof navigator===g?{browser:{},os:{},node:!0,canvasSupported:!0}:t(navigator.userAgent)}),e("
        echarts / model / Global ",[me,de,".. / util / model ",". / Model ",". / Component ",". / globalDefault ",". / mixin / colorPalette "],function(t){function e(t,e){l.each(e,function(e,i){g.hasClass(i)||("
                                    object "==typeof e?t[i]=t[i]?l.merge(t[i],e,!1):l.clone(e):null==t[i]&&(t[i]=e))})}function i(t){t=t,this.option={},this.option[_]=1,this._componentsMap={},this._seriesIndices=null,e(t,this._theme.option),l.merge(t,y,!1),this.mergeOption(t)}function n(t,e){l[z](e)||(e=e?[e]:[]);var i={};return h(e,function(e){i[e]=(t[e]||[]).slice()}),i}function r(t,e,i){var n=e.type?e.type:i?i.subType:g.determineSubType(t,e);return n}function a(t){return d(t,function(t){return t.componentIndex})||[]}function o(t,e){return e.hasOwnProperty("
                                    subType ")?f(t,function(t){return t.subType===e.subType}):t}function s(t){}var l=t(de),u=t(".. / util / model "),c=t(". / Model "),h=l.each,f=l.filter,d=l.map,p=l[z],m=l[J],v=l[oe],g=t(". / Component "),y=t(". / globalDefault "),_="\
                                    x00_ec_inner ",x=c[H]({constructor:x,init:function(t,e,i,n){i=i||{},this.option=null,this._theme=new c(i),this._optionManager=n},setOption:function(t,e){l.assert(!(_ in t),"
                                    please use chart.getOption()
        "),this._optionManager.setOption(t,e),this.resetOption()},resetOption:function(t){var e=!1,n=this._optionManager;if(!t||"
                                    recreate "===t){var r=n.mountOption("
                                    recreate "===t);this.option&&"
                                    recreate "!==t?(this.restoreData(),this.mergeOption(r)):i.call(this,r),e=!0}if(("
                                    timeline "===t||"
                                    media "===t)&&this.restoreData(),!t||"
                                    recreate "===t||"
                                    timeline "===t){var a=n.getTimelineOption(this);a&&(this.mergeOption(a),e=!0)}if(!t||"
                                    recreate "===t||"
                                    media "===t){var o=n.getMediaOption(this,this._api);o[te]&&h(o,function(t){this.mergeOption(t,e=!0)},this)}return e},mergeOption:function(t){function e(e,s){var c=u.normalizeToArray(t[e]),f=u.mappingToExists(o[e],c);u.makeIdAndName(f),h(f,function(t){var i=t.option;v(i)&&(t.keyInfo.mainType=e,t.keyInfo.subType=r(e,i,t.exist))});var d=n(o,s);i[e]=[],o[e]=[],h(f,function(t,n){var r=t.exist,a=t.option;if(l.assert(v(a)||r,"
                                    Empty component definition "),a){var s=g.getClass(e,t.keyInfo.subType,!0);if(r&&r instanceof s)r.name=t.keyInfo.name,r.mergeOption(a,this),r.optionUpdated(a,!1);else{var u=l[H]({dependentModels:d,componentIndex:n},t.keyInfo);r=new s(a,this,this,u),l[H](r,u),r.init(a,this,this,u),r.optionUpdated(null,!0)}}else r.mergeOption({},this),r.optionUpdated({},!1);o[e][n]=r,i[e][n]=r.option},this),e===W&&(this._seriesIndices=a(o[W]))}var i=this.option,o=this._componentsMap,s=[];h(t,function(t,e){null!=t&&(g.hasClass(e)?s.push(e):i[e]=null==i[e]?l.clone(t):l.merge(i[e],t,!0))}),g.topologicalTravel(s,g.getAllClassMainTypes(),e,this),this._seriesIndices=this._seriesIndices||[]},getOption:function(){var t=l.clone(this.option);return h(t,function(e,i){if(g.hasClass(i)){for(var e=u.normalizeToArray(e),n=e[te]-1;n>=0;n--)u.isIdInner(e[n])&&e[F](n,1);t[i]=e}}),delete t[_],t},getTheme:function(){return this._theme},getComponent:function(t,e){var i=this._componentsMap[t];return i?i[e||0]:void 0},queryComponents:function(t){var e=t.mainType;if(!e)return[];var i=t.index,n=t.id,r=t.name,a=this._componentsMap[e];if(!a||!a[te])return[];var s;if(null!=i)p(i)||(i=[i]),s=f(d(i,function(t){return a[t]}),function(t){return!!t});else if(null!=n){var l=p(n);s=f(a,function(t){return l&&m(n,t.id)>=0||!l&&t.id===n})}else if(null!=r){var u=p(r);s=f(a,function(t){return u&&m(r,t.name)>=0||!u&&t.name===r})}else s=a;return o(s,t)},findComponents:function(t){function e(t){var e=r+"
                                    Index ",i=r+"
                                    Id ",n=r+"
                                    Name ";return!t||null==t[e]&&null==t[i]&&null==t[n]?null:{mainType:r,index:t[e],id:t[i],name:t[n]}}function i(e){return t.filter?f(e,t.filter):e}var n=t.query,r=t.mainType,a=e(n),s=a?this.queryComponents(a):this._componentsMap[r];return i(o(s,t))},eachComponent:function(t,e,i){var n=this._componentsMap;if(typeof t===L)i=e,e=t,h(n,function(t,n){h(t,function(t,r){e.call(i,n,t,r)})});else if(l.isString(t))h(n[t],e,i);else if(v(t)){var r=this.findComponents(t);h(r,e,i)}},getSeriesByName:function(t){var e=this._componentsMap[W];return f(e,function(e){return e.name===t})},getSeriesByIndex:function(t){return this._componentsMap[W][t]},getSeriesByType:function(t){var e=this._componentsMap[W];return f(e,function(e){return e.subType===t})},getSeries:function(){return this._componentsMap[W].slice()},eachSeries:function(t,e){s(this),h(this._seriesIndices,function(i){var n=this._componentsMap[W][i];t.call(e,n,i)},this)},eachRawSeries:function(t,e){h(this._componentsMap[W],t,e)},eachSeriesByType:function(t,e,i){s(this),h(this._seriesIndices,function(n){var r=this._componentsMap[W][n];r.subType===t&&e.call(i,r,n)},this)},eachRawSeriesByType:function(t,e,i){return h(this.getSeriesByType(t),e,i)},isSeriesFiltered:function(t){return s(this),l[J](this._seriesIndices,t.componentIndex)<0},filterSeries:function(t,e){s(this);var i=f(this._componentsMap[W],t,e);this._seriesIndices=a(i)},restoreData:function(){var t=this._componentsMap;this._seriesIndices=a(t[W]);var e=[];h(t,function(t,i){e.push(i)}),g.topologicalTravel(e,g.getAllClassMainTypes(),function(e){h(t[e],function(t){t.restoreData()})})}});return l.mixin(x,t(". / mixin / colorPalette ")),x}),e("
        echarts / ExtensionAPI ",[me,de],function(t){function e(t){i.each(n,function(e){this[e]=i.bind(t[e],t)},this)}var i=t(de),n=["
                                    getDom ","
                                    getZr ",re,ne,"
                                    dispatchAction ","
                                    isDisposed ","
                                    on ","
                                    off ","
                                    getDataURL ","
                                    getConnectedDataURL ",ae,"
                                    getOption "];return e}),e("
        echarts / CoordinateSystem ",[me,de],function(t){function e(){this._coordinateSystems=[]}var i=t(de),n={};return e[he]={constructor:e,create:function(t,e){var r=[];i.each(n,function(i){var n=i[X](t,e);r=r[v](n||[])}),this._coordinateSystems=r},update:function(t,e){i.each(this._coordinateSystems,function(i){i[U]&&i[U](t,e)})},getCoordinateSystems:function(){return this._coordinateSystems.slice()}},e.register=function(t,e){n[t]=e},e.get=function(t){return n[t]},e}),e("
        echarts / model / OptionManager ",[me,de,".. / util / model ",". / Component "],function(t){function e(t){this._api=t,this._timelineOptions=[],this._mediaList=[],this._mediaDefault,this._currentMediaIndices=[],this._optionBackup,this._newBaseOption}function i(t,e,i){var n,r,a=[],o=[],l=t.timeline;if(t.baseOption&&(r=t.baseOption),(l||t.options)&&(r=r||{},a=(t.options||[]).slice()),t.media){r=r||{};var u=t.media;c(u,function(t){t&&t.option&&(t.query?o.push(t):n||(n=t))})}return r||(r=t),r.timeline||(r.timeline=l),c([r][v](a)[v](s.map(o,function(t){return t.option})),function(t){c(e,function(e){e(t,i)})}),{baseOption:r,timelineOptions:a,mediaDefault:n,mediaList:o}}function n(t,e,i){var n={width:e,height:i,aspectratio:e/i},a=!0;return s.each(t,function(t,e){var i=e.match(p);if(i&&i[1]&&i[2]){var o=i[1],s=i[2][fe]();r(n[s],t,o)||(a=!1)}}),a}function r(t,e,i){return"
                                    min "===i?t>=e:"
                                    max "===i?e>=t:t===e}function a(t,e){return t.join(", ")===e.join(", ")}function o(t,e){e=e||{},c(e,function(e,i){if(null!=e){var n=t[i];if(u.hasClass(i)){e=l.normalizeToArray(e),n=l.normalizeToArray(n);var r=l.mappingToExists(n,e);t[i]=f(r,function(t){return t.option&&t.exist?d(t.exist,t.option,!0):t.exist||t.option})}else t[i]=d(n,e,!0)}})}var s=t(de),l=t(".. / util / model "),u=t(". / Component "),c=s.each,h=s.clone,f=s.map,d=s.merge,p=/^(min|max)?(.+)$/;return e[he]={constructor:e,setOption:function(t,e){t=h(t,!0);var n=this._optionBackup,r=i.call(this,t,e,!n);this._newBaseOption=r.baseOption,n?(o(n.baseOption,r.baseOption),r.timelineOptions[te]&&(n.timelineOptions=r.timelineOptions),r.mediaList[te]&&(n.mediaList=r.mediaList),r.mediaDefault&&(n.mediaDefault=r.mediaDefault)):this._optionBackup=r
    }, mountOption : function (t) {
        var e = this._optionBackup;
        return this._timelineOptions = f(e.timelineOptions, h), this._mediaList = f(e.mediaList, h), this._mediaDefault = h(e.mediaDefault), this._currentMediaIndices = [], h(t ? e.baseOption : this._newBaseOption)
    }, getTimelineOption: function (t) {
        var e, i = this._timelineOptions;
        if (i[te]) {
            var n = t.getComponent("timeline");
            n && (e = h(i[n.getCurrentIndex()], !0))
        }
        return e
    }, getMediaOption: function () {
        var t = this._api[re](),
            e = this._api[ne](),
            i = this._mediaList,
            r = this._mediaDefault,
            o = [],
            s = [];
        if (!i[te] && !r) return s;
        for (var l = 0, u = i[te]; u > l; l++) n(i[l].query, t, e) && o.push(l);
        return !o[te] && r && (o = [-1]), o[te] && !a(o, this._currentMediaIndices) && (s = f(o, function (t) {
            return h(-1 === t ? r.option : i[t].option)
        })), this._currentMediaIndices = o, s
    }
                            }, e
                        }), e("echarts/model/Component", [me, "./Model", de, "../util/component", "../util/clazz", "../util/layout", "./mixin/boxLayout"], function (t) {
        function e(t) {
            var e = [];
            return n.each(l.getClassesByMainType(t), function (t) {
                r.apply(e, t[he].dependencies || [])
            }), n.map(e, function (t) {
                return o.parseClassType(t).main
            })
        }
        var i = t("./Model"),
            n = t(de),
            r = Array[he].push,
            a = t("../util/component"),
            o = t("../util/clazz"),
            s = t("../util/layout"),
            l = i[H]({
                type: "component",
                id: "",
                name: "",
                mainType: "",
                subType: "",
                componentIndex: 0,
                defaultOption: null,
                ecModel: null,
                dependentModels: [],
                uid: null,
                layoutMode: null,
                $constructor: function (t, e, n, r) {
                    i.call(this, t, e, n, r), this.uid = a.getUID("componentModel")
                },
                init: function (t, e, i) {
                    this.mergeDefaultAndTheme(t, i)
                },
                mergeDefaultAndTheme: function (t, e) {
                    var i = this.layoutMode,
                        r = i ? s.getLayoutParams(t) : {},
                        a = e.getTheme();
                    n.merge(t, a.get(this.mainType)), n.merge(t, this.getDefaultOption()), i && s.mergeLayoutParam(t, r, i)
                },
                mergeOption: function (t) {
                    n.merge(this.option, t, !0);
                    var e = this.layoutMode;
                    e && s.mergeLayoutParam(this.option, t, e)
                },
                optionUpdated: function () { },
                getDefaultOption: function () {
                    if (!o.hasOwn(this, "__defaultOption")) {
                        for (var t = [], e = this.constructor; e;) {
                            var i = e[he].defaultOption;
                            i && t.push(i), e = e.superClass
                        }
                        for (var r = {}, a = t[te] - 1; a >= 0; a--) r = n.merge(r, t[a], !0);
                        o.set(this, "__defaultOption", r)
                    }
                    return o.get(this, "__defaultOption")
                },
                getReferringComponents: function (t) {
                    return this[m].queryComponents({
                        mainType: t,
                        index: this.get(t + "Index", !0),
                        id: this.get(t + "Id", !0)
                    })
                }
            });
        return o.enableClassManagement(l, {
            registerWhenExtend: !0
        }), a.enableSubTypeDefaulter(l), a.enableTopologicalTravel(l, e), n.mixin(l, t("./mixin/boxLayout")), l
    }), e("echarts/model/Series", [me, de, "../util/format", "../util/clazz", "../util/model", "./Component", "./mixin/colorPalette", pe, "../util/layout"], function (t) {
        var e = t(de),
            i = t("../util/format"),
            n = t("../util/clazz"),
            r = t("../util/model"),
            a = t("./Component"),
            o = t("./mixin/colorPalette"),
            s = t(pe),
            l = t("../util/layout"),
            u = n.set,
            c = n.get,
            h = i.encodeHTML,
            f = i.addCommas,
            v = a[H]({
                type: "series.__base__",
                seriesIndex: 0,
                coordinateSystem: null,
                defaultOption: null,
                legendDataProvider: null,
                visualColorAccessPath: "itemStyle.normal.color",
                layoutMode: null,
                init: function (t, e, i) {
                    this[R] = this.componentIndex, this.mergeDefaultAndTheme(t, i), u(this, "dataBeforeProcessed", this.getInitialData(t, i)), this.restoreData()
                },
                mergeDefaultAndTheme: function (t, i) {
                    var n = this.layoutMode,
                        a = n ? l.getLayoutParams(t) : {};
                    e.merge(t, i.getTheme().get(this.subType)), e.merge(t, this.getDefaultOption()), r.defaultEmphasis(t.label, r.LABEL_OPTIONS), this.fillDataTextStyle(t.data), n && l.mergeLayoutParam(t, a, n)
                },
                mergeOption: function (t, i) {
                    t = e.merge(this.option, t, !0), this.fillDataTextStyle(t.data);
                    var n = this.layoutMode;
                    n && l.mergeLayoutParam(this.option, t, n);
                    var r = this.getInitialData(t, i);
                    r && (u(this, "data", r), u(this, "dataBeforeProcessed", r.cloneShallow()))
                },
                fillDataTextStyle: function (t) {
                    if (t)
                        for (var e = 0; e < t[te]; e++) t[e] && t[e].label && r.defaultEmphasis(t[e].label, r.LABEL_OPTIONS)
                },
                getInitialData: function () { },
                getData: function (t) {
                    var e = c(this, "data");
                    return null == t ? e : e.getLinkedData(t)
                },
                setData: function (t) {
                    u(this, "data", t)
                },
                getRawData: function () {
                    return c(this, "dataBeforeProcessed")
                },
                coordDimToDataDim: function (t) {
                    return [t]
                },
                dataDimToCoordDim: function (t) {
                    return t
                },
                getBaseAxis: function () {
                    var t = this[K];
                    return t && t.getBaseAxis && t.getBaseAxis()
                },
                formatTooltip: function (t, n) {
                    function r(t) {
                        var r = [];
                        return e.each(t, function (t, e) {
                            var o, s = a.getDimensionInfo(e),
                                l = s && s.type;
                            o = l === p ? t + "" : "time" === l ? n ? "" : i.formatTime("yyyy/MM/dd hh:mm:ss", t) : f(t), o && r.push(o)
                        }), r.join(", ")
                    }
                    var a = c(this, "data"),
                        o = this.getRawValue(t),
                        s = h(e[z](o) ? r(o) : f(o)),
                        l = a.getName(t),
                        u = a[Y](t, "color");
                    e[oe](u) && u[j] && (u = (u[j][0] || {}).color), u = u || "transparent";
                    var d = '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + h(u) + '"></span>',
                        m = this.name;
                    return "\x00-" === m && (m = ""), n ? d + h(this.name) + " : " + s : (m && h(m) + "<br />") + d + (l ? h(l) + " : " + s : s)
                },
                isAnimationEnabled: function () {
                    if (s.node) return !1;
                    var t = this[d](le);
                    return t && this[Q]().count() > this[d]("animationThreshold") && (t = !1), t
                },
                restoreData: function () {
                    u(this, "data", c(this, "dataBeforeProcessed").cloneShallow())
                },
                getColorFromPalette: function (t, e) {
                    var i = this[m],
                        n = o.getColorFromPalette.call(this, t, e);
                    return n || (n = i.getColorFromPalette(t, e)), n
                },
                getAxisTooltipDataIndex: null,
                getTooltipPosition: null
            });
        return e.mixin(v, r.dataFormatMixin), e.mixin(v, o), v
    }), e("echarts/view/Component", [me, "zrender/container/Group", "../util/component", "../util/clazz"], function (t) {
        var e = t("zrender/container/Group"),
            i = t("../util/component"),
            n = t("../util/clazz"),
            r = function () {
                this.group = new e, this.uid = i.getUID("viewComponent")
            };
        r[he] = {
            constructor: r,
            init: function () { },
            render: function () { },
            dispose: function () { }
        };
        var a = r[he];
        return a.updateView = a.updateLayout = a.updateVisual = function () { }, n.enableClassExtend(r), n.enableClassManagement(r, {
            registerWhenExtend: !0
        }), r
    }), e("echarts/view/Chart", [me, "zrender/container/Group", "../util/component", "../util/clazz", "../util/model", de], function (t) {
        function e() {
            this.group = new r, this.uid = a.getUID("viewChart")
        }

        function i(t, e) {
            if (t && (t[G](e), "group" === t.type))
                for (var n = 0; n < t.childCount(); n++) i(t.childAt(n), e)
        }

        function n(t, e, n) {
            var r = s.queryDataIndex(t, e);
            null != r ? l.each(s.normalizeToArray(r), function (e) {
                i(t[f](e), n)
            }) : t[h](function (t) {
                i(t, n)
            })
        }
        var r = t("zrender/container/Group"),
            a = t("../util/component"),
            o = t("../util/clazz"),
            s = t("../util/model"),
            l = t(de);
        e[he] = {
            type: "chart",
            init: function () { },
            render: function () { },
            highlight: function (t, e, i, r) {
                n(t[Q](), r, "emphasis")
            },
            downplay: function (t, e, i, r) {
                n(t[Q](), r, "normal")
            },
            remove: function () {
                this.group[P]()
            },
            dispose: function () { }
        };
        var u = e[he];
        return u.updateView = u.updateLayout = u.updateVisual = function (t, e, i, n) {
            this.render(t, e, i, n)
        }, o.enableClassExtend(e, ["dispose"]), o.enableClassManagement(e, {
            registerWhenExtend: !0
        }), e
    }), e("echarts/util/graphic", [me, de, "zrender/tool/path", "zrender/graphic/Path", "zrender/tool/color", "zrender/core/matrix", "zrender/core/vector", "zrender/container/Group", "zrender/graphic/Image", "zrender/graphic/Text", "zrender/graphic/shape/Circle", "zrender/graphic/shape/Sector", "zrender/graphic/shape/Ring", "zrender/graphic/shape/Polygon", "zrender/graphic/shape/Polyline", "zrender/graphic/shape/Rect", "zrender/graphic/shape/Line", "zrender/graphic/shape/BezierCurve", "zrender/graphic/shape/Arc", "zrender/graphic/CompoundPath", "zrender/graphic/LinearGradient", "zrender/graphic/RadialGradient", "zrender/core/BoundingRect"], function (t) {
        function e(t) {
            return null != t && "none" != t
        }

        function i(t) {
            return typeof t === ce ? T.lift(t, -.1) : t
        }

        function n(t) {
            if (t.__hoverStlDirty) {
                var n = t.style[u],
                    r = t.style.fill,
                    a = t.__hoverStl;
                a.fill = a.fill || (e(r) ? i(r) : null), a[u] = a[u] || (e(n) ? i(n) : null);
                var o = {};
                for (var s in a) a.hasOwnProperty(s) && (o[s] = t.style[s]);
                t.__normalStl = o, t.__hoverStlDirty = !1
            }
        }

        function r(t) {
            t.__isHover || (n(t), t.useHoverLayer ? t.__zr && t.__zr.addHover(t, t.__hoverStl) : (t[O](t.__hoverStl), t.z2 += 1), t.__isHover = !0)
        }

        function a(t) {
            if (t.__isHover) {
                var e = t.__normalStl;
                t.useHoverLayer ? t.__zr && t.__zr.removeHover(t) : (e && t[O](e), t.z2 -= 1), t.__isHover = !1
            }
        }

        function o(t) {
            "group" === t.type ? t[B](function (t) {
                "group" !== t.type && r(t)
            }) : r(t)
        }

        function s(t) {
            "group" === t.type ? t[B](function (t) {
                "group" !== t.type && a(t)
            }) : a(t)
        }

        function h(t, e) {
            t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0, t.__isHover && n(t)
        }

        function f(t) {
            this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && o(this)
        }

        function p(t) {
            this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && s(this)
        }

        function m() {
            this.__isEmphasis = !0, o(this)
        }

        function v() {
            this.__isEmphasis = !1, s(this)
        }

        function g(t, e, i, n, r, a) {
            typeof r === L && (a = r, r = null);
            var o = n && n.isAnimationEnabled();
            if (o) {
                var s = t ? "Update" : "",
                    l = n[d]("animationDuration" + s),
                    u = n[d]("animationEasing" + s),
                    c = n[d]("animationDelay" + s);
                typeof c === L && (c = c(r, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, r) : null)), typeof l === L && (l = l(r)), l > 0 ? e.animateTo(i, l, c || 0, u, a) : (e.attr(i), a && a())
            } else e.attr(i), a && a()
        }
        var y = t(de),
            _ = t("zrender/tool/path"),
            x = Math.round,
            b = t("zrender/graphic/Path"),
            T = t("zrender/tool/color"),
            P = t("zrender/core/matrix"),
            k = t("zrender/core/vector"),
            z = {};
        return z.Group = t("zrender/container/Group"), z.Image = t("zrender/graphic/Image"), z.Text = t("zrender/graphic/Text"), z.Circle = t("zrender/graphic/shape/Circle"), z.Sector = t("zrender/graphic/shape/Sector"), z.Ring = t("zrender/graphic/shape/Ring"), z.Polygon = t("zrender/graphic/shape/Polygon"), z.Polyline = t("zrender/graphic/shape/Polyline"), z.Rect = t("zrender/graphic/shape/Rect"), z.Line = t("zrender/graphic/shape/Line"), z.BezierCurve = t("zrender/graphic/shape/BezierCurve"), z.Arc = t("zrender/graphic/shape/Arc"), z.CompoundPath = t("zrender/graphic/CompoundPath"), z.LinearGradient = t("zrender/graphic/LinearGradient"), z.RadialGradient = t("zrender/graphic/RadialGradient"), z.BoundingRect = t("zrender/core/BoundingRect"), z.extendShape = function (t) {
            return b[H](t)
        }, z.extendPath = function (t, e) {
            return _.extendFromString(t, e)
        }, z.makePath = function (t, e, i, n) {
            var r = _.createFromString(t, e),
                a = r[S]();
            if (i) {
                var o = a.width / a[ue];
                if (n === M) {
                    var s, l = i[ue] * o;
                    l <= i.width ? s = i[ue] : (l = i.width, s = l / o);
                    var u = i.x + i.width / 2,
                        c = i.y + i[ue] / 2;
                    i.x = u - l / 2, i.y = c - s / 2, i.width = l, i[ue] = s
                }
                z.resizePath(r, i)
            }
            return r
        }, z.mergePath = _.mergePath, z.resizePath = function (t, e) {
            if (t[c]) {
                var i = t[S](),
                    n = i.calculateTransform(e);
                t[c](n)
            }
        }, z.subPixelOptimizeLine = function (t) {
            var e = z.subPixelOptimize,
                i = t.shape,
                n = t.style.lineWidth;
            return x(2 * i.x1) === x(2 * i.x2) && (i.x1 = i.x2 = e(i.x1, n, !0)), x(2 * i.y1) === x(2 * i.y2) && (i.y1 = i.y2 = e(i.y1, n, !0)), t
        }, z.subPixelOptimizeRect = function (t) {
            var e = z.subPixelOptimize,
                i = t.shape,
                n = t.style.lineWidth,
                r = i.x,
                a = i.y,
                o = i.width,
                s = i[ue];
            return i.x = e(i.x, n, !0), i.y = e(i.y, n, !0), i.width = Math.max(e(r + o, n, !1) - i.x, 0 === o ? 0 : 1), i[ue] = Math.max(e(a + s, n, !1) - i.y, 0 === s ? 0 : 1), t
        }, z.subPixelOptimize = function (t, e, i) {
            var n = x(2 * t);
            return (n + x(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2
        }, z.setHoverStyle = function (t, e, i) {
            t.__hoverSilentOnTouch = i && i.hoverSilentOnTouch, "group" === t.type ? t[B](function (t) {
                "group" !== t.type && h(t, e)
            }) : h(t, e), t.on("mouseover", f).on(N, p), t.on("emphasis", m).on("normal", v)
        }, z.setText = function (t, e, i) {
            var n = e[d](w) || "inside",
                r = e[d]("offset"),
                a = n[J]("inside") >= 0 ? "white" : i,
                o = e[ae](A);
            y[H](t, {
                textDistance: e[d]("distance") || 5,
                textFont: o[C](),
                textPosition: n,
                textOffset: r,
                textFill: o.getTextColor() || a
            })
        }, z.updateProps = function (t, e, i, n, r) {
            g(!0, t, e, i, n, r)
        }, z.initProps = function (t, e, i, n, r) {
            g(!1, t, e, i, n, r)
        }, z.getTransform = function (t, e) {
            for (var i = P.identity([]); t && t !== e;) P.mul(i, t.getLocalTransform(), i), t = t[l];
            return i
        }, z[c] = function (t, e, i) {
            return i && (e = P.invert([], e)), k[c]([], t, e)
        }, z.transformDirection = function (t, e, i) {
            var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
                r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
                a = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -r : t === ee ? r : 0];
            return a = z[c](a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? ee : "top"
        }, z.groupTransition = function (t, e, i) {
            function n(t) {
                var e = {};
                return t[B](function (t) {
                    !t.isGroup && t.anid && (e[t.anid] = t)
                }), e
            }

            function r(t) {
                var e = {
                    position: k.clone(t[w]),
                    rotation: t.rotation
                };
                return t.shape && (e.shape = y[H]({}, t.shape)), e
            }
            if (t && e) {
                var a = n(t);
                e[B](function (t) {
                    if (!t.isGroup && t.anid) {
                        var e = a[t.anid];
                        if (e) {
                            var n = r(t);
                            t.attr(r(e)), z.updateProps(t, n, i, t[$])
                        }
                    }
                })
            }
        }, z
    }), e("echarts/util/model", [me, "./format", "./number", "../model/Model", de], function (t) {
        function e(t, e) {
            return t && t.hasOwnProperty(e)
        }
        var i = t("./format"),
            n = t("./number"),
            r = t("../model/Model"),
            a = t(de),
            l = a.each,
            u = a[oe],
            c = {};
        return c.normalizeToArray = function (t) {
            return t instanceof Array ? t : null == t ? [] : [t]
        }, c.defaultEmphasis = function (t, e) {
            if (t) {
                var i = t.emphasis = t.emphasis || {},
                    n = t.normal = t.normal || {};
                l(e, function (t) {
                    var e = a[s](i[t], n[t]);
                    null != e && (i[t] = e)
                })
            }
        }, c.LABEL_OPTIONS = [w, "offset", "show", A, "distance", "formatter"], c.getDataItemValue = function (t) {
            return t && (null == t.value ? t : t.value)
        }, c.isDataItemOption = function (t) {
            return u(t) && !(t instanceof Array)
        }, c.converDataValue = function (t, e) {
            var i = e && e.type;
            return i === p ? t : ("time" !== i || isFinite(t) || null == t || "-" === t || (t = +n.parseDate(t)), null == t || "" === t ? 0 / 0 : +t)
        }, c.createDataFormatModel = function (t, e) {
            var i = new r;
            return a.mixin(i, c.dataFormatMixin), i[R] = e[R], i.name = e.name || "", i.mainType = e.mainType, i.subType = e.subType, i[Q] = function () {
                return t
            }, i
        }, c.dataFormatMixin = {
            getDataParams: function (t, e) {
                var i = this[Q](e),
                    n = this[R],
                    r = this.name,
                    a = this.getRawValue(t, e),
                    o = i.getRawIndex(t),
                    s = i.getName(t, !0),
                    l = i.getRawDataItem(t);
                return {
                    componentType: this.mainType,
                    componentSubType: this.subType,
                    seriesType: this.mainType === W ? this.subType : null,
                    seriesIndex: n,
                    seriesName: r,
                    name: s,
                    dataIndex: o,
                    data: l,
                    dataType: e,
                    value: a,
                    color: i[Y](t, "color"),
                    $vars: ["seriesName", "name", "value"]
                }
            },
            getFormattedLabel: function (t, e, n, r) {
                e = e || "normal";
                var a = this[Q](n),
                    s = a[o](t),
                    l = this[E](t, n);
                null != r && l.value instanceof Array && (l.value = l.value[r]);
                var u = s.get(["label", e, "formatter"]);
                return typeof u === L ? (l.status = e, u(l)) : typeof u === ce ? i.formatTpl(u, l) : void 0
            },
            getRawValue: function (t, e) {
                var i = this[Q](e),
                    n = i.getRawDataItem(t);
                return null != n ? !u(n) || n instanceof Array ? n : n.value : void 0
            },
            formatTooltip: a.noop
        }, c.mappingToExists = function (t, e) {
            e = (e || []).slice();
            var i = a.map(t || [], function (t) {
                return {
                    exist: t
                }
            });
            return l(e, function (t, n) {
                if (u(t)) {
                    for (var r = 0; r < i[te]; r++)
                        if (!i[r].option && null != t.id && i[r].exist.id === t.id + "") return i[r].option = t, void (e[n] = null);
                    for (var r = 0; r < i[te]; r++) {
                        var a = i[r].exist;
                        if (!(i[r].option || null != a.id && null != t.id || null == t.name || c.isIdInner(t) || c.isIdInner(a) || a.name !== t.name + "")) return i[r].option = t, void (e[n] = null)
                    }
                }
            }), l(e, function (t) {
                if (u(t)) {
                    for (var e = 0; e < i[te]; e++) {
                        var n = i[e].exist;
                        if (!i[e].option && !c.isIdInner(n) && null == t.id) {
                            i[e].option = t;
                            break
                        }
                    }
                    e >= i[te] && i.push({
                        option: t
                    })
                }
            }), i
        }, c.makeIdAndName = function (t) {
            var e = {};
            l(t, function (t) {
                var i = t.exist;
                i && (e[i.id] = t)
            }), l(t, function (t) {
                var i = t.option;
                a.assert(!i || null == i.id || !e[i.id] || e[i.id] === t, "id duplicates: " + (i && i.id)), i && null != i.id && (e[i.id] = t), !t.keyInfo && (t.keyInfo = {})
            }), l(t, function (t) {
                var i = t.exist,
                    n = t.option,
                    r = t.keyInfo;
                if (u(n)) {
                    if (r.name = null != n.name ? n.name + "" : i ? i.name : "\x00-", i) r.id = i.id;
                    else if (null != n.id) r.id = n.id + "";
                    else {
                        var a = 0;
                        do r.id = "\x00" + r.name + "\x00" + a++; while (e[r.id])
                    }
                    e[r.id] = t
                }
            })
        }, c.isIdInner = function (t) {
            return u(t) && t.id && 0 === (t.id + "")[J]("\x00_ec_\x00")
        }, c.compressBatches = function (t, e) {
            function i(t, e, i) {
                for (var n = 0, r = t[te]; r > n; n++)
                    for (var a = t[n].seriesId, o = c.normalizeToArray(t[n][$]), s = i && i[a], l = 0, u = o[te]; u > l; l++) {
                        var h = o[l];
                        s && s[h] ? s[h] = null : (e[a] || (e[a] = {}))[h] = 1
                    }
            }

            function n(t, e) {
                var i = [];
                for (var r in t)
                    if (t.hasOwnProperty(r) && null != t[r])
                        if (e) i.push(+r);
                        else {
                            var a = n(t[r], !0);
                            a[te] && i.push({
                                seriesId: r,
                                dataIndex: a
                            })
                        } return i
            }
            var r = {},
                a = {};
            return i(t || [], r), i(e || [], a, r), [n(r), n(a)]
        }, c.queryDataIndex = function (t, e) {
            return null != e.dataIndexInside ? e.dataIndexInside : null != e[$] ? a[z](e[$]) ? a.map(e[$], function (e) {
                return t.indexOfRawIndex(e)
            }) : t.indexOfRawIndex(e[$]) : null != e.name ? a[z](e.name) ? a.map(e.name, function (e) {
                return t.indexOfName(e)
            }) : t.indexOfName(e.name) : void 0
        }, c.parseFinder = function (t, i, n) {
            if (a.isString(i)) {
                var r = {};
                r[i + "Index"] = 0, i = r
            }
            var o = n && n.defaultMainType;
            !o || e(i, o + "Index") || e(i, o + "Id") || e(i, o + "Name") || (i[o + "Index"] = 0);
            var s = {};
            return l(i, function (e, n) {
                var e = i[n];
                if (n === $ || "dataIndexInside" === n) return void (s[n] = e);
                var r = n.match(/^(\w+)(Index|Id|Name)$/) || [],
                    a = r[1],
                    o = r[2];
                if (a && o) {
                    var l = {
                        mainType: a
                    };
                    l[o[fe]()] = e;
                    var u = t.queryComponents(l);
                    s[a + "Models"] = u, s[a + "Model"] = u[0]
                }
            }), s
        }, c
    }), e("echarts/util/throttle", [], function () {
        var t = {},
            e = "\x00__throttleOriginMethod",
            i = "\x00__throttleRate",
            n = "\x00__throttleType";
        return t.throttle = function (t, e, i) {
            function n() {
                u = (new Date).getTime(), c = null, t.apply(o, s || [])
            }
            var r, a, o, s, l = 0,
                u = 0,
                c = null;
            e = e || 0;
            var h = function () {
                r = (new Date).getTime(), o = this, s = arguments, a = r - (i ? l : u) - e, clearTimeout(c), i ? c = setTimeout(n, e) : a >= 0 ? n() : c = setTimeout(n, -a), l = r
            };
            return h.clear = function () {
                c && (clearTimeout(c), c = null)
            }, h
        }, t.createOrUpdate = function (r, a, o, s) {
            var l = r[a];
            if (l) {
                var u = l[e] || l,
                    c = l[n],
                    h = l[i];
                if (h !== o || c !== s) {
                    if (null == o || !s) return r[a] = u;
                    l = r[a] = t.throttle(u, o, "debounce" === s), l[e] = u, l[n] = s, l[i] = o
                }
                return l
            }
        }, t.clear = function (t, i) {
            var n = t[i];
            n && n[e] && (t[i] = n[e])
        }, t
    }), e("zrender/zrender", [me, "./core/guid", "./core/env", "./core/util", "./Handler", "./Storage", "./animation/Animation", "./dom/HandlerProxy", "./Painter"], function (t) {
        function e(t) {
            delete h[t]
        }
        var i = t("./core/guid"),
            n = t("./core/env"),
            r = t("./core/util"),
            a = t("./Handler"),
            o = t("./Storage"),
            s = t("./animation/Animation"),
            l = t("./dom/HandlerProxy"),
            u = !n.canvasSupported,
            c = {
                canvas: t("./Painter")
            },
            h = {},
            f = {};
        f.version = "3.3.0", f.init = function (t, e) {
            var n = new d(i(), t, e);
            return h[n.id] = n, n
        }, f.dispose = function (t) {
            if (t) t.dispose();
            else {
                for (var e in h) h.hasOwnProperty(e) && h[e].dispose();
                h = {}
            }
            return f
        }, f.getInstance = function (t) {
            return h[t]
        }, f.registerPainter = function (t, e) {
            c[t] = e
        };
        var d = function (t, e, i) {
            i = i || {}, this.dom = e, this.id = t;
            var h = this,
                f = new o,
                d = i.renderer;
            if (u) {
                if (!c.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");
                d = "vml"
            } else d && c[d] || (d = "canvas");
            var p = new c[d](e, f, i);
            this.storage = f, this.painter = p;
            var m = n.node ? null : new l(p.getViewportRoot());
            this.handler = new a(f, p, m, p.root), this[le] = new s({
                stage: {
                    update: r.bind(this.flush, this)
                }
            }), this[le].start(), this._needsRefresh;
            var v = f.delFromMap,
                g = f.addToMap;
            f.delFromMap = function (t) {
                var e = f.get(t);
                v.call(f, t), e && e.removeSelfFromZr(h)
            }, f.addToMap = function (t) {
                g.call(f, t), t.addSelfToZr(h)
            }
        };
        return d[he] = {
            constructor: d,
            getId: function () {
                return this.id
            },
            add: function (t) {
                this.storage.addRoot(t), this._needsRefresh = !0
            },
            remove: function (t) {
                this.storage.delRoot(t), this._needsRefresh = !0
            },
            configLayer: function (t, e) {
                this.painter.configLayer(t, e), this._needsRefresh = !0
            },
            refreshImmediately: function () {
                this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1
            },
            refresh: function () {
                this._needsRefresh = !0
            },
            flush: function () {
                this._needsRefresh && this.refreshImmediately(), this._needsRefreshHover && this.refreshHoverImmediately()
            },
            addHover: function (t, e) {
                this.painter.addHover && (this.painter.addHover(t, e), this.refreshHover())
            },
            removeHover: function (t) {
                this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover())
            },
            clearHover: function () {
                this.painter.clearHover && (this.painter.clearHover(), this.refreshHover())
            },
            refreshHover: function () {
                this._needsRefreshHover = !0
            },
            refreshHoverImmediately: function () {
                this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover()
            },
            resize: function (t) {
                t = t || {}, this.painter.resize(t.width, t[ue]), this.handler.resize()
            },
            clearAnimation: function () {
                this[le].clear()
            },
            getWidth: function () {
                return this.painter[re]()
            },
            getHeight: function () {
                return this.painter[ne]()
            },
            pathToImage: function (t, e, n) {
                var r = i();
                return this.painter.pathToImage(r, t, e, n)
            },
            setCursorStyle: function (t) {
                this.handler.setCursorStyle(t)
            },
            on: function (t, e, i) {
                this.handler.on(t, e, i)
            },
            off: function (t, e) {
                this.handler.off(t, e)
            },
            trigger: function (t, e) {
                this.handler[G](t, e)
            },
            clear: function () {
                this.storage.delRoot(), this.painter.clear()
            },
            dispose: function () {
                this[le].stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this[le] = this.storage = this.painter = this.handler = null, e(this.id)
            }
        }, f
    }), e(de, [me], function () {
        function t(e) {
            if (null == e || "object" != typeof e) return e;
            var i = e,
                n = O.call(e);
            if ("[object Array]" === n) {
                i = [];
                for (var r = 0, a = e[te]; a > r; r++) i[r] = t(e[r])
            } else if (D[n]) i = e.constructor.from(e);
            else if (!I[n] && !T(e)) {
                i = {};
                for (var o in e) e.hasOwnProperty(o) && (i[o] = t(e[o]))
            }
            return i
        }

        function e(i, n, r) {
            if (!w(n) || !w(i)) return r ? t(n) : i;
            for (var a in n)
                if (n.hasOwnProperty(a)) {
                    var o = i[a],
                        s = n[a];
                    !w(s) || !w(o) || _(s) || _(o) || T(s) || T(o) || M(s) || M(o) ? !r && a in i || (i[a] = t(n[a], !0)) : e(o, s, r)
                } return i
        }

        function i(t, i) {
            for (var n = t[0], r = 1, a = t[te]; a > r; r++) n = e(n, t[r], i);
            return n
        }

        function n(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
            return t
        }

        function r(t, e, i) {
            for (var n in e) e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
            return t
        }

        function a() {
            return document.createElement("canvas")
        }

        function o() {
            return z || (z = V.createCanvas().getContext("2d")), z
        }

        function s(t, e) {
            if (t) {
                if (t[J]) return t[J](e);
                for (var i = 0, n = t[te]; n > i; i++)
                    if (t[i] === e) return i
            }
            return -1
        }

        function l(t, e) {
            function i() { }
            var n = t[he];
            i[he] = e[he], t[he] = new i;
            for (var r in n) t[he][r] = n[r];
            t[he].constructor = t, t.superClass = e
        }

        function u(t, e, i) {
            t = he in t ? t[he] : t, e = he in e ? e[he] : e, r(t, e, i)
        }

        function c(t) {
            return t ? typeof t == ce ? !1 : typeof t[te] == k : void 0
        }

        function h(t, e, i) {
            if (t && e)
                if (t.forEach && t.forEach === E) t.forEach(e, i);
                else if (t[te] === +t[te])
                    for (var n = 0, r = t[te]; r > n; n++) e.call(i, t[n], n, t);
                else
                    for (var a in t) t.hasOwnProperty(a) && e.call(i, t[a], a, t)
        }

        function f(t, e, i) {
            if (t && e) {
                if (t.map && t.map === F) return t.map(e, i);
                for (var n = [], r = 0, a = t[te]; a > r; r++) n.push(e.call(i, t[r], r, t));
                return n
            }
        }

        function d(t, e, i, n) {
            if (t && e) {
                if (t.reduce && t.reduce === G) return t.reduce(e, i, n);
                for (var r = 0, a = t[te]; a > r; r++) i = e.call(n, i, t[r], r, t);
                return i
            }
        }

        function p(t, e, i) {
            if (t && e) {
                if (t.filter && t.filter === R) return t.filter(e, i);
                for (var n = [], r = 0, a = t[te]; a > r; r++) e.call(i, t[r], r, t) && n.push(t[r]);
                return n
            }
        }

        function m(t, e, i) {
            if (t && e)
                for (var n = 0, r = t[te]; r > n; n++)
                    if (e.call(i, t[n], n, t)) return t[n]
        }

        function g(t, e) {
            var i = N.call(arguments, 2);
            return function () {
                return t.apply(e, i[v](N.call(arguments)))
            }
        }

        function y(t) {
            var e = N.call(arguments, 1);
            return function () {
                return t.apply(this, e[v](N.call(arguments)))
            }
        }

        function _(t) {
            return "[object Array]" === O.call(t)
        }

        function x(t) {
            return typeof t === L
        }

        function b(t) {
            return "[object String]" === O.call(t)
        }

        function w(t) {
            var e = typeof t;
            return e === L || !!t && "object" == e
        }

        function M(t) {
            return !!I[O.call(t)]
        }

        function T(t) {
            return "object" == typeof t && typeof t.nodeType === k && "object" == typeof t.ownerDocument
        }

        function S(t) {
            return t !== t
        }

        function C() {
            for (var t = 0, e = arguments[te]; e > t; t++)
                if (null != arguments[t]) return arguments[t]
        }

        function A() {
            return Function.call.apply(N, arguments)
        }

        function P(t, e) {
            if (!t) throw new Error(e)
        }
        var z, I = {
            "[object Function]": 1,
            "[object RegExp]": 1,
            "[object Date]": 1,
            "[object Error]": 1,
            "[object CanvasGradient]": 1,
            "[object CanvasPattern]": 1,
            "[object Image]": 1,
            "[object Canvas]": 1
        },
            D = {
                "[object Int8Array]": 1,
                "[object Uint8Array]": 1,
                "[object Uint8ClampedArray]": 1,
                "[object Int16Array]": 1,
                "[object Uint16Array]": 1,
                "[object Int32Array]": 1,
                "[object Uint32Array]": 1,
                "[object Float32Array]": 1,
                "[object Float64Array]": 1
            },
            O = Object[he].toString,
            B = Array[he],
            E = B.forEach,
            R = B.filter,
            N = B.slice,
            F = B.map,
            G = B.reduce,
            V = {
                inherits: l,
                mixin: u,
                clone: t,
                merge: e,
                mergeAll: i,
                extend: n,
                defaults: r,
                getContext: o,
                createCanvas: a,
                indexOf: s,
                slice: A,
                find: m,
                isArrayLike: c,
                each: h,
                map: f,
                reduce: d,
                filter: p,
                bind: g,
                curry: y,
                isArray: _,
                isString: b,
                isObject: w,
                isFunction: x,
                isBuildInObject: M,
                isDom: T,
                eqNaN: S,
                retrieve: C,
                assert: P,
                noop: function () { }
            };
        return V
    }), e("zrender/tool/color", [me], function () {
        function t(t) {
            return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t
        }

        function e(t) {
            return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t
        }

        function i(t) {
            return 0 > t ? 0 : t > 1 ? 1 : t
        }

        function n(e) {
            return t(e[te] && "%" === e.charAt(e[te] - 1) ? parseFloat(e) / 100 * 255 : parseInt(e, 10))
        }

        function r(t) {
            return i(t[te] && "%" === t.charAt(t[te] - 1) ? parseFloat(t) / 100 : parseFloat(t))
        }

        function a(t, e, i) {
            return 0 > i ? i += 1 : i > 1 && (i -= 1), 1 > 6 * i ? t + (e - t) * i * 6 : 1 > 2 * i ? e : 2 > 3 * i ? t + (e - t) * (2 / 3 - i) * 6 : t
        }

        function o(t, e, i) {
            return t + (e - t) * i
        }

        function s(t) {
            if (t) {
                t += "";
                var e = t[I](/ /g, "")[fe]();
                if (e in g) return g[e].slice();
                if ("#" !== e.charAt(0)) {
                    var i = e[J]("("),
                        a = e[J](")");
                    if (-1 !== i && a + 1 === e[te]) {
                        var o = e.substr(0, i),
                            s = e.substr(i + 1, a - (i + 1)).split(","),
                            u = 1;
                        switch (o) {
                            case "rgba":
                                if (4 !== s[te]) return;
                                u = r(s.pop());
                            case "rgb":
                                if (3 !== s[te]) return;
                                return [n(s[0]), n(s[1]), n(s[2]), u];
                            case "hsla":
                                if (4 !== s[te]) return;
                                return s[3] = r(s[3]), l(s);
                            case "hsl":
                                if (3 !== s[te]) return;
                                return l(s);
                            default:
                                return
                        }
                    }
                } else {
                    if (4 === e[te]) {
                        var c = parseInt(e.substr(1), 16);
                        if (!(c >= 0 && 4095 >= c)) return;
                        return [(3840 & c) >> 4 | (3840 & c) >> 8, 240 & c | (240 & c) >> 4, 15 & c | (15 & c) << 4, 1]
                    }
                    if (7 === e[te]) {
                        var c = parseInt(e.substr(1), 16);
                        if (!(c >= 0 && 16777215 >= c)) return;
                        return [(16711680 & c) >> 16, (65280 & c) >> 8, 255 & c, 1]
                    }
                }
            }
        }

        function l(e) {
            var i = (parseFloat(e[0]) % 360 + 360) % 360 / 360,
                n = r(e[1]),
                o = r(e[2]),
                s = .5 >= o ? o * (n + 1) : o + n - o * n,
                l = 2 * o - s,
                u = [t(255 * a(l, s, i + 1 / 3)), t(255 * a(l, s, i)), t(255 * a(l, s, i - 1 / 3))];
            return 4 === e[te] && (u[3] = e[3]), u
        }

        function u(t) {
            if (t) {
                var e, i, n = t[0] / 255,
                    r = t[1] / 255,
                    a = t[2] / 255,
                    o = Math.min(n, r, a),
                    s = Math.max(n, r, a),
                    l = s - o,
                    u = (s + o) / 2;
                if (0 === l) e = 0, i = 0;
                else {
                    i = .5 > u ? l / (s + o) : l / (2 - s - o);
                    var c = ((s - n) / 6 + l / 2) / l,
                        h = ((s - r) / 6 + l / 2) / l,
                        f = ((s - a) / 6 + l / 2) / l;
                    n === s ? e = f - h : r === s ? e = 1 / 3 + c - f : a === s && (e = 2 / 3 + h - c), 0 > e && (e += 1), e > 1 && (e -= 1)
                }
                var d = [360 * e, i, u];
                return null != t[3] && d.push(t[3]), d
            }
        }

        function c(t, e) {
            var i = s(t);
            if (i) {
                for (var n = 0; 3 > n; n++) i[n] = 0 > e ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0;
                return v(i, 4 === i[te] ? "rgba" : "rgb")
            }
        }

        function h(t) {
            var e = s(t);
            return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0
        }

        function f(e, i, n) {
            if (i && i[te] && e >= 0 && 1 >= e) {
                n = n || [0, 0, 0, 0];
                var r = e * (i[te] - 1),
                    a = Math.floor(r),
                    s = Math.ceil(r),
                    l = i[a],
                    u = i[s],
                    c = r - a;
                return n[0] = t(o(l[0], u[0], c)), n[1] = t(o(l[1], u[1], c)), n[2] = t(o(l[2], u[2], c)), n[3] = t(o(l[3], u[3], c)), n
            }
        }

        function d(e, n, r) {
            if (n && n[te] && e >= 0 && 1 >= e) {
                var a = e * (n[te] - 1),
                    l = Math.floor(a),
                    u = Math.ceil(a),
                    c = s(n[l]),
                    h = s(n[u]),
                    f = a - l,
                    d = v([t(o(c[0], h[0], f)), t(o(c[1], h[1], f)), t(o(c[2], h[2], f)), i(o(c[3], h[3], f))], "rgba");
                return r ? {
                    color: d,
                    leftIndex: l,
                    rightIndex: u,
                    value: a
                } : d
            }
        }

        function p(t, i, n, a) {
            return t = s(t), t ? (t = u(t), null != i && (t[0] = e(i)), null != n && (t[1] = r(n)), null != a && (t[2] = r(a)), v(l(t), "rgba")) : void 0
        }

        function m(t, e) {
            return t = s(t), t && null != e ? (t[3] = i(e), v(t, "rgba")) : void 0
        }

        function v(t, e) {
            var i = t[0] + "," + t[1] + "," + t[2];
            return ("rgba" === e || "hsva" === e || "hsla" === e) && (i += "," + t[3]), e + "(" + i + ")"
        }
        var g = {
            transparent: [0, 0, 0, 0],
            aliceblue: [240, 248, 255, 1],
            antiquewhite: [250, 235, 215, 1],
            aqua: [0, 255, 255, 1],
            aquamarine: [127, 255, 212, 1],
            azure: [240, 255, 255, 1],
            beige: [245, 245, 220, 1],
            bisque: [255, 228, 196, 1],
            black: [0, 0, 0, 1],
            blanchedalmond: [255, 235, 205, 1],
            blue: [0, 0, 255, 1],
            blueviolet: [138, 43, 226, 1],
            brown: [165, 42, 42, 1],
            burlywood: [222, 184, 135, 1],
            cadetblue: [95, 158, 160, 1],
            chartreuse: [127, 255, 0, 1],
            chocolate: [210, 105, 30, 1],
            coral: [255, 127, 80, 1],
            cornflowerblue: [100, 149, 237, 1],
            cornsilk: [255, 248, 220, 1],
            crimson: [220, 20, 60, 1],
            cyan: [0, 255, 255, 1],
            darkblue: [0, 0, 139, 1],
            darkcyan: [0, 139, 139, 1],
            darkgoldenrod: [184, 134, 11, 1],
            darkgray: [169, 169, 169, 1],
            darkgreen: [0, 100, 0, 1],
            darkgrey: [169, 169, 169, 1],
            darkkhaki: [189, 183, 107, 1],
            darkmagenta: [139, 0, 139, 1],
            darkolivegreen: [85, 107, 47, 1],
            darkorange: [255, 140, 0, 1],
            darkorchid: [153, 50, 204, 1],
            darkred: [139, 0, 0, 1],
            darksalmon: [233, 150, 122, 1],
            darkseagreen: [143, 188, 143, 1],
            darkslateblue: [72, 61, 139, 1],
            darkslategray: [47, 79, 79, 1],
            darkslategrey: [47, 79, 79, 1],
            darkturquoise: [0, 206, 209, 1],
            darkviolet: [148, 0, 211, 1],
            deeppink: [255, 20, 147, 1],
            deepskyblue: [0, 191, 255, 1],
            dimgray: [105, 105, 105, 1],
            dimgrey: [105, 105, 105, 1],
            dodgerblue: [30, 144, 255, 1],
            firebrick: [178, 34, 34, 1],
            floralwhite: [255, 250, 240, 1],
            forestgreen: [34, 139, 34, 1],
            fuchsia: [255, 0, 255, 1],
            gainsboro: [220, 220, 220, 1],
            ghostwhite: [248, 248, 255, 1],
            gold: [255, 215, 0, 1],
            goldenrod: [218, 165, 32, 1],
            gray: [128, 128, 128, 1],
            green: [0, 128, 0, 1],
            greenyellow: [173, 255, 47, 1],
            grey: [128, 128, 128, 1],
            honeydew: [240, 255, 240, 1],
            hotpink: [255, 105, 180, 1],
            indianred: [205, 92, 92, 1],
            indigo: [75, 0, 130, 1],
            ivory: [255, 255, 240, 1],
            khaki: [240, 230, 140, 1],
            lavender: [230, 230, 250, 1],
            lavenderblush: [255, 240, 245, 1],
            lawngreen: [124, 252, 0, 1],
            lemonchiffon: [255, 250, 205, 1],
            lightblue: [173, 216, 230, 1],
            lightcoral: [240, 128, 128, 1],
            lightcyan: [224, 255, 255, 1],
            lightgoldenrodyellow: [250, 250, 210, 1],
            lightgray: [211, 211, 211, 1],
            lightgreen: [144, 238, 144, 1],
            lightgrey: [211, 211, 211, 1],
            lightpink: [255, 182, 193, 1],
            lightsalmon: [255, 160, 122, 1],
            lightseagreen: [32, 178, 170, 1],
            lightskyblue: [135, 206, 250, 1],
            lightslategray: [119, 136, 153, 1],
            lightslategrey: [119, 136, 153, 1],
            lightsteelblue: [176, 196, 222, 1],
            lightyellow: [255, 255, 224, 1],
            lime: [0, 255, 0, 1],
            limegreen: [50, 205, 50, 1],
            linen: [250, 240, 230, 1],
            magenta: [255, 0, 255, 1],
            maroon: [128, 0, 0, 1],
            mediumaquamarine: [102, 205, 170, 1],
            mediumblue: [0, 0, 205, 1],
            mediumorchid: [186, 85, 211, 1],
            mediumpurple: [147, 112, 219, 1],
            mediumseagreen: [60, 179, 113, 1],
            mediumslateblue: [123, 104, 238, 1],
            mediumspringgreen: [0, 250, 154, 1],
            mediumturquoise: [72, 209, 204, 1],
            mediumvioletred: [199, 21, 133, 1],
            midnightblue: [25, 25, 112, 1],
            mintcream: [245, 255, 250, 1],
            mistyrose: [255, 228, 225, 1],
            moccasin: [255, 228, 181, 1],
            navajowhite: [255, 222, 173, 1],
            navy: [0, 0, 128, 1],
            oldlace: [253, 245, 230, 1],
            olive: [128, 128, 0, 1],
            olivedrab: [107, 142, 35, 1],
            orange: [255, 165, 0, 1],
            orangered: [255, 69, 0, 1],
            orchid: [218, 112, 214, 1],
            palegoldenrod: [238, 232, 170, 1],
            palegreen: [152, 251, 152, 1],
            paleturquoise: [175, 238, 238, 1],
            palevioletred: [219, 112, 147, 1],
            papayawhip: [255, 239, 213, 1],
            peachpuff: [255, 218, 185, 1],
            peru: [205, 133, 63, 1],
            pink: [255, 192, 203, 1],
            plum: [221, 160, 221, 1],
            powderblue: [176, 224, 230, 1],
            purple: [128, 0, 128, 1],
            red: [255, 0, 0, 1],
            rosybrown: [188, 143, 143, 1],
            royalblue: [65, 105, 225, 1],
            saddlebrown: [139, 69, 19, 1],
            salmon: [250, 128, 114, 1],
            sandybrown: [244, 164, 96, 1],
            seagreen: [46, 139, 87, 1],
            seashell: [255, 245, 238, 1],
            sienna: [160, 82, 45, 1],
            silver: [192, 192, 192, 1],
            skyblue: [135, 206, 235, 1],
            slateblue: [106, 90, 205, 1],
            slategray: [112, 128, 144, 1],
            slategrey: [112, 128, 144, 1],
            snow: [255, 250, 250, 1],
            springgreen: [0, 255, 127, 1],
            steelblue: [70, 130, 180, 1],
            tan: [210, 180, 140, 1],
            teal: [0, 128, 128, 1],
            thistle: [216, 191, 216, 1],
            tomato: [255, 99, 71, 1],
            turquoise: [64, 224, 208, 1],
            violet: [238, 130, 238, 1],
            wheat: [245, 222, 179, 1],
            white: [255, 255, 255, 1],
            whitesmoke: [245, 245, 245, 1],
            yellow: [255, 255, 0, 1],
            yellowgreen: [154, 205, 50, 1]
        };
        return {
            parse: s,
            lift: c,
            toHex: h,
            fastMapToColor: f,
            mapToColor: d,
            modifyHSL: p,
            modifyAlpha: m,
            stringify: v
        }
    }), e("zrender/mixin/Eventful", [me], function () {
        var t = Array[he].slice,
            e = function () {
                this._$handlers = {}
            };
        return e[he] = {
            constructor: e,
            one: function (t, e, i) {
                var n = this._$handlers;
                if (!e || !t) return this;
                n[t] || (n[t] = []);
                for (var r = 0; r < n[t][te]; r++)
                    if (n[t][r].h === e) return this;
                return n[t].push({
                    h: e,
                    one: !0,
                    ctx: i || this
                }), this
            },
            on: function (t, e, i) {
                var n = this._$handlers;
                if (!e || !t) return this;
                n[t] || (n[t] = []);
                for (var r = 0; r < n[t][te]; r++)
                    if (n[t][r].h === e) return this;
                return n[t].push({
                    h: e,
                    one: !1,
                    ctx: i || this
                }), this
            },
            isSilent: function (t) {
                var e = this._$handlers;
                return e[t] && e[t][te]
            },
            off: function (t, e) {
                var i = this._$handlers;
                if (!t) return this._$handlers = {}, this;
                if (e) {
                    if (i[t]) {
                        for (var n = [], r = 0, a = i[t][te]; a > r; r++) i[t][r].h != e && n.push(i[t][r]);
                        i[t] = n
                    }
                    i[t] && 0 === i[t][te] && delete i[t]
                } else delete i[t];
                return this
            },
            trigger: function (e) {
                if (this._$handlers[e]) {
                    var i = arguments,
                        n = i[te];
                    n > 3 && (i = t.call(i, 1));
                    for (var r = this._$handlers[e], a = r[te], o = 0; a > o;) {
                        switch (n) {
                            case 1:
                                r[o].h.call(r[o].ctx);
                                break;
                            case 2:
                                r[o].h.call(r[o].ctx, i[1]);
                                break;
                            case 3:
                                r[o].h.call(r[o].ctx, i[1], i[2]);
                                break;
                            default:
                                r[o].h.apply(r[o].ctx, i)
                        }
                        r[o].one ? (r[F](o, 1), a--) : o++
                    }
                }
                return this
            },
            triggerWithContext: function (e) {
                if (this._$handlers[e]) {
                    var i = arguments,
                        n = i[te];
                    n > 4 && (i = t.call(i, 1, i[te] - 1));
                    for (var r = i[i[te] - 1], a = this._$handlers[e], o = a[te], s = 0; o > s;) {
                        switch (n) {
                            case 1:
                                a[s].h.call(r);
                                break;
                            case 2:
                                a[s].h.call(r, i[1]);
                                break;
                            case 3:
                                a[s].h.call(r, i[1], i[2]);
                                break;
                            default:
                                a[s].h.apply(r, i)
                        }
                        a[s].one ? (a[F](s, 1), o--) : s++
                    }
                }
                return this
            }
        }, e
    }), e("zrender/core/timsort", [], function () {
        function t(t) {
            for (var e = 0; t >= l;) e |= 1 & t, t >>= 1;
            return t + e
        }

        function e(t, e, n, r) {
            var a = e + 1;
            if (a === n) return 1;
            if (r(t[a++], t[e]) < 0) {
                for (; n > a && r(t[a], t[a - 1]) < 0;) a++;
                i(t, e, a)
            } else
                for (; n > a && r(t[a], t[a - 1]) >= 0;) a++;
            return a - e
        }

        function i(t, e, i) {
            for (i--; i > e;) {
                var n = t[e];
                t[e++] = t[i], t[i--] = n
            }
        }

        function n(t, e, i, n, r) {
            for (n === e && n++; i > n; n++) {
                for (var a, o = t[n], s = e, l = n; l > s;) a = s + l >>> 1, r(o, t[a]) < 0 ? l = a : s = a + 1;
                var u = n - s;
                switch (u) {
                    case 3:
                        t[s + 3] = t[s + 2];
                    case 2:
                        t[s + 2] = t[s + 1];
                    case 1:
                        t[s + 1] = t[s];
                        break;
                    default:
                        for (; u > 0;) t[s + u] = t[s + u - 1], u--
                }
                t[s] = o
            }
        }

        function r(t, e, i, n, r, a) {
            var o = 0,
                s = 0,
                l = 1;
            if (a(t, e[i + r]) > 0) {
                for (s = n - r; s > l && a(t, e[i + r + l]) > 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
                l > s && (l = s), o += r, l += r
            } else {
                for (s = r + 1; s > l && a(t, e[i + r - l]) <= 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
                l > s && (l = s);
                var u = o;
                o = r - l, l = r - u
            }
            for (o++; l > o;) {
                var c = o + (l - o >>> 1);
                a(t, e[i + c]) > 0 ? o = c + 1 : l = c
            }
            return l
        }

        function a(t, e, i, n, r, a) {
            var o = 0,
                s = 0,
                l = 1;
            if (a(t, e[i + r]) < 0) {
                for (s = r + 1; s > l && a(t, e[i + r - l]) < 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
                l > s && (l = s);
                var u = o;
                o = r - l, l = r - u
            } else {
                for (s = n - r; s > l && a(t, e[i + r + l]) >= 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
                l > s && (l = s), o += r, l += r
            }
            for (o++; l > o;) {
                var c = o + (l - o >>> 1);
                a(t, e[i + c]) < 0 ? l = c : o = c + 1
            }
            return l
        }

        function o(t, e) {
            function i(t, e) {
                f[y] = t, d[y] = e, y += 1
            }

            function n() {
                for (; y > 1;) {
                    var t = y - 2;
                    if (t >= 1 && d[t - 1] <= d[t] + d[t + 1] || t >= 2 && d[t - 2] <= d[t] + d[t - 1]) d[t - 1] < d[t + 1] && t--;
                    else if (d[t] > d[t + 1]) break;
                    s(t)
                }
            }

            function o() {
                for (; y > 1;) {
                    var t = y - 2;
                    t > 0 && d[t - 1] < d[t + 1] && t--, s(t)
                }
            }

            function s(i) {
                var n = f[i],
                    o = d[i],
                    s = f[i + 1],
                    u = d[i + 1];
                d[i] = o + u, i === y - 3 && (f[i + 1] = f[i + 2], d[i + 1] = d[i + 2]), y--;
                var c = a(t[s], t, n, o, 0, e);
                n += c, o -= c, 0 !== o && (u = r(t[n + o - 1], t, s, u, u - 1, e), 0 !== u && (u >= o ? l(n, o, s, u) : h(n, o, s, u)))
            }

            function l(i, n, o, s) {
                var l = 0;
                for (l = 0; n > l; l++) _[l] = t[i + l];
                var c = 0,
                    h = o,
                    f = i;
                if (t[f++] = t[h++], 0 !== --s) {
                    if (1 === n) {
                        for (l = 0; s > l; l++) t[f + l] = t[h + l];
                        return void (t[f + s] = _[c])
                    }
                    for (var d, m, v, g = p; ;) {
                        d = 0, m = 0, v = !1;
                        do
                            if (e(t[h], _[c]) < 0) {
                                if (t[f++] = t[h++], m++, d = 0, 0 === --s) {
                                    v = !0;
                                    break
                                }
                            } else if (t[f++] = _[c++], d++, m = 0, 1 === --n) {
                                v = !0;
                                break
                            } while (g > (d | m));
                        if (v) break;
                        do {
                            if (d = a(t[h], _, c, n, 0, e), 0 !== d) {
                                for (l = 0; d > l; l++) t[f + l] = _[c + l];
                                if (f += d, c += d, n -= d, 1 >= n) {
                                    v = !0;
                                    break
                                }
                            }
                            if (t[f++] = t[h++], 0 === --s) {
                                v = !0;
                                break
                            }
                            if (m = r(_[c], t, h, s, 0, e), 0 !== m) {
                                for (l = 0; m > l; l++) t[f + l] = t[h + l];
                                if (f += m, h += m, s -= m, 0 === s) {
                                    v = !0;
                                    break
                                }
                            }
                            if (t[f++] = _[c++], 1 === --n) {
                                v = !0;
                                break
                            }
                            g--
                        } while (d >= u || m >= u);
                        if (v) break;
                        0 > g && (g = 0), g += 2
                    }
                    if (p = g, 1 > p && (p = 1), 1 === n) {
                        for (l = 0; s > l; l++) t[f + l] = t[h + l];
                        t[f + s] = _[c]
                    } else {
                        if (0 === n) throw new Error;
                        for (l = 0; n > l; l++) t[f + l] = _[c + l]
                    }
                } else
                    for (l = 0; n > l; l++) t[f + l] = _[c + l]
            }

            function h(i, n, o, s) {
                var l = 0;
                for (l = 0; s > l; l++) _[l] = t[o + l];
                var c = i + n - 1,
                    h = s - 1,
                    f = o + s - 1,
                    d = 0,
                    m = 0;
                if (t[f--] = t[c--], 0 !== --n) {
                    if (1 === s) {
                        for (f -= n, c -= n, m = f + 1, d = c + 1, l = n - 1; l >= 0; l--) t[m + l] = t[d + l];
                        return void (t[f] = _[h])
                    }
                    for (var v = p; ;) {
                        var g = 0,
                            y = 0,
                            x = !1;
                        do
                            if (e(_[h], t[c]) < 0) {
                                if (t[f--] = t[c--], g++, y = 0, 0 === --n) {
                                    x = !0;
                                    break
                                }
                            } else if (t[f--] = _[h--], y++, g = 0, 1 === --s) {
                                x = !0;
                                break
                            } while (v > (g | y));
                        if (x) break;
                        do {
                            if (g = n - a(_[h], t, i, n, n - 1, e), 0 !== g) {
                                for (f -= g, c -= g, n -= g, m = f + 1, d = c + 1, l = g - 1; l >= 0; l--) t[m + l] = t[d + l];
                                if (0 === n) {
                                    x = !0;
                                    break
                                }
                            }
                            if (t[f--] = _[h--], 1 === --s) {
                                x = !0;
                                break
                            }
                            if (y = s - r(t[c], _, 0, s, s - 1, e), 0 !== y) {
                                for (f -= y, h -= y, s -= y, m = f + 1, d = h + 1, l = 0; y > l; l++) t[m + l] = _[d + l];
                                if (1 >= s) {
                                    x = !0;
                                    break
                                }
                            }
                            if (t[f--] = t[c--], 0 === --n) {
                                x = !0;
                                break
                            }
                            v--
                        } while (g >= u || y >= u);
                        if (x) break;
                        0 > v && (v = 0), v += 2
                    }
                    if (p = v, 1 > p && (p = 1), 1 === s) {
                        for (f -= n, c -= n, m = f + 1, d = c + 1, l = n - 1; l >= 0; l--) t[m + l] = t[d + l];
                        t[f] = _[h]
                    } else {
                        if (0 === s) throw new Error;
                        for (d = f - (s - 1), l = 0; s > l; l++) t[d + l] = _[l]
                    }
                } else
                    for (d = f - (s - 1), l = 0; s > l; l++) t[d + l] = _[l]
            }
            var f, d, p = u,
                m = 0,
                v = c,
                g = 0,
                y = 0;
            m = t[te], 2 * c > m && (v = m >>> 1);
            var _ = [];
            g = 120 > m ? 5 : 1542 > m ? 10 : 119151 > m ? 19 : 40, f = [], d = [], this.mergeRuns = n, this.forceMergeRuns = o, this.pushRun = i
        }

        function s(i, r, a, s) {
            a || (a = 0), s || (s = i[te]);
            var u = s - a;
            if (!(2 > u)) {
                var c = 0;
                if (l > u) return c = e(i, a, s, r), void n(i, a, s, a + c, r);
                var h = new o(i, r),
                    f = t(u);
                do {
                    if (c = e(i, a, s, r), f > c) {
                        var d = u;
                        d > f && (d = f), n(i, a, a + d, a + c, r), c = d
                    }
                    h.pushRun(a, c), h.mergeRuns(), u -= c, a += c
                } while (0 !== u);
                h.forceMergeRuns()
            }
        }
        var l = 32,
            u = 7,
            c = 256;
        return s
    }), e("echarts/visual/seriesColor", [me, "zrender/graphic/Gradient"], function (t) {
        var e = t("zrender/graphic/Gradient");
        return function (t) {
            function i(i) {
                var n = (i.visualColorAccessPath || "itemStyle.normal.color").split("."),
                    r = i[Q](),
                    a = i.get(n) || i.getColorFromPalette(i.get("name"));
                r.setVisual("color", a), t.isSeriesFiltered(i) || (typeof a !== L || a instanceof e || r.each(function (t) {
                    r.setItemVisual(t, "color", a(i[E](t)))
                }), r.each(function (t) {
                    var e = r[o](t),
                        i = e.get(n, !0);
                    null != i && r.setItemVisual(t, "color", i)
                }))
            }
            t.eachRawSeries(i)
        }
    }), e("echarts/preprocessor/backwardCompat", [me, de, "./helper/compatStyle"], function (t) {
        function e(t, e) {
            e = e.split(",");
            for (var i = t, n = 0; n < e[te] && (i = i && i[e[n]], null != i); n++);
            return i
        }

        function i(t, e, i, n) {
            e = e.split(",");
            for (var r, a = t, o = 0; o < e[te] - 1; o++) r = e[o], null == a[r] && (a[r] = {}), a = a[r];
            (n || null == a[e[o]]) && (a[e[o]] = i)
        }

        function n(t) {
            u(o, function (e) {
                e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]])
            })
        }
        var r = t(de),
            a = t("./helper/compatStyle"),
            o = [
                ["x", "left"],
                ["y", "top"],
                ["x2", "right"],
                ["y2", ee]
            ],
            s = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
            l = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", "parallel", "pie", "radar", "sankey", "scatter", "treemap"],
            u = r.each;
        return function (t) {
            u(t[W], function (t) {
                if (r[oe](t)) {
                    var o = t.type;
                    if (a(t), ("pie" === o || "gauge" === o) && null != t.clockWise && (t.clockwise = t.clockWise), "gauge" === o) {
                        var s = e(t, "pointer.color");
                        null != s && i(t, "itemStyle.normal.color", s)
                    }
                    for (var u = 0; u < l[te]; u++)
                        if (l[u] === t.type) {
                            n(t);
                            break
                        }
                }
            }), t.dataRange && (t.visualMap = t.dataRange), u(s, function (e) {
                var i = t[e];
                i && (r[z](i) || (i = [i]), u(i, function (t) {
                    n(t)
                }))
            })
        }
    }), e("echarts/loading/default", [me, "../util/graphic", de], function (t) {
        var e = t("../util/graphic"),
            i = t(de),
            n = Math.PI;
        return function (t, r) {
            r = r || {}, i[V](r, {
                text: "loading",
                color: "#c23531",
                textColor: "#000",
                maskColor: "rgba(255, 255, 255, 0.8)",
                zlevel: 0
            });
            var a = new e.Rect({
                style: {
                    fill: r.maskColor
                },
                zlevel: r[D],
                z: 1e4
            }),
                o = new e.Arc({
                    shape: {
                        startAngle: -n / 2,
                        endAngle: -n / 2 + .1,
                        r: 10
                    },
                    style: {
                        stroke: r.color,
                        lineCap: "round",
                        lineWidth: 5
                    },
                    zlevel: r[D],
                    z: 10001
                }),
                s = new e.Rect({
                    style: {
                        fill: "none",
                        text: r.text,
                        textPosition: "right",
                        textDistance: 10,
                        textFill: r.textColor
                    },
                    zlevel: r[D],
                    z: 10001
                });
            o.animateShape(!0).when(1e3, {
                endAngle: 3 * n / 2
            }).start("circularInOut"), o.animateShape(!0).when(1e3, {
                startAngle: 3 * n / 2
            }).delay(300).start("circularInOut");
            var l = new e.Group;
            return l.add(o), l.add(s), l.add(a), l.resize = function () {
                var e = t[re]() / 2,
                    i = t[ne]() / 2;
                o.setShape({
                    cx: e,
                    cy: i
                });
                var n = o.shape.r;
                s.setShape({
                    x: e - n,
                    y: i - n,
                    width: 2 * n,
                    height: 2 * n
                }), a.setShape({
                    x: 0,
                    y: 0,
                    width: t[re](),
                    height: t[ne]()
                })
            }, l.resize(), l
        }
    }), e("echarts/data/List", [me, "../model/Model", "./DataDiffer", de, "../util/model"], function (t) {
        function e(t) {
            return d[z](t) || (t = [t]), t
        }

        function i(t, e) {
            var i = t.dimensions,
                n = new w(d.map(i, t.getDimensionInfo, t), t.hostModel);
            b(n, t);
            for (var r = n._storage = {}, a = t._storage, o = 0; o < i[te]; o++) {
                var s = i[o],
                    l = a[s];
                r[s] = d[J](e, s) >= 0 ? new l.constructor(a[s][te]) : a[s]
            }
            return n
        }
        var n = g,
            r = typeof window === g ? global : window,
            a = typeof r.Float64Array === n ? Array : r.Float64Array,
            s = typeof r.Int32Array === n ? Array : r.Int32Array,
            l = {
                "float": a,
                "int": s,
                ordinal: Array,
                number: Array,
                time: Array
            },
            u = t("../model/Model"),
            c = t("./DataDiffer"),
            d = t(de),
            y = t("../util/model"),
            _ = d[oe],
            x = ["stackedOn", "hasItemOption", "_nameList", "_idList", "_rawData"],
            b = function (t, e) {
                d.each(x[v](e.__wrappedMethods || []), function (i) {
                    e.hasOwnProperty(i) && (t[i] = e[i])
                }), t.__wrappedMethods = e.__wrappedMethods
            },
            w = function (t, e) {
                t = t || ["x", "y"];
                for (var i = {}, n = [], r = 0; r < t[te]; r++) {
                    var a, o = {};
                    typeof t[r] === ce ? (a = t[r], o = {
                        name: a,
                        stackable: !1,
                        type: "number"
                    }) : (o = t[r], a = o.name, o.type = o.type || k), n.push(a), i[a] = o
                }
                this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this.indices = [], this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this.stackedOn = null, this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._rawData, this._extent
            },
            M = w[he];
        M.type = "list", M.hasItemOption = !0, M.getDimension = function (t) {
            return isNaN(t) || (t = this.dimensions[t] || t), t
        }, M.getDimensionInfo = function (t) {
            return d.clone(this._dimensionInfos[this.getDimension(t)])
        }, M.initData = function (t, e, i) {
            t = t || [], this._rawData = t;
            var n = this._storage = {},
                r = this.indices = [],
                a = this.dimensions,
                o = t[te],
                s = this._dimensionInfos,
                u = [],
                c = {};
            e = e || [];
            for (var h = 0; h < a[te]; h++) {
                var f = s[a[h]],
                    d = l[f.type];
                n[a[h]] = new d(o)
            }
            var p = this;
            i || (p.hasItemOption = !1), i = i || function (t, e, i, n) {
                var r = y.getDataItemValue(t);
                return y.isDataItemOption(t) && (p.hasItemOption = !0), y.converDataValue(r instanceof Array ? r[n] : r, s[e])
            };
            for (var m = 0; m < t[te]; m++) {
                for (var v = t[m], g = 0; g < a[te]; g++) {
                    var _ = a[g],
                        x = n[_];
                    x[m] = i(v, _, m, g)
                }
                r.push(m)
            }
            for (var h = 0; h < t[te]; h++) {
                e[h] || t[h] && null != t[h].name && (e[h] = t[h].name);
                var b = e[h] || "",
                    w = t[h] && t[h].id;
                !w && b && (c[b] = c[b] || 0, w = b, c[b] > 0 && (w += "__ec__" + c[b]), c[b]++), w && (u[h] = w)
            }
            this._nameList = e, this._idList = u
        }, M.count = function () {
            return this.indices[te]
        }, M.get = function (t, e, i) {
            var n = this._storage,
                r = this.indices[e];
            if (null == r) return 0 / 0;
            var a = n[t] && n[t][r];
            if (i) {
                var o = this._dimensionInfos[t];
                if (o && o.stackable)
                    for (var s = this.stackedOn; s;) {
                        var l = s.get(t, e);
                        (a >= 0 && l > 0 || 0 >= a && 0 > l) && (a += l), s = s.stackedOn
                    }
            }
            return a
        }, M.getValues = function (t, e, i) {
            var n = [];
            d[z](t) || (i = e, e = t, t = this.dimensions);
            for (var r = 0, a = t[te]; a > r; r++) n.push(this.get(t[r], e, i));
            return n
        }, M.hasValue = function (t) {
            for (var e = this.dimensions, i = this._dimensionInfos, n = 0, r = e[te]; r > n; n++)
                if (i[e[n]].type !== p && isNaN(this.get(e[n], t))) return !1;
            return !0
        }, M.getDataExtent = function (t, e, i) {
            t = this.getDimension(t);
            var n = this._storage[t],
                r = this.getDimensionInfo(t);
            e = r && r.stackable && e;
            var a, o = (this._extent || (this._extent = {}))[t + !!e];
            if (o) return o;
            if (n) {
                for (var s = 1 / 0, l = -1 / 0, u = 0, c = this.count(); c > u; u++) a = this.get(t, u, e), (!i || i(a, t, u)) && (s > a && (s = a), a > l && (l = a));
                return this._extent[t + !!e] = [s, l]
            }
            return [1 / 0, -1 / 0]
        }, M.getSum = function (t, e) {
            var i = this._storage[t],
                n = 0;
            if (i)
                for (var r = 0, a = this.count(); a > r; r++) {
                    var o = this.get(t, r, e);
                    isNaN(o) || (n += o)
                }
            return n
        }, M[J] = function (t, e) {
            var i = this._storage,
                n = i[t],
                r = this.indices;
            if (n)
                for (var a = 0, o = r[te]; o > a; a++) {
                    var s = r[a];
                    if (n[s] === e) return a
                }
            return -1
        }, M.indexOfName = function (t) {
            for (var e = this.indices, i = this._nameList, n = 0, r = e[te]; r > n; n++) {
                var a = e[n];
                if (i[a] === t) return n
            }
            return -1
        }, M.indexOfRawIndex = function (t) {
            var e = this.indices,
                i = e[t];
            if (null != i && i === t) return t;
            for (var n = 0, r = e[te] - 1; r >= n;) {
                var a = (n + r) / 2 | 0;
                if (e[a] < t) n = a + 1;
                else {
                    if (!(e[a] > t)) return a;
                    r = a - 1
                }
            }
            return -1
        }, M.indexOfNearest = function (t, e, i, n) {
            var r = this._storage,
                a = r[t];
            null == n && (n = 1 / 0);
            var o = -1;
            if (a)
                for (var s = Number.MAX_VALUE, l = 0, u = this.count(); u > l; l++) {
                    var c = e - this.get(t, l, i),
                        h = Math.abs(c);
                    n >= c && (s > h || h === s && c > 0) && (s = h, o = l)
                }
            return o
        }, M.getRawIndex = function (t) {
            var e = this.indices[t];
            return null == e ? -1 : e
        }, M.getRawDataItem = function (t) {
            return this._rawData[this.getRawIndex(t)]
        }, M.getName = function (t) {
            return this._nameList[this.indices[t]] || ""
        }, M.getId = function (t) {
            return this._idList[this.indices[t]] || this.getRawIndex(t) + ""
        }, M.each = function (t, i, n, r) {
            typeof t === L && (r = n, n = i, i = t, t = []), t = d.map(e(t), this.getDimension, this);
            var a = [],
                o = t[te],
                s = this.indices;
            r = r || this;
            for (var l = 0; l < s[te]; l++) switch (o) {
                case 0:
                    i.call(r, l);
                    break;
                case 1:
                    i.call(r, this.get(t[0], l, n), l);
                    break;
                case 2:
                    i.call(r, this.get(t[0], l, n), this.get(t[1], l, n), l);
                    break;
                default:
                    for (var u = 0; o > u; u++) a[u] = this.get(t[u], l, n);
                    a[u] = l, i.apply(r, a)
            }
        }, M.filterSelf = function (t, i, n, r) {
            typeof t === L && (r = n, n = i, i = t, t = []), t = d.map(e(t), this.getDimension, this);
            var a = [],
                o = [],
                s = t[te],
                l = this.indices;
            r = r || this;
            for (var u = 0; u < l[te]; u++) {
                var c;
                if (1 === s) c = i.call(r, this.get(t[0], u, n), u);
                else {
                    for (var h = 0; s > h; h++) o[h] = this.get(t[h], u, n);
                    o[h] = u, c = i.apply(r, o)
                }
                c && a.push(l[u])
            }
            return this.indices = a, this._extent = {}, this
        }, M.mapArray = function (t, e, i, n) {
            typeof t === L && (n = i, i = e, e = t, t = []);
            var r = [];
            return this.each(t, function () {
                r.push(e && e.apply(this, arguments))
            }, i, n), r
        }, M.map = function (t, n, r, a) {
            t = d.map(e(t), this.getDimension, this);
            var o = i(this, t),
                s = o.indices = this.indices,
                l = o._storage,
                u = [];
            return this.each(t, function () {
                var e = arguments[arguments[te] - 1],
                    i = n && n.apply(this, arguments);
                if (null != i) {
                    typeof i === k && (u[0] = i, i = u);
                    for (var r = 0; r < i[te]; r++) {
                        var a = t[r],
                            o = l[a],
                            c = s[e];
                        o && (o[c] = i[r])
                    }
                }
            }, r, a), o
        }, M.downSample = function (t, e, n, r) {
            for (var a = i(this, [t]), o = this._storage, s = a._storage, l = this.indices, u = a.indices = [], c = [], h = [], f = Math.floor(1 / e), d = s[t], p = this.count(), m = 0; m < o[t][te]; m++) s[t][m] = o[t][m];
            for (var m = 0; p > m; m += f) {
                f > p - m && (f = p - m, c[te] = f);
                for (var v = 0; f > v; v++) {
                    var g = l[m + v];
                    c[v] = d[g], h[v] = g
                }
                var y = n(c),
                    g = h[r(c, y) || 0];
                d[g] = y, u.push(g)
            }
            return a
        }, M[o] = function (t) {
            var e = this.hostModel;
            return t = this.indices[t], new u(this._rawData[t], e, e && e[m])
        }, M.diff = function (t) {
            var e, i = this._idList,
                n = t && t._idList,
                r = "e\x00\x00";
            return new c(t ? t.indices : [], this.indices, function (t) {
                return null != (e = n[t]) ? e : r + t
            }, function (t) {
                return null != (e = i[t]) ? e : r + t
            })
        }, M.getVisual = function (t) {
            var e = this._visual;
            return e && e[t]
        }, M.setVisual = function (t, e) {
            if (_(t))
                for (var i in t) t.hasOwnProperty(i) && this.setVisual(i, t[i]);
            else this._visual = this._visual || {}, this._visual[t] = e
        }, M.setLayout = function (t, e) {
            if (_(t))
                for (var i in t) t.hasOwnProperty(i) && this.setLayout(i, t[i]);
            else this._layout[t] = e
        }, M.getLayout = function (t) {
            return this._layout[t]
        }, M.getItemLayout = function (t) {
            return this._itemLayouts[t]
        }, M.setItemLayout = function (t, e, i) {
            this._itemLayouts[t] = i ? d[H](this._itemLayouts[t] || {}, e) : e
        }, M.clearItemLayouts = function () {
            this._itemLayouts[te] = 0
        }, M[Y] = function (t, e, i) {
            var n = this._itemVisuals[t],
                r = n && n[e];
            return null != r || i ? r : this.getVisual(e)
        }, M.setItemVisual = function (t, e, i) {
            var n = this._itemVisuals[t] || {};
            if (this._itemVisuals[t] = n, _(e))
                for (var r in e) e.hasOwnProperty(r) && (n[r] = e[r]);
            else n[e] = i
        }, M.clearAllVisual = function () {
            this._visual = {}, this._itemVisuals = []
        };
        var T = function (t) {
            t[R] = this[R], t[$] = this[$], t.dataType = this.dataType
        };
        return M.setItemGraphicEl = function (t, e) {
            var i = this.hostModel;
            e && (e[$] = t, e.dataType = this.dataType, e[R] = i && i[R], "group" === e.type && e[B](T, e)), this._graphicEls[t] = e
        }, M[f] = function (t) {
            return this._graphicEls[t]
        }, M[h] = function (t, e) {
            d.each(this._graphicEls, function (i, n) {
                i && t && t.call(e, i, n)
            })
        }, M.cloneShallow = function () {
            var t = d.map(this.dimensions, this.getDimensionInfo, this),
                e = new w(t, this.hostModel);
            return e._storage = this._storage, b(e, this), e.indices = this.indices.slice(), this._extent && (e._extent = d[H]({}, this._extent)), e
        }, M.wrapMethod = function (t, e) {
            var i = this[t];
            typeof i === L && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () {
                var t = i.apply(this, arguments);
                return e.apply(this, [t][v](d.slice(arguments)))
            })
        }, M.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], M.CHANGABLE_METHODS = ["filterSelf"], w
    }), e("echarts/model/Model", [me, de, "../util/clazz", pe, "./mixin/lineStyle", "./mixin/areaStyle", "./mixin/textStyle", "./mixin/itemStyle"], function (t) {
        function e(t, e, i) {
            this.parentModel = e, this[m] = i, this.option = t
        }

        function i(t, e, i) {
            for (var n = 0; n < e[te] && (!e[n] || (t = t && "object" == typeof t ? t[e[n]] : null, null != t)); n++);
            return null == t && i && (t = i.get(e)), t
        }

        function n(t, e) {
            var i = a.get(t, "getParent");
            return i ? i.call(t, e) : t.parentModel
        }
        var r = t(de),
            a = t("../util/clazz"),
            o = t(pe);
        e[he] = {
            constructor: e,
            init: null,
            mergeOption: function (t) {
                r.merge(this.option, t, !0)
            },
            get: function (t, e) {
                return null == t ? this.option : i(this.option, this.parsePath(t), !e && n(this, t))
            },
            getShallow: function (t, e) {
                var i = this.option,
                    r = null == i ? i : i[t],
                    a = !e && n(this, t);
                return null == r && a && (r = a[d](t)), r
            },
            getModel: function (t, r) {
                var a, o = null == t ? this.option : i(this.option, t = this.parsePath(t));
                return r = r || (a = n(this, t)) && a[ae](t), new e(o, r, this[m])
            },
            isEmpty: function () {
                return null == this.option
            },
            restoreData: function () { },
            clone: function () {
                var t = this.constructor;
                return new t(r.clone(this.option))
            },
            setReadOnly: function (t) {
                a.setReadOnly(this, t)
            },
            parsePath: function (t) {
                return typeof t === ce && (t = t.split(".")), t
            },
            customizeGetParent: function (t) {
                a.set(this, "getParent", t)
            },
            isAnimationEnabled: function () {
                if (!o.node) {
                    if (null != this.option[le]) return !!this.option[le];
                    if (this.parentModel) return this.parentModel.isAnimationEnabled()
                }
            }
        }, a.enableClassExtend(e);
        var s = r.mixin;
        return s(e, t("./mixin/lineStyle")), s(e, t("./mixin/areaStyle")), s(e, t("./mixin/textStyle")), s(e, t("./mixin/itemStyle")), e
    }), e("echarts/util/number", [me], function () {
        function t(t) {
            return t[I](/^\s+/, "")[I](/\s+$/, "")
        }
        var e = {},
            i = 1e-4;
        return e.linearMap = function (t, e, i, n) {
            var r = e[1] - e[0],
                a = i[1] - i[0];
            if (0 === r) return 0 === a ? i[0] : (i[0] + i[1]) / 2;
            if (n)
                if (r > 0) {
                    if (t <= e[0]) return i[0];
                    if (t >= e[1]) return i[1]
                } else {
                    if (t >= e[0]) return i[0];
                    if (t <= e[1]) return i[1]
                }
            else {
                if (t === e[0]) return i[0];
                if (t === e[1]) return i[1]
            }
            return (t - e[0]) / r * a + i[0]
        }, e[a] = function (e, i) {
            switch (e) {
                case M:
                case T:
                    e = "50%";
                    break;
                case "left":
                case "top":
                    e = "0%";
                    break;
                case "right":
                case ee:
                    e = "100%"
            }
            return typeof e === ce ? t(e).match(/%$/) ? parseFloat(e) / 100 * i : parseFloat(e) : null == e ? 0 / 0 : +e
        }, e.round = function (t, e) {
            return null == e && (e = 10), e = Math.min(Math.max(0, e), 20), +(+t).toFixed(e)
        }, e.asc = function (t) {
            return t.sort(function (t, e) {
                return t - e
            }), t
        }, e.getPrecision = function (t) {
            if (t = +t, isNaN(t)) return 0;
            for (var e = 1, i = 0; Math.round(t * e) / e !== t;) e *= 10, i++;
            return i
        }, e.getPrecisionSafe = function (t) {
            var e = t.toString(),
                i = e[J](".");
            return 0 > i ? 0 : e[te] - 1 - i
        }, e.getPixelPrecision = function (t, e) {
            var i = Math.log,
                n = Math.LN10,
                r = Math.floor(i(t[1] - t[0]) / n),
                a = Math.round(i(Math.abs(e[1] - e[0])) / n),
                o = Math.min(Math.max(-r + a, 0), 20);
            return isFinite(o) ? o : 20
        }, e.MAX_SAFE_INTEGER = 9007199254740991, e.remRadian = function (t) {
            var e = 2 * Math.PI;
            return (t % e + e) % e
        }, e.isRadianAroundZero = function (t) {
            return t > -i && i > t
        }, e.parseDate = function (t) {
            if (t instanceof Date) return t;
            if (typeof t === ce) {
                var e = new Date(t);
                return isNaN(+e) && (e = new Date(new Date(t[I](/-/g, "/")) - new Date("1970/01/01"))), e
            }
            return new Date(Math.round(t))
        }, e.quantity = function (t) {
            return Math.pow(10, Math.floor(Math.log(t) / Math.LN10))
        }, e.nice = function (t, i) {
            var n, r = e.quantity(t),
                a = t / r;
            return n = i ? 1.5 > a ? 1 : 2.5 > a ? 2 : 4 > a ? 3 : 7 > a ? 5 : 10 : 1 > a ? 1 : 2 > a ? 2 : 3 > a ? 3 : 5 > a ? 5 : 10, n * r
        }, e.reformIntervals = function (t) {
            function e(t, i, n) {
                return t.interval[n] < i.interval[n] || t.interval[n] === i.interval[n] && (t.close[n] - i.close[n] === (n ? -1 : 1) || !n && e(t, i, 1))
            }
            t.sort(function (t, i) {
                return e(t, i, 0) ? -1 : 1
            });
            for (var i = -1 / 0, n = 1, r = 0; r < t[te];) {
                for (var a = t[r].interval, o = t[r].close, s = 0; 2 > s; s++) a[s] <= i && (a[s] = i, o[s] = s ? 1 : 1 - n), i = a[s], n = o[s];
                a[0] === a[1] && o[0] * o[1] !== 1 ? t[F](r, 1) : r++
            }
            return t
        }, e.isNumeric = function (t) {
            return t - parseFloat(t) >= 0
        }, e
    }), e("echarts/util/format", [me, de, "./number", "zrender/contain/text"], function (t) {
        var e = t(de),
            i = t("./number"),
            n = t("zrender/contain/text"),
            r = {};
        r.addCommas = function (t) {
            return isNaN(t) ? "-" : (t = (t + "").split("."), t[0][I](/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t[te] > 1 ? "." + t[1] : ""))
        }, r.toCamelCase = function (t, e) {
            return t = (t || "")[fe]()[I](/-(.)/g, function (t, e) {
                return e.toUpperCase()
            }), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t
        }, r.normalizeCssArray = function (t) {
            var e = t[te];
            return typeof t === k ? [t, t, t, t] : 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t
        };
        var a = r.encodeHTML = function (t) {
            return String(t)[I](/&/g, "&amp;")[I](/</g, "&lt;")[I](/>/g, "&gt;")[I](/"/g, "&quot;")[I](/'/g, "&#39;")
        },
            o = ["a", "b", "c", "d", "e", "f", "g"],
            s = function (t, e) {
                return "{" + t + (null == e ? "" : e) + "}"
            };
        r.formatTpl = function (t, i, n) {
            e[z](i) || (i = [i]);
            var r = i[te];
            if (!r) return "";
            for (var l = i[0].$vars || [], u = 0; u < l[te]; u++) {
                var c = o[u],
                    h = s(c, 0);
                t = t[I](s(c), n ? a(h) : h)
            }
            for (var f = 0; r > f; f++)
                for (var d = 0; d < l[te]; d++) {
                    var h = i[f][l[d]];
                    t = t[I](s(o[d], f), n ? a(h) : h)
                }
            return t
        };
        var l = function (t) {
            return 10 > t ? "0" + t : t
        };
        return r.formatTime = function (t, e) {
            ("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy");
            var n = i.parseDate(e),
                r = n.getFullYear(),
                a = n.getMonth() + 1,
                o = n.getDate(),
                s = n.getHours(),
                u = n.getMinutes(),
                c = n.getSeconds();
            return t = t[I]("MM", l(a))[fe]()[I]("yyyy", r)[I]("yy", r % 100)[I]("dd", l(o))[I]("d", o)[I]("hh", l(s))[I]("h", s)[I]("mm", l(u))[I]("m", u)[I]("ss", l(c))[I]("s", c)
        }, r.capitalFirst = function (t) {
            return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
        }, r.truncateText = n.truncateText, r
    }), e("zrender/core/matrix", [], function () {
        var t = typeof Float32Array === g ? Array : Float32Array,
            e = {
                create: function () {
                    var i = new t(6);
                    return e.identity(i), i
                },
                identity: function (t) {
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
                },
                copy: function (t, e) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
                },
                mul: function (t, e, i) {
                    var n = e[0] * i[0] + e[2] * i[1],
                        r = e[1] * i[0] + e[3] * i[1],
                        a = e[0] * i[2] + e[2] * i[3],
                        o = e[1] * i[2] + e[3] * i[3],
                        s = e[0] * i[4] + e[2] * i[5] + e[4],
                        l = e[1] * i[4] + e[3] * i[5] + e[5];
                    return t[0] = n, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t
                },
                translate: function (t, e, i) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t
                },
                rotate: function (t, e, i) {
                    var n = e[0],
                        r = e[2],
                        a = e[4],
                        o = e[1],
                        s = e[3],
                        l = e[5],
                        u = Math.sin(i),
                        c = Math.cos(i);
                    return t[0] = n * c + o * u, t[1] = -n * u + o * c, t[2] = r * c + s * u, t[3] = -r * u + c * s, t[4] = c * a + u * l, t[5] = c * l - u * a, t
                },
                scale: function (t, e, i) {
                    var n = i[0],
                        r = i[1];
                    return t[0] = e[0] * n, t[1] = e[1] * r, t[2] = e[2] * n, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * r, t
                },
                invert: function (t, e) {
                    var i = e[0],
                        n = e[2],
                        r = e[4],
                        a = e[1],
                        o = e[3],
                        s = e[5],
                        l = i * o - a * n;
                    return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - o * r) * l, t[5] = (a * r - i * s) * l, t) : null
                }
            };
        return e
    }), e("zrender/core/vector", [], function () {
        var t = typeof Float32Array === g ? Array : Float32Array,
            e = {
                create: function (e, i) {
                    var n = new t(2);
                    return null == e && (e = 0), null == i && (i = 0), n[0] = e, n[1] = i, n
                },
                copy: function (t, e) {
                    return t[0] = e[0], t[1] = e[1], t
                },
                clone: function (e) {
                    var i = new t(2);
                    return i[0] = e[0], i[1] = e[1], i
                },
                set: function (t, e, i) {
                    return t[0] = e, t[1] = i, t
                },
                add: function (t, e, i) {
                    return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
                },
                scaleAndAdd: function (t, e, i, n) {
                    return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t
                },
                sub: function (t, e, i) {
                    return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
                },
                len: function (t) {
                    return Math.sqrt(this.lenSquare(t))
                },
                lenSquare: function (t) {
                    return t[0] * t[0] + t[1] * t[1]
                },
                mul: function (t, e, i) {
                    return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
                },
                div: function (t, e, i) {
                    return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
                },
                dot: function (t, e) {
                    return t[0] * e[0] + t[1] * e[1]
                },
                scale: function (t, e, i) {
                    return t[0] = e[0] * i, t[1] = e[1] * i, t
                },
                normalize: function (t, i) {
                    var n = e.len(i);
                    return 0 === n ? (t[0] = 0, t[1] = 0) : (t[0] = i[0] / n, t[1] = i[1] / n), t
                },
                distance: function (t, e) {
                    return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
                },
                distanceSquare: function (t, e) {
                    return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
                },
                negate: function (t, e) {
                    return t[0] = -e[0], t[1] = -e[1], t
                },
                lerp: function (t, e, i, n) {
                    return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t
                },
                applyTransform: function (t, e, i) {
                    var n = e[0],
                        r = e[1];
                    return t[0] = i[0] * n + i[2] * r + i[4], t[1] = i[1] * n + i[3] * r + i[5], t
                },
                min: function (t, e, i) {
                    return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t
                },
                max: function (t, e, i) {
                    return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t
                }
            };
        return e[te] = e.len, e.lengthSquare = e.lenSquare, e.dist = e.distance, e.distSquare = e.distanceSquare, e
    }), e("echarts/coord/cartesian/Grid", [me, "exports", "../../util/layout", "../../coord/axisHelper", de, "./Cartesian2D", "./Axis2D", "./GridModel", "../../CoordinateSystem"], function (t) {
        function e(t, e) {
            return t.getCoordSysModel() === e
        }

        function i(t) {
            var e, i = t.model,
                n = i.getFormattedLabels(),
                r = i[ae]("axisLabel.textStyle"),
                a = 1,
                o = n[te];
            o > 40 && (a = Math.ceil(o / 40));
            for (var s = 0; o > s; s += a)
                if (!t.isLabelIgnored(s)) {
                    var l = r.getTextRect(n[s]);
                    e ? e.union(l) : e = l
                } return e
        }

        function n(t, e, i) {
            this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this._model = t
        }

        function a(t, e) {
            var i = t[_](),
                n = i[0] + i[1];
            t.toGlobalCoord = "x" === t.dim ? function (t) {
                return t + e
            } : function (t) {
                return n - t + e
            }, t.toLocalCoord = "x" === t.dim ? function (t) {
                return t - e
            } : function (t) {
                return n - t + e
            }
        }

        function o(t) {
            return c.map(g, function (e) {
                var i = t.getReferringComponents(e)[0];
                return i
            })
        }

        function s(t) {
            return "cartesian2d" === t.get(K)
        }
        var l = t("../../util/layout"),
            u = t("../../coord/axisHelper"),
            c = t(de),
            h = t("./Cartesian2D"),
            f = t("./Axis2D"),
            d = c.each,
            p = u.ifAxisCrossZero,
            m = u.niceScaleExtent;
        t("./GridModel");
        var v = n[he];
        v.type = "grid", v.getRect = function () {
            return this._rect
        }, v[U] = function (t, e) {
            function i(t) {
                var e = n[t];
                for (var i in e)
                    if (e.hasOwnProperty(i)) {
                        var r = e[i];
                        if (r && ("category" === r.type || !p(r))) return !0
                    } return !1
            }
            var n = this._axesMap;
            this._updateScale(t, this._model), d(n.x, function (t) {
                m(t, t.model)
            }), d(n.y, function (t) {
                m(t, t.model)
            }), d(n.x, function (t) {
                i("y") && (t.onZero = !1)
            }), d(n.y, function (t) {
                i("x") && (t.onZero = !1)
            }), this.resize(this._model, e)
        }, v.resize = function (t, e) {
            function n() {
                d(o, function (t) {
                    var e = t.isHorizontal(),
                        i = e ? [0, r.width] : [0, r[ue]],
                        n = t.inverse ? 1 : 0;
                    t.setExtent(i[n], i[1 - n]), a(t, e ? r.x : r.y)
                })
            }
            var r = l.getLayoutRect(t.getBoxLayoutParams(), {
                width: e[re](),
                height: e[ne]()
            });
            this._rect = r;
            var o = this._axesList;
            n(), t.get("containLabel") && (d(o, function (t) {
                if (!t.model.get("axisLabel.inside")) {
                    var e = i(t);
                    if (e) {
                        var n = t.isHorizontal() ? ue : "width",
                            a = t.model.get("axisLabel.margin");
                        r[n] -= e[n] + a, "top" === t[w] ? r.y += e[ue] + a : "left" === t[w] && (r.x += e.width + a)
                    }
                }
            }), n())
        }, v.getAxis = function (t, e) {
            var i = this._axesMap[t];
            if (null != i) {
                if (null == e)
                    for (var n in i)
                        if (i.hasOwnProperty(n)) return i[n];
                return i[e]
            }
        }, v.getCartesian = function (t, e) {
            if (null != t && null != e) {
                var i = "x" + t + "y" + e;
                return this._coordsMap[i]
            }
            for (var n = 0, r = this._coordsList; n < r[te]; n++)
                if (r[n].getAxis("x").index === t || r[n].getAxis("y").index === e) return r[n]
        }, v.convertToPixel = function (t, e, i) {
            var n = this._findConvertTarget(t, e);
            return n.cartesian ? n.cartesian[r](i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null
        }, v.convertFromPixel = function (t, e, i) {
            var n = this._findConvertTarget(t, e);
            return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null
        }, v._findConvertTarget = function (t, e) {
            var i, n, r = e.seriesModel,
                a = e.xAxisModel || r && r.getReferringComponents("xAxis")[0],
                o = e.yAxisModel || r && r.getReferringComponents("yAxis")[0],
                s = e.gridModel,
                l = this._coordsList;
            if (r) i = r[K], c[J](l, i) < 0 && (i = null);
            else if (a && o) i = this.getCartesian(a.componentIndex, o.componentIndex);
            else if (a) n = this.getAxis("x", a.componentIndex);
            else if (o) n = this.getAxis("y", o.componentIndex);
            else if (s) {
                var u = s[K];
                u === this && (i = this._coordsList[0])
            }
            return {
                cartesian: i,
                axis: n
            }
        }, v.containPoint = function (t) {
            var e = this._coordsList[0];
            return e ? e.containPoint(t) : void 0
        }, v._initCartesian = function (t, i) {
            function n(n) {
                return function (s, l) {
                    if (e(s, t, i)) {
                        var c = s.get(w);
                        "x" === n ? "top" !== c && c !== ee && (c = ee, r[c] && (c = "top" === c ? ee : "top")) : "left" !== c && "right" !== c && (c = "left", r[c] && (c = "left" === c ? "right" : "left")), r[c] = !0;
                        var h = new f(n, u.createScaleByModel(s), [0, 0], s.get("type"), c),
                            d = "category" === h.type;
                        h.onBand = d && s.get("boundaryGap"), h.inverse = s.get("inverse"), h.onZero = s.get("axisLine.onZero"), s.axis = h, h.model = s, h.grid = this, h.index = l, this._axesList.push(h), a[n][l] = h, o[n]++
                    }
                }
            }
            var r = {
                left: !1,
                right: !1,
                top: !1,
                bottom: !1
            },
                a = {
                    x: {},
                    y: {}
                },
                o = {
                    x: 0,
                    y: 0
                };
            return i.eachComponent("xAxis", n("x"), this), i.eachComponent("yAxis", n("y"), this), o.x && o.y ? (this._axesMap = a, void d(a.x, function (t, e) {
                d(a.y, function (i, n) {
                    var r = "x" + e + "y" + n,
                        a = new h(r);
                    a.grid = this, this._coordsMap[r] = a, this._coordsList.push(a), a.addAxis(t), a.addAxis(i)
                }, this)
            }, this)) : (this._axesMap = {}, void (this._axesList = []))
        }, v._updateScale = function (t, i) {
            function n(t, e, i) {
                d(i.coordDimToDataDim(e.dim), function (i) {
                    e.scale.unionExtentFromData(t, i)
                })
            }
            c.each(this._axesList, function (t) {
                t.scale.setExtent(1 / 0, -1 / 0)
            }), t[Z](function (r) {
                if (s(r)) {
                    var a = o(r, t),
                        l = a[0],
                        u = a[1];
                    if (!e(l, i, t) || !e(u, i, t)) return;
                    var c = this.getCartesian(l.componentIndex, u.componentIndex),
                        h = r[Q](),
                        f = c.getAxis("x"),
                        d = c.getAxis("y");
                    "list" === h.type && (n(h, f, r), n(h, d, r))
                }
            }, this)
        };
        var g = ["xAxis", "yAxis"];
        return n[X] = function (t, e) {
            var i = [];
            return t.eachComponent("grid", function (r, a) {
                var o = new n(r, t, e);
                o.name = "grid_" + a, o.resize(r, e), r[K] = o, i.push(o)
            }), t[Z](function (e) {
                if (s(e)) {
                    var i = o(e, t),
                        n = i[0],
                        r = i[1],
                        a = n.getCoordSysModel(),
                        l = a[K];
                    e[K] = l.getCartesian(n.componentIndex, r.componentIndex)
                }
            }), i
        }, n.dimensions = h[he].dimensions, t("../../CoordinateSystem").register("cartesian2d", n), n
    }), e("echarts/chart/bar/BarSeries", [me, "./BaseBarSeries"], function (t) {
        return t("./BaseBarSeries")[H]({
            type: "series.bar",
            dependencies: ["grid", "polar"],
            brushSelector: "rect"
        })
    }), e("echarts/chart/bar/BarView", [me, de, n, "./helper", "../../model/Model", "./barItemStyle", "../../echarts"], function (t) {
        function e(t, e, i, n, r, a, o) {
            var s = new c.Rect({
                shape: u[H]({}, n)
            });
            if (a) {
                var l = s.shape,
                    h = r ? ue : "width",
                    f = {};
                l[h] = 0, f[h] = n[h], c[o ? "updateProps" : "initProps"](s, {
                    shape: f
                }, a, e)
            }
            return s
        }

        function i(t, e, i) {
            i.style.text = "", c.updateProps(i, {
                shape: {
                    width: 0
                }
            }, e, t, function () {
                i[l] && i[l][q](i)
            })
        }

        function r(t, e, i) {
            var n = t.getItemLayout(e),
                r = s(i, n),
                a = n.width > 0 ? 1 : -1,
                o = n[ue] > 0 ? 1 : -1;
            return {
                x: n.x + a * r / 2,
                y: n.y + o * r / 2,
                width: n.width - a * r,
                height: n[ue] - o * r
            }
        }

        function a(t, e, i, n, r, a, o) {
            var s = e[Y](i, "color"),
                l = e[Y](i, b),
                h = n[ae]("itemStyle.normal"),
                f = n[ae]("itemStyle.emphasis").getBarItemStyle();
            t.setShape("r", h.get("barBorderRadius") || 0), t.useStyle(u[V]({
                fill: s,
                opacity: l
            }, h.getBarItemStyle()));
            var p = o ? r[ue] > 0 ? ee : "top" : r.width > 0 ? "left" : "right";
            d.setLabel(t.style, f, n, s, a, i, p), c.setHoverStyle(t, f)
        }

        function s(t, e) {
            var i = t.get(p) || 0;
            return Math.min(i, Math.abs(e.width), Math.abs(e[ue]))
        }
        var u = t(de),
            c = t(n),
            d = t("./helper"),
            p = ["itemStyle", "normal", "barBorderWidth"];
        u[H](t("../../model/Model")[he], t("./barItemStyle"));
        var m = t("../../echarts").extendChartView({
            type: "bar",
            render: function (t, e, i) {
                var n = t.get(K);
                return "cartesian2d" === n && this._renderOnCartesian(t, e, i), this.group
            },
            dispose: u.noop,
            _renderOnCartesian: function (t) {
                var n = this.group,
                    s = t[Q](),
                    l = this._data,
                    u = t[K],
                    h = u.getBaseAxis(),
                    d = h.isHorizontal(),
                    p = t.isAnimationEnabled() ? t : null;
                s.diff(l).add(function (i) {
                    if (s.hasValue(i)) {
                        var l = s[o](i),
                            u = r(s, i, l),
                            c = e(s, i, l, u, d, p);
                        s.setItemGraphicEl(i, c), n.add(c), a(c, s, i, l, u, t, d)
                    }
                })[U](function (i, u) {
                    var h = l[f](u);
                    if (!s.hasValue(i)) return void n[q](h);
                    var m = s[o](i),
                        v = r(s, i, m);
                    h ? c.updateProps(h, {
                        shape: v
                    }, p, i) : h = e(s, i, m, v, d, p, !0), s.setItemGraphicEl(i, h), n.add(h), a(h, s, i, m, v, t, d)
                })[q](function (t) {
                    var e = l[f](t);
                    e && i(t, p, e)
                }).execute(), this._data = s
            },
            remove: function (t) {
                var e = this.group,
                    n = this._data;
                t.get(le) ? n && n[h](function (e) {
                    i(e[$], t, e)
                }) : e[P]()
            }
        });
        return m
    }), e("echarts/layout/barGrid", [me, de, "../util/number"], function (t) {
        function e(t) {
            return t.get("stack") || "__ec_stack_" + t[R]
        }

        function i(t) {
            return t.dim + t.index
        }

        function n(t) {
            var n = {};
            o.each(t, function (t) {
                var r = t[Q](),
                    a = t[K],
                    o = a.getBaseAxis(),
                    s = o[_](),
                    u = "category" === o.type ? o.getBandWidth() : Math.abs(s[1] - s[0]) / r.count(),
                    c = n[i(o)] || {
                        bandWidth: u,
                        remainedWidth: u,
                        autoWidthCount: 0,
                        categoryGap: "20%",
                        gap: "30%",
                        stacks: {}
                    },
                    h = c.stacks;
                n[i(o)] = c;
                var f = e(t);
                h[f] || c.autoWidthCount++, h[f] = h[f] || {
                    width: 0,
                    maxWidth: 0
                };
                var d = l(t.get("barWidth"), u),
                    p = l(t.get("barMaxWidth"), u),
                    m = t.get("barGap"),
                    v = t.get("barCategoryGap");
                d && !h[f].width && (d = Math.min(c.remainedWidth, d), h[f].width = d, c.remainedWidth -= d), p && (h[f].maxWidth = p), null != m && (c.gap = m), null != v && (c.categoryGap = v)
            });
            var r = {};
            return o.each(n, function (t, e) {
                r[e] = {};
                var i = t.stacks,
                    n = t.bandWidth,
                    a = l(t.categoryGap, n),
                    s = l(t.gap, 1),
                    u = t.remainedWidth,
                    c = t.autoWidthCount,
                    h = (u - a) / (c + (c - 1) * s);
                h = Math.max(h, 0), o.each(i, function (t) {
                    var e = t.maxWidth;
                    !t.width && e && h > e && (e = Math.min(e, u), u -= e, t.width = e, c--)
                }), h = (u - a) / (c + (c - 1) * s), h = Math.max(h, 0);
                var f, d = 0;
                o.each(i, function (t) {
                    t.width || (t.width = h), f = t, d += t.width * (1 + s)
                }), f && (d -= f.width * s);
                var p = -d / 2;
                o.each(i, function (t, i) {
                    r[e][i] = r[e][i] || {
                        offset: p,
                        width: t.width
                    }, p += t.width * (1 + s)
                })
            }), r
        }

        function r(t, r) {
            var a = n(o.filter(r.getSeriesByType(t), function (t) {
                return !r.isSeriesFiltered(t) && t[K] && "cartesian2d" === t[K].type
            })),
                s = {},
                l = {};
            r.eachSeriesByType(t, function (t) {
                var n = t[Q](),
                    r = t[K],
                    o = r.getBaseAxis(),
                    u = e(t),
                    c = a[i(o)][u],
                    h = c.offset,
                    f = c.width,
                    d = r.getOtherAxis(o),
                    p = t.get("barMinHeight") || 0,
                    m = o.onZero ? d.toGlobalCoord(d.dataToCoord(0)) : d.getGlobalExtent()[0],
                    v = r.dataToPoints(n, !0);
                s[u] = s[u] || [], l[u] = l[u] || [], n.setLayout({
                    offset: h,
                    size: f
                }), n.each(d.dim, function (t, e) {
                    if (!isNaN(t)) {
                        s[u][e] || (s[u][e] = {
                            p: m,
                            n: m
                        }, l[u][e] = {
                            p: m,
                            n: m
                        });
                        var i, r, a, o, c = t >= 0 ? "p" : "n",
                            g = v[e],
                            y = s[u][e][c],
                            _ = l[u][e][c];
                        d.isHorizontal() ? (i = y, r = g[1] + h, a = g[0] - _, o = f, l[u][e][c] += a, Math.abs(a) < p && (a = (0 > a ? -1 : 1) * p), s[u][e][c] += a) : (i = g[0] + h, r = y, a = f, o = g[1] - _, l[u][e][c] += o, Math.abs(o) < p && (o = (0 >= o ? -1 : 1) * p), s[u][e][c] += o), n.setItemLayout(e, {
                            x: i,
                            y: r,
                            width: a,
                            height: o
                        })
                    }
                }, !0)
            }, this)
        }
        var o = t(de),
            s = t("../util/number"),
            l = s[a];
        return r
    }), e("echarts/chart/line/LineSeries", [me, "../helper/createListFromArray", "../../model/Series"], function (t) {
        var e = t("../helper/createListFromArray"),
            i = t("../../model/Series");
        return i[H]({
            type: "series.line",
            dependencies: ["grid", "polar"],
            getInitialData: function (t, i) {
                return e(t.data, this, i)
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                hoverAnimation: !0,
                clipOverflow: !0,
                label: {
                    normal: {
                        position: "top"
                    }
                },
                lineStyle: {
                    normal: {
                        width: 2,
                        type: "solid"
                    }
                },
                step: !1,
                smooth: !1,
                smoothMonotone: null,
                symbol: "emptyCircle",
                symbolSize: 4,
                symbolRotate: null,
                showSymbol: !0,
                showAllSymbol: !1,
                connectNulls: !1,
                sampling: "none",
                animationEasing: "linear",
                progressive: 0,
                hoverLayerThreshold: 1 / 0
            }
        })
    }), e("echarts/chart/line/LineView", [me, de, "../helper/SymbolDraw", "../helper/Symbol", "./lineAnimationDiff", n, "../../util/model", "./poly", "../../view/Chart"], function (t) {
        function e(t, e) {
            if (t[te] === e[te]) {
                for (var i = 0; i < t[te]; i++) {
                    var n = t[i],
                        r = e[i];
                    if (n[0] !== r[0] || n[1] !== r[1]) return
                }
                return !0
            }
        }

        function i(t) {
            return typeof t === k ? t : t ? .3 : 0
        }

        function a(t) {
            var e = t.getGlobalExtent();
            if (t.onBand) {
                var i = t.getBandWidth() / 2 - 1,
                    n = e[1] > e[0] ? 1 : -1;
                e[0] += n * i, e[1] -= n * i
            }
            return e
        }

        function o(t) {
            return t >= 0 ? 1 : -1
        }

        function s(t, e) {
            var i = t.getBaseAxis(),
                n = t.getOtherAxis(i),
                a = i.onZero ? 0 : n.scale[_]()[0],
                s = n.dim,
                l = "x" === s || "radius" === s ? 1 : 0;
            return e.mapArray([s], function (n, u) {
                for (var c, h = e.stackedOn; h && o(h.get(s, u)) === o(n);) {
                    c = h;
                    break
                }
                var f = [];
                return f[l] = e.get(i.dim, u), f[1 - l] = c ? c.get(s, u, !0) : a, t[r](f)
            }, !0)
        }

        function l(t, e, i) {
            var n = a(t.getAxis("x")),
                r = a(t.getAxis("y")),
                o = t.getBaseAxis().isHorizontal(),
                s = Math.min(n[0], n[1]),
                l = Math.min(r[0], r[1]),
                u = Math.max(n[0], n[1]) - s,
                c = Math.max(r[0], r[1]) - l,
                h = i.get("lineStyle.normal.width") || 2,
                f = i.get("clipOverflow") ? h / 2 : Math.max(u, c);
            o ? (l -= f, c += 2 * f) : (s -= f, u += 2 * f);
            var d = new b.Rect({
                shape: {
                    x: s,
                    y: l,
                    width: u,
                    height: c
                }
            });
            return e && (d.shape[o ? "width" : ue] = 0, b.initProps(d, {
                shape: {
                    width: u,
                    height: c
                }
            }, i)), d
        }

        function u(t, e, i) {
            var n = t.getAngleAxis(),
                r = t.getRadiusAxis(),
                a = r[_](),
                o = n[_](),
                s = Math.PI / 180,
                l = new b.Sector({
                    shape: {
                        cx: t.cx,
                        cy: t.cy,
                        r0: a[0],
                        r: a[1],
                        startAngle: -o[0] * s,
                        endAngle: -o[1] * s,
                        clockwise: n.inverse
                    }
                });
            return e && (l.shape.endAngle = -o[0] * s, b.initProps(l, {
                shape: {
                    endAngle: -o[1] * s
                }
            }, i)), l
        }

        function c(t, e, i) {
            return "polar" === t.type ? u(t, e, i) : l(t, e, i)
        }

        function d(t, e, i) {
            for (var n = e.getBaseAxis(), r = "x" === n.dim || "radius" === n.dim ? 0 : 1, a = [], o = 0; o < t[te] - 1; o++) {
                var s = t[o + 1],
                    l = t[o];
                a.push(l);
                var u = [];
                switch (i) {
                    case "end":
                        u[r] = s[r], u[1 - r] = l[1 - r], a.push(u);
                        break;
                    case T:
                        var c = (l[r] + s[r]) / 2,
                            h = [];
                        u[r] = h[r] = c, u[1 - r] = l[1 - r], h[1 - r] = s[1 - r], a.push(u), a.push(h);
                        break;
                    default:
                        u[r] = l[r], u[1 - r] = s[1 - r], a.push(u)
                }
            }
            return t[o] && a.push(t[o]), a
        }

        function m(t, e) {
            var i = t.getVisual("visualMeta");
            if (i && i[te] && t.count()) {
                for (var n, r = i[te] - 1; r >= 0; r--)
                    if (i[r].dimension < 2) {
                        n = i[r];
                        break
                    } if (n && "cartesian2d" === e.type) {
                        var a = n.dimension,
                            o = t.dimensions[a],
                            s = e.getAxis(o),
                            l = v.map(n.stops, function (t) {
                                return {
                                    coord: s.toGlobalCoord(s.dataToCoord(t.value)),
                                    color: t.color
                                }
                            }),
                            u = l[te],
                            c = n.outerColors.slice();
                        u && l[0].coord > l[u - 1].coord && (l.reverse(), c.reverse());
                        var h = 10,
                            f = l[0].coord - h,
                            d = l[u - 1].coord + h,
                            p = d - f;
                        if (.001 > p) return "transparent";
                        v.each(l, function (t) {
                            t.offset = (t.coord - f) / p
                        }), l.push({
                            offset: u ? l[u - 1].offset : .5,
                            color: c[1] || "transparent"
                        }), l.unshift({
                            offset: u ? l[0].offset : .5,
                            color: c[0] || "transparent"
                        });
                        var m = new b.LinearGradient(0, 0, 0, 0, l, !0);
                        return m[o] = f, m[o + "2"] = d, m
                    }
            }
        }
        var v = t(de),
            g = t("../helper/SymbolDraw"),
            y = t("../helper/Symbol"),
            x = t("./lineAnimationDiff"),
            b = t(n),
            M = t("../../util/model"),
            S = t("./poly"),
            C = t("../../view/Chart");
        return C[H]({
            type: "line",
            init: function () {
                var t = new b.Group,
                    e = new g;
                this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t
            },
            render: function (t, n, r) {
                var a = t[K],
                    o = this.group,
                    l = t[Q](),
                    u = t[ae]("lineStyle.normal"),
                    f = t[ae]("areaStyle.normal"),
                    p = l.mapArray(l.getItemLayout, !0),
                    g = "polar" === a.type,
                    y = this._coordSys,
                    _ = this._symbolDraw,
                    x = this._polyline,
                    b = this._polygon,
                    w = this._lineGroup,
                    M = t.get(le),
                    T = !f.isEmpty(),
                    S = s(a, l),
                    C = t.get("showSymbol"),
                    A = C && !g && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(l, a),
                    P = this._data;
                P && P[h](function (t, e) {
                    t.__temp && (o[q](t), P.setItemGraphicEl(e, null))
                }), C || _[q](), o.add(w);
                var k = !g && t.get("step");
                x && y.type === a.type && k === this._step ? (T && !b ? b = this._newPolygon(p, S, a, M) : b && !T && (w[q](b), b = this._polygon = null), w.setClipPath(c(a, !1, t)), C && _.updateData(l, A), l[h](function (t) {
                    t.stopAnimation(!0)
                }), e(this._stackedOnPoints, S) && e(this._points, p) || (M ? this._updateAnimation(l, S, a, r, k) : (k && (p = d(p, a, k), S = d(S, a, k)), x.setShape({
                    points: p
                }), b && b.setShape({
                    points: p,
                    stackedOnPoints: S
                })))) : (C && _.updateData(l, A), k && (p = d(p, a, k), S = d(S, a, k)), x = this._newPolyline(p, a, M), T && (b = this._newPolygon(p, S, a, M)), w.setClipPath(c(a, !0, t)));
                var L = m(l, a) || l.getVisual("color");
                x.useStyle(v[V](u.getLineStyle(), {
                    fill: "none",
                    stroke: L,
                    lineJoin: "bevel"
                }));
                var z = t.get("smooth");
                if (z = i(t.get("smooth")), x.setShape({
                    smooth: z,
                    smoothMonotone: t.get("smoothMonotone"),
                    connectNulls: t.get("connectNulls")
                }), b) {
                    var I = l.stackedOn,
                        D = 0;
                    if (b.useStyle(v[V](f.getAreaStyle(), {
                        fill: L,
                        opacity: .7,
                        lineJoin: "bevel"
                    })), I) {
                        var O = I.hostModel;
                        D = i(O.get("smooth"))
                    }
                    b.setShape({
                        smooth: z,
                        stackedOnSmooth: D,
                        smoothMonotone: t.get("smoothMonotone"),
                        connectNulls: t.get("connectNulls")
                    })
                }
                this._data = l, this._coordSys = a, this._stackedOnPoints = S, this._points = p, this._step = k
            },
            dispose: function () { },
            highlight: function (t, e, i, n) {
                var r = t[Q](),
                    a = M.queryDataIndex(r, n);
                if (!(a instanceof Array) && null != a && a >= 0) {
                    var o = r[f](a);
                    if (!o) {
                        var s = r.getItemLayout(a);
                        if (!s) return;
                        o = new y(r, a), o[w] = s, o.setZ(t.get(D), t.get("z")), o[ie] = isNaN(s[0]) || isNaN(s[1]), o.__temp = !0, r.setItemGraphicEl(a, o), o.stopSymbolAnimation(!0), this.group.add(o)
                    }
                    o.highlight()
                } else C[he].highlight.call(this, t, e, i, n)
            },
            downplay: function (t, e, i, n) {
                var r = t[Q](),
                    a = M.queryDataIndex(r, n);
                if (null != a && a >= 0) {
                    var o = r[f](a);
                    o && (o.__temp ? (r.setItemGraphicEl(a, null), this.group[q](o)) : o.downplay())
                } else C[he].downplay.call(this, t, e, i, n)
            },
            _newPolyline: function (t) {
                var e = this._polyline;
                return e && this._lineGroup[q](e), e = new S.Polyline({
                    shape: {
                        points: t
                    },
                    silent: !0,
                    z2: 10
                }), this._lineGroup.add(e), this._polyline = e, e
            },
            _newPolygon: function (t, e) {
                var i = this._polygon;
                return i && this._lineGroup[q](i), i = new S.Polygon({
                    shape: {
                        points: t,
                        stackedOnPoints: e
                    },
                    silent: !0
                }), this._lineGroup.add(i), this._polygon = i, i
            },
            _getSymbolIgnoreFunc: function (t, e) {
                var i = e.getAxesByScale(p)[0];
                return i && i.isLabelIgnored ? v.bind(i.isLabelIgnored, i) : void 0
            },
            _updateAnimation: function (t, e, i, n, r) {
                var a = this._polyline,
                    o = this._polygon,
                    s = t.hostModel,
                    l = x(this._data, t, this._stackedOnPoints, e, this._coordSys, i),
                    u = l.current,
                    c = l.stackedOnCurrent,
                    h = l.next,
                    p = l.stackedOnNext;
                r && (u = d(l.current, i, r), c = d(l.stackedOnCurrent, i, r), h = d(l.next, i, r), p = d(l.stackedOnNext, i, r)), a.shape.__points = l.current, a.shape.points = u, b.updateProps(a, {
                    shape: {
                        points: h
                    }
                }, s), o && (o.setShape({
                    points: u,
                    stackedOnPoints: c
                }), b.updateProps(o, {
                    shape: {
                        points: h,
                        stackedOnPoints: p
                    }
                }, s));
                for (var m = [], v = l.status, g = 0; g < v[te]; g++) {
                    var y = v[g].cmd;
                    if ("=" === y) {
                        var _ = t[f](v[g].idx1);
                        _ && m.push({
                            el: _,
                            ptIdx: g
                        })
                    }
                }
                a.animators && a.animators[te] && a.animators[0].during(function () {
                    for (var t = 0; t < m[te]; t++) {
                        var e = m[t].el;
                        e.attr(w, a.shape.__points[m[t].ptIdx])
                    }
                })
            },
            remove: function () {
                var t = this.group,
                    e = this._data;
                this._lineGroup[P](), this._symbolDraw[q](!0), e && e[h](function (i, n) {
                    i.__temp && (t[q](i), e.setItemGraphicEl(n, null))
                }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null
            }
        })
    }), e("echarts/visual/symbol", [me], function () {
        return function (t, e, i, n) {
            n.eachRawSeriesByType(t, function (t) {
                var r = t[Q](),
                    a = t.get("symbol") || e,
                    s = t.get("symbolSize");
                r.setVisual({
                    legendSymbol: i || a,
                    symbol: a,
                    symbolSize: s
                }), n.isSeriesFiltered(t) || (typeof s === L && r.each(function (e) {
                    var i = t.getRawValue(e),
                        n = t[E](e);
                    r.setItemVisual(e, "symbolSize", s(i, n))
                }), r.each(function (t) {
                    var e = r[o](t),
                        i = e[d]("symbol", !0),
                        n = e[d]("symbolSize", !0);
                    null != i && r.setItemVisual(t, "symbol", i), null != n && r.setItemVisual(t, "symbolSize", n)
                }))
            })
        }
    }), e("echarts/layout/points", [me], function () {
        return function (t, e) {
            e.eachSeriesByType(t, function (t) {
                var e = t[Q](),
                    i = t[K];
                if (i) {
                    var n = i.dimensions;
                    "singleAxis" === i.type ? e.each(n[0], function (t, n) {
                        e.setItemLayout(n, isNaN(t) ? [0 / 0, 0 / 0] : i[r](t))
                    }) : e.each(n, function (t, n, a) {
                        e.setItemLayout(a, isNaN(t) || isNaN(n) ? [0 / 0, 0 / 0] : i[r]([t, n]))
                    }, !0)
                }
            })
        }
    }), e("echarts/processor/dataSample", [], function () {
        var t = {
            average: function (t) {
                for (var e = 0, i = 0, n = 0; n < t[te]; n++) isNaN(t[n]) || (e += t[n], i++);
                return 0 === i ? 0 / 0 : e / i
            },
            sum: function (t) {
                for (var e = 0, i = 0; i < t[te]; i++) e += t[i] || 0;
                return e
            },
            max: function (t) {
                for (var e = -1 / 0, i = 0; i < t[te]; i++) t[i] > e && (e = t[i]);
                return e
            },
            min: function (t) {
                for (var e = 1 / 0, i = 0; i < t[te]; i++) t[i] < e && (e = t[i]);
                return e
            },
            nearest: function (t) {
                return t[0]
            }
        },
            e = function (t) {
                return Math.round(t[te] / 2)
            };
        return function (i, n) {
            n.eachSeriesByType(i, function (i) {
                var n = i[Q](),
                    r = i.get("sampling"),
                    a = i[K];
                if ("cartesian2d" === a.type && r) {
                    var o = a.getBaseAxis(),
                        s = a.getOtherAxis(o),
                        l = o[_](),
                        u = l[1] - l[0],
                        c = Math.round(n.count() / u);
                    if (c > 1) {
                        var h;
                        typeof r === ce ? h = t[r] : typeof r === L && (h = r), h && (n = n.downSample(s.dim, 1 / c, h, e), i.setData(n))
                    }
                }
            }, this)
        }
    }), e("echarts/chart/gauge/GaugeSeries", [me, "../../data/List", "../../model/Series", de], function (t) {
        var e = t("../../data/List"),
            i = t("../../model/Series"),
            n = t(de),
            r = i[H]({
                type: "series.gauge",
                getInitialData: function (t) {
                    var i = new e(["value"], this),
                        r = t.data || [];
                    return n[z](r) || (r = [r]), i.initData(r), i
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    center: ["50%", "50%"],
                    legendHoverLink: !0,
                    radius: "75%",
                    startAngle: 225,
                    endAngle: -45,
                    clockwise: !0,
                    min: 0,
                    max: 100,
                    splitNumber: 10,
                    axisLine: {
                        show: !0,
                        lineStyle: {
                            color: [
                                [.2, "#91c7ae"],
                                [.8, "#63869e"],
                                [1, "#c23531"]
                            ],
                            width: 30
                        }
                    },
                    splitLine: {
                        show: !0,
                        length: 30,
                        lineStyle: {
                            color: "#eee",
                            width: 2,
                            type: "solid"
                        }
                    },
                    axisTick: {
                        show: !0,
                        splitNumber: 5,
                        length: 8,
                        lineStyle: {
                            color: "#eee",
                            width: 1,
                            type: "solid"
                        }
                    },
                    axisLabel: {
                        show: !0,
                        distance: 5,
                        textStyle: {
                            color: "auto"
                        }
                    },
                    pointer: {
                        show: !0,
                        length: "80%",
                        width: 8
                    },
                    itemStyle: {
                        normal: {
                            color: "auto"
                        }
                    },
                    title: {
                        show: !0,
                        offsetCenter: [0, "-40%"],
                        textStyle: {
                            color: "#333",
                            fontSize: 15
                        }
                    },
                    detail: {
                        show: !0,
                        backgroundColor: "rgba(0,0,0,0)",
                        borderWidth: 0,
                        borderColor: "#ccc",
                        width: 100,
                        height: 40,
                        offsetCenter: [0, "40%"],
                        textStyle: {
                            color: "auto",
                            fontSize: 30
                        }
                    }
                }
            });
        return r
    }), e("echarts/chart/gauge/GaugeView", [me, "./PointerPath", n, "../../util/number", "../../view/Chart"], function (t) {
        function e(t, e) {
            var i = t.get(M),
                n = e[re](),
                r = e[ne](),
                a = Math.min(n, r),
                o = c(i[0], e[re]()),
                s = c(i[1], e[ne]()),
                l = c(t.get("radius"), a / 2);
            return {
                cx: o,
                cy: s,
                r: l
            }
        }

        function i(t, e) {
            return e && (typeof e === ce ? t = e[I]("{value}", null != t ? t : "") : typeof e === L && (t = e(t))), t
        }
        var r = t("./PointerPath"),
            s = t(n),
            l = t("../../util/number"),
            c = l[a],
            d = 2 * Math.PI,
            p = t("../../view/Chart")[H]({
                type: "gauge",
                render: function (t, i, n) {
                    this.group[P]();
                    var r = t.get("axisLine.lineStyle.color"),
                        a = e(t, n);
                    this._renderMain(t, i, n, r, a)
                },
                dispose: function () { },
                _renderMain: function (t, e, i, n, r) {
                    for (var a = this.group, o = t[ae]("axisLine"), l = o[ae]("lineStyle"), u = t.get("clockwise"), c = -t.get("startAngle") / 180 * Math.PI, h = -t.get("endAngle") / 180 * Math.PI, f = (h - c) % d, p = c, m = l.get("width"), v = 0; v < n[te]; v++) {
                        var g = Math.min(Math.max(n[v][0], 0), 1),
                            h = c + f * g,
                            y = new s.Sector({
                                shape: {
                                    startAngle: p,
                                    endAngle: h,
                                    cx: r.cx,
                                    cy: r.cy,
                                    clockwise: u,
                                    r0: r.r - m,
                                    r: r.r
                                },
                                silent: !0
                            });
                        y[O]({
                            fill: n[v][1]
                        }), y[O](l.getLineStyle(["color", "borderWidth", "borderColor"])), a.add(y), p = h
                    }
                    var _ = function (t) {
                        if (0 >= t) return n[0][1];
                        for (var e = 0; e < n[te]; e++)
                            if (n[e][0] >= t && (0 === e ? 0 : n[e - 1][0]) < t) return n[e][1];
                        return n[e - 1][1]
                    };
                    if (!u) {
                        var x = c;
                        c = h, h = x
                    }
                    this._renderTicks(t, e, i, _, r, c, h, u), this._renderPointer(t, e, i, _, r, c, h, u), this._renderTitle(t, e, i, _, r), this._renderDetail(t, e, i, _, r)
                },
                _renderTicks: function (t, e, n, r, a, o, h) {
                    for (var f = this.group, d = a.cx, p = a.cy, m = a.r, v = +t.get("min"), g = +t.get("max"), y = t[ae]("splitLine"), _ = t[ae]("axisTick"), x = t[ae]("axisLabel"), b = t.get("splitNumber"), w = _.get("splitNumber"), S = c(y.get(te), m), P = c(_.get(te), m), k = o, L = (h - o) / b, z = L / w, I = y[ae]("lineStyle").getLineStyle(), D = _[ae]("lineStyle").getLineStyle(), B = x[ae](A), E = 0; b >= E; E++) {
                        var R = Math.cos(k),
                            N = Math.sin(k);
                        if (y.get("show")) {
                            var F = new s.Line({
                                shape: {
                                    x1: R * m + d,
                                    y1: N * m + p,
                                    x2: R * (m - S) + d,
                                    y2: N * (m - S) + p
                                },
                                style: I,
                                silent: !0
                            });
                            "auto" === I[u] && F[O]({
                                stroke: r(E / b)
                            }), f.add(F)
                        }
                        if (x.get("show")) {
                            var G = i(l.round(E / b * (g - v) + v), x.get("formatter")),
                                V = x.get("distance"),
                                H = new s.Text({
                                    style: {
                                        text: G,
                                        x: R * (m - S - V) + d,
                                        y: N * (m - S - V) + p,
                                        fill: B.getTextColor(),
                                        textFont: B[C](),
                                        textVerticalAlign: -.4 > N ? "top" : N > .4 ? ee : T,
                                        textAlign: -.4 > R ? "left" : R > .4 ? "right" : M
                                    },
                                    silent: !0
                                });
                            "auto" === H.style.fill && H[O]({
                                fill: r(E / b)
                            }), f.add(H)
                        }
                        if (_.get("show") && E !== b) {
                            for (var q = 0; w >= q; q++) {
                                var R = Math.cos(k),
                                    N = Math.sin(k),
                                    W = new s.Line({
                                        shape: {
                                            x1: R * m + d,
                                            y1: N * m + p,
                                            x2: R * (m - P) + d,
                                            y2: N * (m - P) + p
                                        },
                                        silent: !0,
                                        style: D
                                    });
                                "auto" === D[u] && W[O]({
                                    stroke: r((E + q / w) / b)
                                }), f.add(W), k += z
                            }
                            k -= z
                        } else k += L
                    }
                },
                _renderPointer: function (t, e, i, n, a, u, d) {
                    var p = this.group,
                        m = this._data;
                    if (!t.get("pointer.show")) return void m[h](function (t) {
                        p[q](t)
                    });
                    var v = [+t.get("min"), +t.get("max")],
                        g = [u, d],
                        y = t[Q]();
                    y.diff(m).add(function (e) {
                        var i = new r({
                            shape: {
                                angle: u
                            }
                        });
                        s.updateProps(i, {
                            shape: {
                                angle: l.linearMap(y.get("value", e), v, g, !0)
                            }
                        }, t), p.add(i), y.setItemGraphicEl(e, i)
                    })[U](function (e, i) {
                        var n = m[f](i);
                        s.updateProps(n, {
                            shape: {
                                angle: l.linearMap(y.get("value", e), v, g, !0)
                            }
                        }, t), p.add(n), y.setItemGraphicEl(e, n)
                    })[q](function (t) {
                        var e = m[f](t);
                        p[q](e)
                    }).execute(), y[h](function (t, e) {
                        var i = y[o](e),
                            r = i[ae]("pointer");
                        t.setShape({
                            x: a.cx,
                            y: a.cy,
                            width: c(r.get("width"), a.r),
                            r: c(r.get(te), a.r)
                        }), t.useStyle(i[ae]("itemStyle.normal").getItemStyle()), "auto" === t.style.fill && t[O]("fill", n((y.get("value", e) - v[0]) / (v[1] - v[0]))), s.setHoverStyle(t, i[ae]("itemStyle.emphasis").getItemStyle())
                    }), this._data = y
                },
                _renderTitle: function (t, e, i, n, r) {
                    var a = t[ae]("title");
                    if (a.get("show")) {
                        var o = a[ae](A),
                            l = a.get("offsetCenter"),
                            u = r.cx + c(l[0], r.r),
                            h = r.cy + c(l[1], r.r),
                            f = new s.Text({
                                style: {
                                    x: u,
                                    y: h,
                                    text: t[Q]().getName(0),
                                    fill: o.getTextColor(),
                                    textFont: o[C](),
                                    textAlign: "center",
                                    textVerticalAlign: "middle"
                                }
                            });
                        this.group.add(f)
                    }
                },
                _renderDetail: function (t, e, n, r, a) {
                    var o = t[ae]("detail"),
                        u = +t.get("min"),
                        h = +t.get("max");
                    if (o.get("show")) {
                        var f = o[ae](A),
                            d = o.get("offsetCenter"),
                            p = a.cx + c(d[0], a.r),
                            m = a.cy + c(d[1], a.r),
                            v = c(o.get("width"), a.r),
                            g = c(o.get(ue), a.r),
                            y = t[Q]().get("value", 0),
                            _ = new s.Rect({
                                shape: {
                                    x: p - v / 2,
                                    y: m - g / 2,
                                    width: v,
                                    height: g
                                },
                                style: {
                                    text: i(y, o.get("formatter")),
                                    fill: o.get("backgroundColor"),
                                    textFill: f.getTextColor(),
                                    textFont: f[C]()
                                }
                            });
                        "auto" === _.style.textFill && _[O]("textFill", r(l.linearMap(y, [u, h], [0, 1], !0))), _[O](o.getItemStyle(["color"])), this.group.add(_)
                    }
                }
            });
        return p
    }), e("echarts/component/axis", [me, "../coord/cartesian/AxisModel", "./axis/AxisView"], function (t) {
        t("../coord/cartesian/AxisModel"), t("./axis/AxisView")
    }), e("echarts/util/layout", [me, de, "zrender/core/BoundingRect", "./number", "./format"], function (t) {
        function e(t, e, i, n, r) {
            var a = 0,
                o = 0;
            null == n && (n = 1 / 0), null == r && (r = 1 / 0);
            var s = 0;
            e.eachChild(function (l, u) {
                var c, h, f = l[w],
                    d = l[S](),
                    p = e.childAt(u + 1),
                    m = p && p[S]();
                if ("horizontal" === t) {
                    var v = d.width + (m ? -m.x + d.x : 0);
                    c = a + v, c > n || l.newline ? (a = 0, c = v, o += s + i, s = d[ue]) : s = Math.max(s, d[ue])
                } else {
                    var g = d[ue] + (m ? -m.y + d.y : 0);
                    h = o + g, h > r || l.newline ? (a += s + i, o = 0, h = g, s = d.width) : s = Math.max(s, d.width)
                }
                l.newline || (f[0] = a, f[1] = o, "horizontal" === t ? a = c + i : o = h + i)
            })
        }
        var i = t(de),
            n = t("zrender/core/BoundingRect"),
            r = t("./number"),
            o = t("./format"),
            s = r[a],
            l = i.each,
            u = {},
            h = u.LOCATION_PARAMS = ["left", "right", "top", ee, "width", ue];
        return u.box = e, u.vbox = i.curry(e, "vertical"), u.hbox = i.curry(e, "horizontal"), u.getAvailableSize = function (t, e, i) {
            var n = e.width,
                r = e[ue],
                a = s(t.x, n),
                l = s(t.y, r),
                u = s(t.x2, n),
                c = s(t.y2, r);
            return (isNaN(a) || isNaN(parseFloat(t.x))) && (a = 0), (isNaN(u) || isNaN(parseFloat(t.x2))) && (u = n), (isNaN(l) || isNaN(parseFloat(t.y))) && (l = 0), (isNaN(c) || isNaN(parseFloat(t.y2))) && (c = r), i = o.normalizeCssArray(i || 0), {
                width: Math.max(u - a - i[1] - i[3], 0),
                height: Math.max(c - l - i[0] - i[2], 0)
            }
        }, u.getLayoutRect = function (t, e, i) {
            i = o.normalizeCssArray(i || 0);
            var r = e.width,
                a = e[ue],
                l = s(t.left, r),
                u = s(t.top, a),
                c = s(t.right, r),
                h = s(t[ee], a),
                f = s(t.width, r),
                d = s(t[ue], a),
                p = i[2] + i[0],
                m = i[1] + i[3],
                v = t.aspect;
            switch (isNaN(f) && (f = r - c - m - l), isNaN(d) && (d = a - h - p - u), isNaN(f) && isNaN(d) && (v > r / a ? f = .8 * r : d = .8 * a), null != v && (isNaN(f) && (f = v * d), isNaN(d) && (d = f / v)), isNaN(l) && (l = r - c - f - m), isNaN(u) && (u = a - h - d - p), t.left || t.right) {
                case M:
                    l = r / 2 - f / 2 - i[3];
                    break;
                case "right":
                    l = r - f - m
            }
            switch (t.top || t[ee]) {
                case T:
                case M:
                    u = a / 2 - d / 2 - i[0];
                    break;
                case ee:
                    u = a - d - p
            }
            l = l || 0, u = u || 0, isNaN(f) && (f = r - l - (c || 0)), isNaN(d) && (d = a - u - (h || 0));
            var g = new n(l + i[3], u + i[0], f, d);
            return g.margin = i, g
        }, u.positionElement = function (t, e, r, a, o) {
            var s = !o || !o.hv || o.hv[0],
                l = !o || !o.hv || o.hv[1],
                h = o && o.boundingMode || "all";
            if (s || l) {
                var f;
                if ("raw" === h) f = "group" === t.type ? new n(0, 0, +e.width || 0, +e[ue] || 0) : t[S]();
                else if (f = t[S](), t.needLocalTransform()) {
                    var d = t.getLocalTransform();
                    f = f.clone(), f[c](d)
                }
                e = u.getLayoutRect(i[V]({
                    width: f.width,
                    height: f[ue]
                }, e), r, a);
                var p = t[w],
                    m = s ? e.x - f.x : 0,
                    v = l ? e.y - f.y : 0;
                t.attr(w, "raw" === h ? [m, v] : [p[0] + m, p[1] + v])
            }
        }, u.mergeLayoutParam = function (t, e, n) {
            function r(i) {
                var r = {},
                    s = 0,
                    u = {},
                    c = 0,
                    h = n.ignoreSize ? 1 : 2;
                if (l(i, function (e) {
                    u[e] = t[e]
                }), l(i, function (t) {
                    a(e, t) && (r[t] = u[t] = e[t]), o(r, t) && s++, o(u, t) && c++
                }), c !== h && s) {
                    if (s >= h) return r;
                    for (var f = 0; f < i[te]; f++) {
                        var d = i[f];
                        if (!a(r, d) && a(t, d)) {
                            r[d] = t[d];
                            break
                        }
                    }
                    return r
                }
                return u
            }

            function a(t, e) {
                return t.hasOwnProperty(e)
            }

            function o(t, e) {
                return null != t[e] && "auto" !== t[e]
            }

            function s(t, e, i) {
                l(t, function (t) {
                    e[t] = i[t]
                })
            } !i[oe](n) && (n = {});
            var u = ["width", "left", "right"],
                c = [ue, "top", ee],
                h = r(u),
                f = r(c);
            s(u, t, h), s(c, t, f)
        }, u.getLayoutParams = function (t) {
            return u.copyLayoutParams({}, t)
        }, u.copyLayoutParams = function (t, e) {
            return e && t && l(h, function (i) {
                e.hasOwnProperty(i) && (t[i] = e[i])
            }), t
        }, u
    }), e("echarts/component/legend/LegendModel", [me, de, "../../model/Model", "../../echarts"], function (t) {
        var e = t(de),
            i = t("../../model/Model"),
            n = t("../../echarts").extendComponentModel({
                type: "legend",
                dependencies: [W],
                layoutMode: {
                    type: "box",
                    ignoreSize: !0
                },
                init: function (t, e, i) {
                    this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}
                },
                mergeOption: function (t) {
                    n.superCall(this, "mergeOption", t)
                },
                optionUpdated: function () {
                    this._updateData(this[m]);
                    var t = this._data;
                    if (t[0] && "single" === this.get("selectedMode")) {
                        for (var e = !1, i = 0; i < t[te]; i++) {
                            var n = t[i].get("name");
                            if (this.isSelected(n)) {
                                this.select(n), e = !0;
                                break
                            }
                        } !e && this.select(t[0].get("name"))
                    }
                },
                _updateData: function (t) {
                    var n = e.map(this.get("data") || [], function (t) {
                        return (typeof t === ce || typeof t === k) && (t = {
                            name: t
                        }), new i(t, this, this[m])
                    }, this);
                    this._data = n;
                    var r = e.map(t.getSeries(), function (t) {
                        return t.name
                    });
                    t[Z](function (t) {
                        if (t.legendDataProvider) {
                            var e = t.legendDataProvider();
                            r = r[v](e.mapArray(e.getName))
                        }
                    }), this._availableNames = r
                },
                getData: function () {
                    return this._data
                },
                select: function (t) {
                    var i = this.option.selected,
                        n = this.get("selectedMode");
                    if ("single" === n) {
                        var r = this._data;
                        e.each(r, function (t) {
                            i[t.get("name")] = !1
                        })
                    }
                    i[t] = !0
                },
                unSelect: function (t) {
                    "single" !== this.get("selectedMode") && (this.option.selected[t] = !1)
                },
                toggleSelected: function (t) {
                    var e = this.option.selected;
                    e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t)
                },
                isSelected: function (t) {
                    var i = this.option.selected;
                    return !(i.hasOwnProperty(t) && !i[t]) && e[J](this._availableNames, t) >= 0
                },
                defaultOption: {
                    zlevel: 0,
                    z: 4,
                    show: !0,
                    orient: "horizontal",
                    left: "center",
                    top: "top",
                    align: "auto",
                    backgroundColor: "rgba(0,0,0,0)",
                    borderColor: "#ccc",
                    borderWidth: 0,
                    padding: 5,
                    itemGap: 10,
                    itemWidth: 25,
                    itemHeight: 14,
                    inactiveColor: "#ccc",
                    textStyle: {
                        color: "#333"
                    },
                    selectedMode: !0,
                    tooltip: {
                        show: !1
                    }
                }
            });
        return n
    }), e("echarts/component/legend/legendAction", [me, "../../echarts", de], function (t) {
        function e(t, e, i) {
            var r, a = {},
                o = "toggleSelected" === t;
            return i.eachComponent("legend", function (i) {
                o && null != r ? i[r ? "select" : "unSelect"](e.name) : (i[t](e.name), r = i.isSelected(e.name));
                var s = i[Q]();
                n.each(s, function (t) {
                    var e = t.get("name");
                    if ("\n" !== e && "" !== e) {
                        var n = i.isSelected(e);
                        a[e] = e in a ? a[e] && n : n
                    }
                })
            }), {
                name: e.name,
                selected: a
            }
        }
        var i = t("../../echarts"),
            n = t(de);
        i.registerAction("legendToggleSelect", "legendselectchanged", n.curry(e, "toggleSelected")), i.registerAction("legendSelect", "legendselected", n.curry(e, "select")), i.registerAction("legendUnSelect", "legendunselected", n.curry(e, "unSelect"))
    }), e("echarts/component/legend/LegendView", [me, de, "../../util/symbol", n, "../helper/listComponent", "../../echarts"], function (t) {
        function e(t, e) {
            e.dispatchAction({
                type: "legendToggleSelect",
                name: t
            })
        }

        function i(t, e, i) {
            var n = i.getZr().storage.getDisplayList()[0];
            n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({
                type: "highlight",
                seriesName: t.name,
                name: e
            })
        }

        function r(t, e, i) {
            var n = i.getZr().storage.getDisplayList()[0];
            n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({
                type: "downplay",
                seriesName: t.name,
                name: e
            })
        }
        var a = t(de),
            o = t("../../util/symbol"),
            s = t(n),
            l = t("../helper/listComponent"),
            u = a.curry;
        return t("../../echarts").extendComponentView({
            type: "legend",
            init: function () {
                this._symbolTypeStore = {}
            },
            render: function (t, n, o) {
                var c = this.group;
                if (c[P](), t.get("show")) {
                    var h = t.get("selectedMode"),
                        f = t.get("align");
                    "auto" === f && (f = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left");
                    var d = {};
                    a.each(t[Q](), function (a) {
                        var l = a.get("name");
                        if ("" === l || "\n" === l) return void c.add(new s.Group({
                            newline: !0
                        }));
                        var p = n.getSeriesByName(l)[0];
                        if (!d[l])
                            if (p) {
                                var m = p[Q](),
                                    v = m.getVisual("color");
                                typeof v === L && (v = v(p[E](0)));
                                var g = m.getVisual("legendSymbol") || "roundRect",
                                    y = m.getVisual("symbol"),
                                    _ = this._createItem(l, a, t, g, y, f, v, h);
                                _.on("click", u(e, l, o)).on("mouseover", u(i, p, null, o)).on(N, u(r, p, null, o)), d[l] = !0
                            } else n.eachRawSeries(function (n) {
                                if (!d[l] && n.legendDataProvider) {
                                    var s = n.legendDataProvider(),
                                        c = s.indexOfName(l);
                                    if (0 > c) return;
                                    var p = s[Y](c, "color"),
                                        m = "roundRect",
                                        v = this._createItem(l, a, t, m, null, f, p, h);
                                    v.on("click", u(e, l, o)).on("mouseover", u(i, n, l, o)).on(N, u(r, n, l, o)), d[l] = !0
                                }
                            }, this)
                    }, this), l.layout(c, t, o), l.addBackground(c, t)
                }
            },
            _createItem: function (t, e, i, n, r, l, u, c) {
                var h = i.get("itemWidth"),
                    f = i.get("itemHeight"),
                    d = i.get("inactiveColor"),
                    p = i.isSelected(t),
                    m = new s.Group,
                    v = e[ae](A),
                    g = e.get("icon"),
                    y = e[ae]("tooltip"),
                    _ = y.parentModel;
                if (n = g || n, m.add(o.createSymbol(n, 0, 0, h, f, p ? u : d)), !g && r && (r !== n || "none" == r)) {
                    var x = .8 * f;
                    "none" === r && (r = "circle"), m.add(o.createSymbol(r, (h - x) / 2, (f - x) / 2, x, x, p ? u : d))
                }
                var b = "left" === l ? h + 5 : -5,
                    w = l,
                    M = i.get("formatter"),
                    T = t;
                typeof M === ce && M ? T = M[I]("{name}", null != t ? t : "") : typeof M === L && (T = M(t));
                var P = new s.Text({
                    style: {
                        text: T,
                        x: b,
                        y: f / 2,
                        fill: p ? v.getTextColor() : d,
                        textFont: v[C](),
                        textAlign: w,
                        textVerticalAlign: "middle"
                    }
                });
                m.add(P);
                var k = new s.Rect({
                    shape: m[S](),
                    invisible: !0,
                    tooltip: y.get("show") ? a[H]({
                        content: t,
                        formatter: _.get("formatter", !0) || function () {
                            return t
                        },
                        formatterParams: {
                            componentType: "legend",
                            legendIndex: i.componentIndex,
                            name: t,
                            $vars: ["name"]
                        }
                    }, y.option) : null
                });
                return m.add(k), m.eachChild(function (t) {
                    t[se] = !0
                }), k[se] = !c, this.group.add(m), s.setHoverStyle(m), m
            }
        })
    }), e("echarts/component/legend/legendFilter", [], function () {
        return function (t) {
            var e = t.findComponents({
                mainType: "legend"
            });
            e && e[te] && t.filterSeries(function (t) {
                for (var i = 0; i < e[te]; i++)
                    if (!e[i].isSelected(t.name)) return !1;
                return !0
            })
        }
    }), e("echarts/component/tooltip/TooltipModel", [me, "../../echarts"], function (t) {
        t("../../echarts").extendComponentModel({
            type: "tooltip",
            defaultOption: {
                zlevel: 0,
                z: 8,
                show: !0,
                showContent: !0,
                trigger: "item",
                triggerOn: "mousemove",
                alwaysShowContent: !1,
                confine: !1,
                showDelay: 0,
                hideDelay: 100,
                transitionDuration: .4,
                enterable: !1,
                backgroundColor: "rgba(50,50,50,0.7)",
                borderColor: "#333",
                borderRadius: 4,
                borderWidth: 0,
                padding: 5,
                extraCssText: "",
                axisPointer: {
                    type: "line",
                    axis: "auto",
                    animation: !0,
                    animationDurationUpdate: 200,
                    animationEasingUpdate: "exponentialOut",
                    lineStyle: {
                        color: "#555",
                        width: 1,
                        type: "solid"
                    },
                    crossStyle: {
                        color: "#555",
                        width: 1,
                        type: "dashed",
                        textStyle: {}
                    },
                    shadowStyle: {
                        color: "rgba(150,150,150,0.3)"
                    }
                },
                textStyle: {
                    color: "#fff",
                    fontSize: 14
                }
            }
        })
    }), e("echarts/component/tooltip/TooltipView", [me, "./TooltipContent", n, de, "../../util/format", "../../util/number", "../../util/model", pe, "../../model/Model", "../../echarts"], function (t) {
        function e(t, e) {
            if (!t || !e) return !1;
            var i = k.round;
            return i(t[0]) === i(e[0]) && i(t[1]) === i(e[1])
        }

        function s(t, e, i, n) {
            return {
                x1: t,
                y1: e,
                x2: i,
                y2: n
            }
        }

        function l(t, e, i, n) {
            return {
                x: t,
                y: e,
                width: i,
                height: n
            }
        }

        function h(t, e, i, n, r, a) {
            return {
                cx: t,
                cy: e,
                r0: i,
                r: n,
                startAngle: r,
                endAngle: a,
                clockwise: !0
            }
        }

        function d(t, e, i, n, r) {
            var a = i.clientWidth,
                o = i.clientHeight,
                s = 20;
            return t + a + s > n ? t -= a + s : t += s, e + o + s > r ? e -= o + s : e += s, [t, e]
        }

        function p(t, e, i, n, r) {
            var a = i.clientWidth,
                o = i.clientHeight;
            return t = Math.min(t + a, n) - a, e = Math.min(e + o, r) - o, t = Math.max(t, 0), e = Math.max(e, 0), [t, e]
        }

        function v(t, e, i) {
            var n = i.clientWidth,
                r = i.clientHeight,
                a = 5,
                o = 0,
                s = 0,
                l = e.width,
                u = e[ue];
            switch (t) {
                case "inside":
                    o = e.x + l / 2 - n / 2, s = e.y + u / 2 - r / 2;
                    break;
                case "top":
                    o = e.x + l / 2 - n / 2, s = e.y - r - a;
                    break;
                case ee:
                    o = e.x + l / 2 - n / 2, s = e.y + u + a;
                    break;
                case "left":
                    o = e.x - n - a, s = e.y + u / 2 - r / 2;
                    break;
                case "right":
                    o = e.x + l + a, s = e.y + u / 2 - r / 2
            }
            return [o, s]
        }

        function g(t, e, n, r, a, o, s, l) {
            var u = l[re](),
                h = l[ne](),
                f = s && s[S]().clone();
            if (s && f[c](s.transform), typeof t === L && (t = t([e, n], o, a.el, f)), M[z](t)) e = B(t[0], u), n = B(t[1], h);
            else if (typeof t === ce && s) {
                var m = v(t, f, a.el);
                e = m[0], n = m[1]
            } else {
                var m = d(e, n, a.el, u, h);
                e = m[0], n = m[1]
            }
            if (r) {
                var m = p(e, n, a.el, u, h);
                e = m[0], n = m[1]
            }
            a[i](e, n)
        }

        function y(t) {
            var e = t[K],
                i = t.get("tooltip.trigger", !0);
            return !(!e || "cartesian2d" !== e.type && "polar" !== e.type && "singleAxis" !== e.type || "item" === i)
        }
        var x = t("./TooltipContent"),
            b = t(n),
            M = t(de),
            T = t("../../util/format"),
            k = t("../../util/number"),
            I = t("../../util/model"),
            B = k[a],
            F = t(pe),
            V = t("../../model/Model");
        t("../../echarts").extendComponentView({
            type: "tooltip",
            _axisPointers: {},
            init: function (t, e) {
                if (!F.node) {
                    var i = new x(e.getDom(), e);
                    this._tooltipContent = i
                }
            },
            render: function (t, e, i) {
                if (!F.node) {
                    this.group[P](), this._axisPointers = {}, this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastHover = {};
                    var n = this._tooltipContent;
                    n[U](), n.enterable = t.get("enterable"), this._alwaysShowContent = t.get("alwaysShowContent"), this._seriesGroupByAxis = this._prepareAxisTriggerData(t, e);
                    var r = this._crossText;
                    r && this.group.add(r);
                    var a = t.get("triggerOn");
                    if (null != this._lastX && null != this._lastY && "none" !== a) {
                        var o = this;
                        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () {
                            o.manuallyShowTip(t, e, i, {
                                x: o._lastX,
                                y: o._lastY
                            })
                        })
                    }
                    var s = this._api.getZr();
                    s.off("click", this._tryShow), s.off("mousemove", this._mousemove), s.off(N, this._hide), s.off("globalout", this._hide), "click" === a ? s.on("click", this._tryShow, this) : "mousemove" === a && (s.on("mousemove", this._mousemove, this), s.on(N, this._hide, this), s.on("globalout", this._hide, this))
                }
            },
            _mousemove: function (t) {
                var e = this._tooltipModel.get("showDelay"),
                    i = this;
                clearTimeout(this._showTimeout), e > 0 ? this._showTimeout = setTimeout(function () {
                    i._tryShow(t)
                }, e) : this._tryShow(t)
            },
            manuallyShowTip: function (t, e, i, n) {
                function a(t) {
                    var e = t[Q](),
                        i = I.queryDataIndex(e, n);
                    return null != i && !M[z](i) && e.hasValue(i) ? !0 : void 0
                }
                if (n.from !== this.uid) {
                    var e = this._ecModel,
                        o = n[R],
                        s = e.getSeriesByIndex(o),
                        i = this._api,
                        l = "axis" === this._tooltipModel.get(G);
                    if (null == n.x || null == n.y) {
                        if (l ? (s && !a(s) && (s = null), s || e[Z](function (t) {
                            y(t) && !s && a(t) && (s = t)
                        })) : s = s || e.getSeriesByIndex(0), s) {
                            var u = s[Q](),
                                h = I.queryDataIndex(u, n);
                            if (null == h || M[z](h)) return;
                            var d, p, m = u[f](h),
                                v = s[K];
                            if (s.getTooltipPosition) {
                                var g = s.getTooltipPosition(h) || [];
                                d = g[0], p = g[1]
                            } else if (v && v[r]) {
                                var g = v[r](u.getValues(M.map(v.dimensions, function (t) {
                                    return s.coordDimToDataDim(t)[0]
                                }), h, !0));
                                d = g && g[0], p = g && g[1]
                            } else if (m) {
                                var _ = m[S]().clone();
                                _[c](m.transform), d = _.x + _.width / 2, p = _.y + _[ue] / 2
                            }
                            null != d && null != p && this._tryShow({
                                offsetX: d,
                                offsetY: p,
                                position: n[w],
                                target: m,
                                event: {}
                            })
                        }
                    } else {
                        var m = i.getZr().handler.findHover(n.x, n.y);
                        this._tryShow({
                            offsetX: n.x,
                            offsetY: n.y,
                            position: n[w],
                            target: m,
                            event: {}
                        })
                    }
                }
            },
            manuallyHideTip: function (t, e, i, n) {
                n.from !== this.uid && this._hide()
            },
            _prepareAxisTriggerData: function (t, e) {
                var i = {};
                return e[Z](function (t) {
                    if (y(t)) {
                        var e, n, r = t[K];
                        "cartesian2d" === r.type ? (e = r.getBaseAxis(), n = e.dim + e.index) : "singleAxis" === r.type ? (e = r.getAxis(), n = e.dim + e.type) : (e = r.getBaseAxis(), n = e.dim + r.name), i[n] = i[n] || {
                            coordSys: [],
                            series: []
                        }, i[n].coordSys.push(r), i[n][W].push(t)
                    }
                }, this), i
            },
            _tryShow: function (t) {
                var e = t.target,
                    i = this._tooltipModel,
                    n = i.get(G),
                    r = this._ecModel,
                    a = this._api;
                if (i)
                    if (this._lastX = t.offsetX, this._lastY = t.offsetY, e && null != e[$]) {
                        var s = e.dataModel || r.getSeriesByIndex(e[R]),
                            l = e[$],
                            u = s[Q](),
                            c = u[o](l);
                        "axis" === (c.get("tooltip.trigger") || n) ? this._showAxisTooltip(i, r, t) : (this._ticket = "", this._hideAxisPointer(), this._resetLastHover(), this._showItemTooltipContent(s, l, e.dataType, t)), a.dispatchAction({
                            type: "showTip",
                            from: this.uid,
                            dataIndexInside: l,
                            dataIndex: u.getRawIndex(l),
                            seriesIndex: e[R]
                        })
                    } else if (e && e.tooltip) {
                        var h = e.tooltip;
                        if (typeof h === ce) {
                            var f = h;
                            h = {
                                content: f,
                                formatter: f
                            }
                        }
                        var d = new V(h, i),
                            p = d.get("content"),
                            m = Math.random();
                        this._showTooltipContent(d, p, d.get("formatterParams") || {}, m, t.offsetX, t.offsetY, t[w], e, a)
                    } else "item" === n ? this._hide() : this._showAxisTooltip(i, r, t), "cross" === i.get("axisPointer.type") && a.dispatchAction({
                        type: "showTip",
                        from: this.uid,
                        x: t.offsetX,
                        y: t.offsetY
                    })
            },
            _showAxisTooltip: function (t, i, n) {
                var a = t[ae]("axisPointer"),
                    o = a.get("type");
                if ("cross" === o) {
                    var s = n.target;
                    if (s && null != s[$]) {
                        var l = i.getSeriesByIndex(s[R]),
                            u = s[$];
                        this._showItemTooltipContent(l, u, s.dataType, n)
                    }
                }
                this._showAxisPointer();
                var c = !0;
                M.each(this._seriesGroupByAxis, function (i) {
                    var s = i.coordSys,
                        l = s[0],
                        u = [n.offsetX, n.offsetY];
                    if (!l.containPoint(u)) return void this._hideAxisPointer(l.name);
                    c = !1;
                    var h = l.dimensions,
                        f = l.pointToData(u, !0);
                    u = l[r](f);
                    var d = l.getBaseAxis(),
                        p = a.get("axis");
                    if ("auto" === p && (p = d.dim), d.isBlank() || M.eqNaN(u[0]) || M.eqNaN(u[1])) return void this._hideAxisPointer(l.name);
                    var m = !1,
                        v = this._lastHover;
                    if ("cross" === o) e(v.data, f) && (m = !0), v.data = f;
                    else {
                        var g = M[J](h, p);
                        v.data === f[g] && (m = !0), v.data = f[g]
                    }
                    var y = t.get(le);
                    "cartesian2d" !== l.type || m ? "polar" !== l.type || m ? "singleAxis" !== l.type || m || this._showSinglePointer(a, l, p, u, y) : this._showPolarPointer(a, l, p, u, y) : this._showCartesianPointer(a, l, p, u, y), "cross" !== o && this._dispatchAndShowSeriesTooltipContent(l, i[W], u, f, m, n[w])
                }, this), this._tooltipModel.get("show") || this._hideAxisPointer(), c && this._hide()
            },
            _showCartesianPointer: function (t, e, i, n, r) {
                function a(i, n, r) {
                    var a = "x" === i ? s(n[0], r[0], n[0], r[1]) : s(r[0], n[1], r[1], n[1]),
                        o = u._getPointerElement(e, t, i, a);
                    b.subPixelOptimizeLine({
                        shape: a,
                        style: o.style
                    }), f ? b.updateProps(o, {
                        shape: a
                    }, t) : o.attr({
                        shape: a
                    })
                }

                function o(i, n, r) {
                    var a = e.getAxis(i),
                        o = a.getBandWidth(),
                        s = r[1] - r[0],
                        c = "x" === i ? l(n[0] - o / 2, r[0], o, s) : l(r[0], n[1] - o / 2, s, o),
                        h = u._getPointerElement(e, t, i, c);
                    f ? b.updateProps(h, {
                        shape: c
                    }, t) : h.attr({
                        shape: c
                    })
                }
                var u = this,
                    c = t.get("type"),
                    h = e.getBaseAxis(),
                    f = r && "cross" !== c && "category" === h.type && h.getBandWidth() > 20;
                if ("cross" === c) a("x", n, e.getAxis("y").getGlobalExtent()), a("y", n, e.getAxis("x").getGlobalExtent()), this._updateCrossText(e, n, t);
                else {
                    var d = e.getAxis("x" === i ? "y" : "x"),
                        p = d.getGlobalExtent();
                    "cartesian2d" === e.type && ("line" === c ? a : o)(i, n, p)
                }
            },
            _showSinglePointer: function (t, e, i, n, r) {
                function a(i, n, r) {
                    var a = e.getAxis(),
                        l = a.orient,
                        c = "horizontal" === l ? s(n[0], r[0], n[0], r[1]) : s(r[0], n[1], r[1], n[1]),
                        h = o._getPointerElement(e, t, i, c);
                    u ? b.updateProps(h, {
                        shape: c
                    }, t) : h.attr({
                        shape: c
                    })
                }
                var o = this,
                    l = t.get("type"),
                    u = r && "cross" !== l && "category" === e.getBaseAxis().type,
                    c = e.getRect(),
                    h = [c.y, c.y + c[ue]];
                a(i, n, h)
            },
            _showPolarPointer: function (t, e, i, n, r) {
                function a(i, n, r) {
                    var a, o = e.pointToCoord(n);
                    if ("angle" === i) {
                        var u = e.coordToPoint([r[0], o[1]]),
                            c = e.coordToPoint([r[1], o[1]]);
                        a = s(u[0], u[1], c[0], c[1])
                    } else a = {
                        cx: e.cx,
                        cy: e.cy,
                        r: o[0]
                    };
                    var h = l._getPointerElement(e, t, i, a);
                    d ? b.updateProps(h, {
                        shape: a
                    }, t) : h.attr({
                        shape: a
                    })
                }

                function o(i, n, r) {
                    var a, o = e.getAxis(i),
                        s = o.getBandWidth(),
                        u = e.pointToCoord(n),
                        c = Math.PI / 180;
                    a = "angle" === i ? h(e.cx, e.cy, r[0], r[1], (-u[1] - s / 2) * c, (-u[1] + s / 2) * c) : h(e.cx, e.cy, u[0] - s / 2, u[0] + s / 2, 0, 2 * Math.PI);
                    var f = l._getPointerElement(e, t, i, a);
                    d ? b.updateProps(f, {
                        shape: a
                    }, t) : f.attr({
                        shape: a
                    })
                }
                var l = this,
                    u = t.get("type"),
                    c = e.getAngleAxis(),
                    f = e.getRadiusAxis(),
                    d = r && "cross" !== u && "category" === e.getBaseAxis().type;
                if ("cross" === u) a("angle", n, f[_]()), a("radius", n, c[_]()), this._updateCrossText(e, n, t);
                else {
                    var p = e.getAxis("radius" === i ? "angle" : "radius"),
                        m = p[_]();
                    ("line" === u ? a : o)(i, n, m)
                }
            },
            _updateCrossText: function (t, e, i) {
                var n = i[ae]("crossStyle"),
                    r = n[ae](A),
                    a = this._tooltipModel,
                    o = this._crossText;
                o || (o = this._crossText = new b.Text({
                    style: {
                        textAlign: "left",
                        textVerticalAlign: "bottom"
                    }
                }), this.group.add(o));
                var s = t.pointToData(e),
                    l = t.dimensions;
                s = M.map(s, function (e, i) {
                    var n = t.getAxis(l[i]);
                    return e = "category" === n.type || "time" === n.type ? n.scale.getLabel(e) : T.addCommas(e.toFixed(n.getPixelPrecision()))
                }), o[O]({
                    fill: r.getTextColor() || n.get("color"),
                    textFont: r[C](),
                    text: s.join(", "),
                    x: e[0] + 5,
                    y: e[1] - 5
                }), o.z = a.get("z"), o[D] = a.get(D)
            },
            _getPointerElement: function (t, e, i, n) {
                var r = this._tooltipModel,
                    a = r.get("z"),
                    o = r.get(D),
                    s = this._axisPointers,
                    l = t.name;
                if (s[l] = s[l] || {}, s[l][i]) return s[l][i];
                var c = e.get("type"),
                    h = e[ae](c + "Style"),
                    f = "shadow" === c,
                    d = h[f ? "getAreaStyle" : "getLineStyle"](),
                    p = "polar" === t.type ? f ? "Sector" : "radius" === i ? "Circle" : "Line" : f ? "Rect" : "Line";
                f ? d[u] = null : d.fill = null;
                var m = s[l][i] = new b[p]({
                    style: d,
                    z: a,
                    zlevel: o,
                    silent: !0,
                    shape: n
                });
                return this.group.add(m), m
            },
            _dispatchAndShowSeriesTooltipContent: function (t, e, i, n, r, a) {
                var o = this._tooltipModel,
                    s = t.getBaseAxis(),
                    l = {
                        x: 1,
                        radius: 1,
                        single: 1
                    }[s.dim] ? 0 : 1;
                if (e[te]) {
                    var u, c = M.map(e, function (t) {
                        return {
                            seriesIndex: t[R],
                            dataIndexInside: t.getAxisTooltipDataIndex ? t.getAxisTooltipDataIndex(t.coordDimToDataDim(s.dim), n, s) : t[Q]().indexOfNearest(t.coordDimToDataDim(s.dim)[0], n[l], !1, "category" === s.type ? .5 : null)
                        }
                    });
                    M.each(c, function (t, i) {
                        e[i][Q]().hasValue(t.dataIndexInside) && (u = i)
                    }), u = u || 0;
                    var h = this._lastHover,
                        f = this._api;
                    h.payloadBatch && !r && f.dispatchAction({
                        type: "downplay",
                        batch: h.payloadBatch
                    }), r || (f.dispatchAction({
                        type: "highlight",
                        batch: c
                    }), h.payloadBatch = c);
                    var d = c[u].dataIndexInside;
                    if (f.dispatchAction({
                        type: "showTip",
                        dataIndexInside: d,
                        dataIndex: e[u][Q]().getRawIndex(d),
                        seriesIndex: c[u][R],
                        from: this.uid
                    }), s && o.get("showContent") && o.get("show")) {
                        var p = M.map(e, function (t, e) {
                            return t[E](c[e].dataIndexInside)
                        });
                        if (r) g(a || o.get(w), i[0], i[1], o.get("confine"), this._tooltipContent, p, null, f);
                        else {
                            var m = c[u].dataIndexInside,
                                v = "time" === s.type ? s.scale.getLabel(n[l]) : e[u][Q]().getName(m),
                                y = (v ? T.encodeHTML(v) + "<br />" : "") + M.map(e, function (t, e) {
                                    return t.formatTooltip(c[e].dataIndexInside, !0)
                                }).join("<br />"),
                                _ = "axis_" + t.name + "_" + m;
                            this._showTooltipContent(o, y, p, _, i[0], i[1], a, null, f)
                        }
                    }
                }
            },
            _showItemTooltipContent: function (t, e, i, n) {
                var r = this._api,
                    a = t[Q](i),
                    s = a[o](e),
                    l = s.get("tooltip", !0);
                if (typeof l === ce) {
                    var u = l;
                    l = {
                        formatter: u
                    }
                }
                var c = this._tooltipModel,
                    h = t[ae]("tooltip", c),
                    f = new V(l, h, h[m]),
                    d = t[E](e, i),
                    p = t.formatTooltip(e, !1, i),
                    v = "item_" + t.name + "_" + e;
                this._showTooltipContent(f, p, d, v, n.offsetX, n.offsetY, n[w], n.target, r)
            },
            _showTooltipContent: function (t, e, i, n, r, a, o, s, l) {
                if (this._ticket = "", t.get("showContent") && t.get("show")) {
                    var u = this._tooltipContent,
                        c = t.get("confine"),
                        h = t.get("formatter");
                    o = o || t.get(w);
                    var f = e;
                    if (h)
                        if (typeof h === ce) f = T.formatTpl(h, i, !0);
                        else if (typeof h === L) {
                            var d = this,
                                p = n,
                                m = function (t, e) {
                                    t === d._ticket && (u.setContent(e), g(o, r, a, c, u, i, s, l))
                                };
                            d._ticket = p, f = h(i, p, m)
                        }
                    u.show(t), u.setContent(f), g(o, r, a, c, u, i, s, l)
                }
            },
            _showAxisPointer: function (t) {
                if (t) {
                    var e = this._axisPointers[t];
                    e && M.each(e, function (t) {
                        t.show()
                    })
                } else this.group.eachChild(function (t) {
                    t.show()
                }), this.group.show()
            },
            _resetLastHover: function () {
                var t = this._lastHover;
                t.payloadBatch && this._api.dispatchAction({
                    type: "downplay",
                    batch: t.payloadBatch
                }), this._lastHover = {}
            },
            _hideAxisPointer: function (t) {
                if (t) {
                    var e = this._axisPointers[t];
                    e && M.each(e, function (t) {
                        t.hide()
                    })
                } else this.group.children()[te] && this.group.hide()
            },
            _hide: function () {
                clearTimeout(this._showTimeout), this._hideAxisPointer(), this._resetLastHover(), this._alwaysShowContent || this._tooltipContent.hideLater(this._tooltipModel.get("hideDelay")), this._api.dispatchAction({
                    type: "hideTip",
                    from: this.uid
                }), this._lastX = this._lastY = null
            },
            dispose: function (t, e) {
                if (!F.node) {
                    var i = e.getZr();
                    this._tooltipContent.hide(), i.off("click", this._tryShow), i.off("mousemove", this._mousemove), i.off(N, this._hide), i.off("globalout", this._hide)
                }
            }
        })
    }), e("echarts/component/marker/MarkPointModel", [me, "./MarkerModel"], function (t) {
        return t("./MarkerModel")[H]({
            type: "markPoint",
            defaultOption: {
                zlevel: 0,
                z: 5,
                symbol: "pin",
                symbolSize: 50,
                tooltip: {
                    trigger: "item"
                },
                label: {
                    normal: {
                        show: !0,
                        position: "inside"
                    },
                    emphasis: {
                        show: !0
                    }
                },
                itemStyle: {
                    normal: {
                        borderWidth: 2
                    }
                }
            }
        })
    }), e("echarts/component/marker/MarkPointView", [me, "../../chart/helper/SymbolDraw", de, "../../util/number", "../../data/List", "./markerHelper", "./MarkerView"], function (t) {
        function e(t, e, i) {
            var n = e[K];
            t.each(function (s) {
                var u, c = t[o](s),
                    h = l[a](c.get("x"), i[re]()),
                    f = l[a](c.get("y"), i[ne]());
                if (isNaN(h) || isNaN(f)) {
                    if (e.getMarkerPosition) u = e.getMarkerPosition(t.getValues(t.dimensions, s));
                    else if (n) {
                        var d = t.get(n.dimensions[0], s),
                            p = t.get(n.dimensions[1], s);
                        u = n[r]([d, p])
                    }
                } else u = [h, f];
                isNaN(h) || (u[0] = h), isNaN(f) || (u[1] = f), t.setItemLayout(s, u)
            })
        }

        function i(t, e, i) {
            var n;
            n = t ? s.map(t && t.dimensions, function (t) {
                var i = e[Q]().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};
                return i.name = t, i
            }) : [{
                name: "value",
                type: "float"
            }];
            var r = new u(n, i),
                a = s.map(i.get("data"), s.curry(c.dataTransform, e));
            return t && (a = s.filter(a, s.curry(c.dataFilter, t))), r.initData(a, null, t ? c.dimValueGetter : function (t) {
                return t.value
            }), r
        }
        var n = t("../../chart/helper/SymbolDraw"),
            s = t(de),
            l = t("../../util/number"),
            u = t("../../data/List"),
            c = t("./markerHelper");
        t("./MarkerView")[H]({
            type: "markPoint",
            updateLayout: function (t, i, n) {
                i[Z](function (t) {
                    var i = t.markPointModel;
                    i && (e(i[Q](), t, n), this.markerGroupMap[t.name].updateLayout(i))
                }, this)
            },
            renderSeries: function (t, r, a, s) {
                var l = t[K],
                    u = t.name,
                    c = t[Q](),
                    f = this.markerGroupMap,
                    p = f[u];
                p || (p = f[u] = new n);
                var m = i(l, t, r);
                r.setData(m), e(r[Q](), t, s), m.each(function (t) {
                    var e = m[o](t),
                        i = e[d]("symbolSize");
                    typeof i === L && (i = i(r.getRawValue(t), r[E](t))), m.setItemVisual(t, {
                        symbolSize: i,
                        color: e.get("itemStyle.normal.color") || c.getVisual("color"),
                        symbol: e[d]("symbol")
                    })
                }), p.updateData(m), this.group.add(p.group), m[h](function (t) {
                    t[B](function (t) {
                        t.dataModel = r
                    })
                }), p.__keep = !0, p.group[se] = r.get(se) || t.get(se)
            }
        })
    }), e("echarts/scale/Interval", [me, "../util/number", "../util/format", "./Scale"], function (t) {
        var e = t("../util/number"),
            i = t("../util/format"),
            n = t("./Scale"),
            r = Math.floor,
            a = Math.ceil,
            o = e.getPrecisionSafe,
            s = e.round,
            l = n[H]({
                type: "interval",
                _interval: 0,
                setExtent: function (t, e) {
                    var i = this._extent;
                    isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e))
                },
                unionExtent: function (t) {
                    var e = this._extent;
                    t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), l[he].setExtent.call(this, e[0], e[1])
                },
                getInterval: function () {
                    return this._interval || this.niceTicks(), this._interval
                },
                setInterval: function (t) {
                    this._interval = t, this._niceExtent = this._extent.slice()
                },
                getTicks: function () {
                    this._interval || this.niceTicks();
                    var t = this._interval,
                        e = this._extent,
                        i = [],
                        n = 1e4;
                    if (t) {
                        var r = this._niceExtent,
                            a = o(t) + 2;
                        e[0] < r[0] && i.push(e[0]);
                        for (var l = r[0]; l <= r[1];)
                            if (i.push(l), l = s(l + t, a), i[te] > n) return [];
                        e[1] > (i[te] ? i[i[te] - 1] : r[1]) && i.push(e[1])
                    }
                    return i
                },
                getTicksLabels: function () {
                    for (var t = [], e = this[y](), i = 0; i < e[te]; i++) t.push(this.getLabel(e[i]));
                    return t
                },
                getLabel: function (t) {
                    return i.addCommas(t)
                },
                niceTicks: function (t) {
                    t = t || 5;
                    var i = this._extent,
                        n = i[1] - i[0];
                    if (isFinite(n)) {
                        0 > n && (n = -n, i.reverse());
                        var l = s(e.nice(n / t, !0), Math.max(o(i[0]), o(i[1])) + 2),
                            u = o(l) + 2,
                            c = [s(a(i[0] / l) * l, u), s(r(i[1] / l) * l, u)];
                        this._interval = l, this._niceExtent = c
                    }
                },
                niceExtent: function (t, e, i) {
                    var n = this._extent;
                    if (n[0] === n[1])
                        if (0 !== n[0]) {
                            var o = n[0];
                            i ? n[0] -= o / 2 : (n[1] += o / 2, n[0] -= o / 2)
                        } else n[1] = 1;
                    var l = n[1] - n[0];
                    isFinite(l) || (n[0] = 0, n[1] = 1), this.niceTicks(t);
                    var u = this._interval;
                    e || (n[0] = s(r(n[0] / u) * u)), i || (n[1] = s(a(n[1] / u) * u))
                }
            });
        return l[X] = function () {
            return new l
        }, l
    }), e("echarts/scale/Scale", [me, "../util/clazz"], function (t) {
        function e() {
            this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments)
        }
        var i = t("../util/clazz"),
            n = e[he];
        return n.parse = function (t) {
            return t
        }, n[x] = function (t) {
            var e = this._extent;
            return t >= e[0] && t <= e[1]
        }, n.normalize = function (t) {
            var e = this._extent;
            return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
        }, n.scale = function (t) {
            var e = this._extent;
            return t * (e[1] - e[0]) + e[0]
        }, n.unionExtent = function (t) {
            var e = this._extent;
            t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
        }, n.unionExtentFromData = function (t, e) {
            this.unionExtent(t.getDataExtent(e, !0))
        }, n[_] = function () {
            return this._extent.slice()
        }, n.setExtent = function (t, e) {
            var i = this._extent;
            isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e)
        }, n.getTicksLabels = function () {
            for (var t = [], e = this[y](), i = 0; i < e[te]; i++) t.push(this.getLabel(e[i]));
            return t
        }, i.enableClassExtend(e), i.enableClassManagement(e, {
            registerWhenExtend: !0
        }), e
    }), e("echarts/model/globalDefault", [], function () {
        var t = "";
        return typeof navigator !== g && (t = navigator.platform || ""), {
            color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
            textStyle: {
                fontFamily: t.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
                fontSize: 12,
                fontStyle: "normal",
                fontWeight: "normal"
            },
            blendMode: null,
            animation: !0,
            animationDuration: 1e3,
            animationDurationUpdate: 300,
            animationEasing: "exponentialOut",
            animationEasingUpdate: "cubicOut",
            animationThreshold: 2e3,
            progressiveThreshold: 3e3,
            progressive: 400,
            hoverLayerThreshold: 3e3
        }
    }), e("echarts/model/mixin/colorPalette", [me, "../../util/clazz"], function (t) {
        var e = t("../../util/clazz"),
            i = e.set,
            n = e.get;
        return {
            clearColorPalette: function () {
                i(this, "colorIdx", 0), i(this, "colorNameMap", {})
            },
            getColorFromPalette: function (t, e) {
                e = e || this;
                var r = n(e, "colorIdx") || 0,
                    a = n(e, "colorNameMap") || i(e, "colorNameMap", {});
                if (a[t]) return a[t];
                var o = this.get("color", !0) || [];
                if (o[te]) {
                    var s = o[r];
                    return t && (a[t] = s), i(e, "colorIdx", (r + 1) % o[te]), s
                }
            }
        }
    }), e("zrender/tool/path", [me, "../graphic/Path", "../core/PathProxy", "./transformPath", "../core/matrix"], function (t) {
        function e(t, e, i, n, r, a, o, s, l, c, p) {
            var g = l * (d / 180),
                y = f(g) * (t - i) / 2 + h(g) * (e - n) / 2,
                _ = -1 * h(g) * (t - i) / 2 + f(g) * (e - n) / 2,
                x = y * y / (o * o) + _ * _ / (s * s);
            x > 1 && (o *= u(x), s *= u(x));
            var b = (r === a ? -1 : 1) * u((o * o * s * s - o * o * _ * _ - s * s * y * y) / (o * o * _ * _ + s * s * y * y)) || 0,
                w = b * o * _ / s,
                M = b * -s * y / o,
                T = (t + i) / 2 + f(g) * w - h(g) * M,
                S = (e + n) / 2 + h(g) * w + f(g) * M,
                C = v([1, 0], [(y - w) / o, (_ - M) / s]),
                A = [(y - w) / o, (_ - M) / s],
                P = [(-1 * y - w) / o, (-1 * _ - M) / s],
                k = v(A, P);
            m(A, P) <= -1 && (k = d), m(A, P) >= 1 && (k = 0), 0 === a && k > 0 && (k -= 2 * d), 1 === a && 0 > k && (k += 2 * d), p.addData(c, T, S, o, s, C, k, g, a)
        }

        function i(t) {
            if (!t) return [];
            var i, n = t[I](/-/g, " -")[I](/  /g, " ")[I](/ /g, ",")[I](/,,/g, ",");
            for (i = 0; i < l[te]; i++) n = n[I](new RegExp(l[i], "g"), "|" + l[i]);
            var r, o = n.split("|"),
                s = 0,
                u = 0,
                c = new a,
                h = a.CMD;
            for (i = 1; i < o[te]; i++) {
                var f, d = o[i],
                    p = d.charAt(0),
                    m = 0,
                    v = d.slice(1)[I](/e,-/g, "e-").split(",");
                v[te] > 0 && "" === v[0] && v.shift();
                for (var g = 0; g < v[te]; g++) v[g] = parseFloat(v[g]);
                for (; m < v[te] && !isNaN(v[m]) && !isNaN(v[0]);) {
                    var y, _, x, b, w, M, T, S = s,
                        C = u;
                    switch (p) {
                        case "l":
                            s += v[m++], u += v[m++], f = h.L, c.addData(f, s, u);
                            break;
                        case "L":
                            s = v[m++], u = v[m++], f = h.L, c.addData(f, s, u);
                            break;
                        case "m":
                            s += v[m++], u += v[m++], f = h.M, c.addData(f, s, u), p = "l";
                            break;
                        case "M":
                            s = v[m++], u = v[m++], f = h.M, c.addData(f, s, u), p = "L";
                            break;
                        case "h":
                            s += v[m++], f = h.L, c.addData(f, s, u);
                            break;
                        case "H":
                            s = v[m++], f = h.L, c.addData(f, s, u);
                            break;
                        case "v":
                            u += v[m++], f = h.L, c.addData(f, s, u);
                            break;
                        case "V":
                            u = v[m++], f = h.L, c.addData(f, s, u);
                            break;
                        case "C":
                            f = h.C, c.addData(f, v[m++], v[m++], v[m++], v[m++], v[m++], v[m++]), s = v[m - 2], u = v[m - 1];
                            break;
                        case "c":
                            f = h.C, c.addData(f, v[m++] + s, v[m++] + u, v[m++] + s, v[m++] + u, v[m++] + s, v[m++] + u), s += v[m - 2], u += v[m - 1];
                            break;
                        case "S":
                            y = s, _ = u;
                            var A = c.len(),
                                P = c.data;
                            r === h.C && (y += s - P[A - 4], _ += u - P[A - 3]), f = h.C, S = v[m++], C = v[m++], s = v[m++], u = v[m++], c.addData(f, y, _, S, C, s, u);
                            break;
                        case "s":
                            y = s, _ = u;
                            var A = c.len(),
                                P = c.data;
                            r === h.C && (y += s - P[A - 4], _ += u - P[A - 3]), f = h.C, S = s + v[m++], C = u + v[m++], s += v[m++], u += v[m++], c.addData(f, y, _, S, C, s, u);
                            break;
                        case "Q":
                            S = v[m++], C = v[m++], s = v[m++], u = v[m++], f = h.Q, c.addData(f, S, C, s, u);
                            break;
                        case "q":
                            S = v[m++] + s, C = v[m++] + u, s += v[m++], u += v[m++], f = h.Q, c.addData(f, S, C, s, u);
                            break;
                        case "T":
                            y = s, _ = u;
                            var A = c.len(),
                                P = c.data;
                            r === h.Q && (y += s - P[A - 4], _ += u - P[A - 3]), s = v[m++], u = v[m++], f = h.Q, c.addData(f, y, _, s, u);
                            break;
                        case "t":
                            y = s, _ = u;
                            var A = c.len(),
                                P = c.data;
                            r === h.Q && (y += s - P[A - 4], _ += u - P[A - 3]), s += v[m++], u += v[m++], f = h.Q, c.addData(f, y, _, s, u);
                            break;
                        case "A":
                            x = v[m++], b = v[m++], w = v[m++], M = v[m++], T = v[m++], S = s, C = u, s = v[m++], u = v[m++], f = h.A, e(S, C, s, u, M, T, x, b, w, f, c);
                            break;
                        case "a":
                            x = v[m++], b = v[m++], w = v[m++], M = v[m++], T = v[m++], S = s, C = u, s += v[m++], u += v[m++], f = h.A, e(S, C, s, u, M, T, x, b, w, f, c)
                    }
                } ("z" === p || "Z" === p) && (f = h.Z, c.addData(f)), r = f
            }
            return c.toStatic(), c
        }

        function n(t, e) {
            var n, r = i(t);
            return e = e || {}, e.buildPath = function (t) {
                t.setData(r.data), n && o(t, n);
                var e = t.getContext();
                e && t.rebuildPath(e)
            }, e[c] = function (t) {
                n || (n = s[X]()), s.mul(n, t, n), this.dirty(!0)
            }, e
        }
        var r = t("../graphic/Path"),
            a = t("../core/PathProxy"),
            o = t("./transformPath"),
            s = t("../core/matrix"),
            l = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"],
            u = Math.sqrt,
            h = Math.sin,
            f = Math.cos,
            d = Math.PI,
            p = function (t) {
                return Math.sqrt(t[0] * t[0] + t[1] * t[1])
            },
            m = function (t, e) {
                return (t[0] * e[0] + t[1] * e[1]) / (p(t) * p(e))
            },
            v = function (t, e) {
                return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(m(t, e))
            };
        return {
            createFromString: function (t, e) {
                return new r(n(t, e))
            },
            extendFromString: function (t, e) {
                return r[H](n(t, e))
            },
            mergePath: function (t, e) {
                for (var i = [], n = t[te], a = 0; n > a; a++) {
                    var o = t[a];
                    o.__dirty && o.buildPath(o.path, o.shape, !0), i.push(o.path)
                }
                var s = new r(e);
                return s.buildPath = function (t) {
                    t.appendPath(i);
                    var e = t.getContext();
                    e && t.rebuildPath(e)
                }, s
            }
        }
    }), e("zrender/graphic/Path", [me, "./Displayable", "../core/util", "../core/PathProxy", "../contain/path", "./Pattern"], function (t) {
        function e(t) {
            i.call(this, t), this.path = new r
        }
        var i = t("./Displayable"),
            n = t("../core/util"),
            r = t("../core/PathProxy"),
            a = t("../contain/path"),
            o = t("./Pattern"),
            s = o[he].getCanvasPattern,
            l = Math.abs;
        return e[he] = {
            constructor: e,
            type: "path",
            __dirtyPath: !0,
            strokeContainThreshold: 5,
            brush: function (t, e) {
                var i = this.style,
                    n = this.path,
                    r = i.hasStroke(),
                    a = i.hasFill(),
                    o = i.fill,
                    l = i[u],
                    c = a && !!o[j],
                    h = r && !!l[j],
                    f = a && !!o.image,
                    d = r && !!l.image;
                if (i.bind(t, this, e), this.setTransform(t), this.__dirty) {
                    var p = this[S]();
                    c && (this._fillGradient = i.getGradient(t, o, p)), h && (this._strokeGradient = i.getGradient(t, l, p))
                }
                c ? t.fillStyle = this._fillGradient : f && (t.fillStyle = s.call(o, t)), h ? t.strokeStyle = this._strokeGradient : d && (t.strokeStyle = s.call(l, t));
                var m = i.lineDash,
                    v = i.lineDashOffset,
                    g = !!t.setLineDash,
                    y = this.getGlobalScale();
                n.setScale(y[0], y[1]), this.__dirtyPath || m && !g && r ? (n = this.path.beginPath(t), m && !g && (n.setLineDash(m), n.setLineDashOffset(v)), this.buildPath(n, this.shape, !1), this.__dirtyPath = !1) : (t.beginPath(), this.path.rebuildPath(t)), a && n.fill(t), m && g && (t.setLineDash(m), t.lineDashOffset = v), r && n[u](t), m && g && t.setLineDash([]), this.restoreTransform(t), null != i.text && this.drawRectText(t, this[S]())
            },
            buildPath: function () { },
            getBoundingRect: function () {
                var t = this._rect,
                    e = this.style,
                    i = !t;
                if (i) {
                    var n = this.path;
                    this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), t = n[S]()
                }
                if (this._rect = t, e.hasStroke()) {
                    var r = this._rectWithStroke || (this._rectWithStroke = t.clone());
                    if (this.__dirty || i) {
                        r.copy(t);
                        var a = e.lineWidth,
                            o = e.strokeNoScale ? this.getLineScale() : 1;
                        e.hasFill() || (a = Math.max(a, this.strokeContainThreshold || 4)), o > 1e-10 && (r.width += a / o, r[ue] += a / o, r.x -= a / o / 2, r.y -= a / o / 2)
                    }
                    return r
                }
                return t
            },
            contain: function (t, e) {
                var i = this.transformCoordToLocal(t, e),
                    n = this[S](),
                    r = this.style;
                if (t = i[0], e = i[1], n[x](t, e)) {
                    var o = this.path.data;
                    if (r.hasStroke()) {
                        var s = r.lineWidth,
                            l = r.strokeNoScale ? this.getLineScale() : 1;
                        if (l > 1e-10 && (r.hasFill() || (s = Math.max(s, this.strokeContainThreshold)), a.containStroke(o, s / l, t, e))) return !0
                    }
                    if (r.hasFill()) return a[x](o, t, e)
                }
                return !1
            },
            dirty: function (t) {
                null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty()
            },
            animateShape: function (t) {
                return this.animate("shape", t)
            },
            attrKV: function (t, e) {
                "shape" === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : i[he].attrKV.call(this, t, e)
            },
            setShape: function (t, e) {
                var i = this.shape;
                if (i) {
                    if (n[oe](t))
                        for (var r in t) t.hasOwnProperty(r) && (i[r] = t[r]);
                    else i[t] = e;
                    this.dirty(!0)
                }
                return this
            },
            getLineScale: function () {
                var t = this.transform;
                return t && l(t[0] - 1) > 1e-10 && l(t[3] - 1) > 1e-10 ? Math.sqrt(l(t[0] * t[3] - t[2] * t[1])) : 1
            }
        }, e[H] = function (t) {
            var i = function (i) {
                e.call(this, i), t.style && this.style.extendFrom(t.style, !1);
                var n = t.shape;
                if (n) {
                    this.shape = this.shape || {};
                    var r = this.shape;
                    for (var a in n) !r.hasOwnProperty(a) && n.hasOwnProperty(a) && (r[a] = n[a])
                }
                t.init && t.init.call(this, i)
            };
            n.inherits(i, e);
            for (var r in t) "style" !== r && "shape" !== r && (i[he][r] = t[r]);
            return i
        }, n.inherits(e, i), e
    }), e("zrender/container/Group", [me, "../core/util", "../Element", "../core/BoundingRect"], function (t) {
        var e = t("../core/util"),
            i = t("../Element"),
            n = t("../core/BoundingRect"),
            r = function (t) {
                t = t || {}, i.call(this, t);
                for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]);
                this._children = [], this.__storage = null, this.__dirty = !0
            };
        return r[he] = {
            constructor: r,
            isGroup: !0,
            type: "group",
            silent: !1,
            children: function () {
                return this._children.slice()
            },
            childAt: function (t) {
                return this._children[t]
            },
            childOfName: function (t) {
                for (var e = this._children, i = 0; i < e[te]; i++)
                    if (e[i].name === t) return e[i]
            },
            childCount: function () {
                return this._children[te]
            },
            add: function (t) {
                return t && t !== this && t[l] !== this && (this._children.push(t), this._doAdd(t)), this
            },
            addBefore: function (t, e) {
                if (t && t !== this && t[l] !== this && e && e[l] === this) {
                    var i = this._children,
                        n = i[J](e);
                    n >= 0 && (i[F](n, 0, t), this._doAdd(t))
                }
                return this
            },
            _doAdd: function (t) {
                t[l] && t[l][q](t), t[l] = this;
                var e = this.__storage,
                    i = this.__zr;
                e && e !== t.__storage && (e.addToMap(t), t instanceof r && t.addChildrenToStorage(e)), i && i.refresh()
            },
            remove: function (t) {
                var i = this.__zr,
                    n = this.__storage,
                    a = this._children,
                    o = e[J](a, t);
                return 0 > o ? this : (a[F](o, 1), t[l] = null, n && (n.delFromMap(t.id), t instanceof r && t.delChildrenFromStorage(n)), i && i.refresh(), this)
            },
            removeAll: function () {
                var t, e, i = this._children,
                    n = this.__storage;
                for (e = 0; e < i[te]; e++) t = i[e], n && (n.delFromMap(t.id), t instanceof r && t.delChildrenFromStorage(n)), t[l] = null;
                return i[te] = 0, this
            },
            eachChild: function (t, e) {
                for (var i = this._children, n = 0; n < i[te]; n++) {
                    var r = i[n];
                    t.call(e, r, n)
                }
                return this
            },
            traverse: function (t, e) {
                for (var i = 0; i < this._children[te]; i++) {
                    var n = this._children[i];
                    t.call(e, n), "group" === n.type && n[B](t, e)
                }
                return this
            },
            addChildrenToStorage: function (t) {
                for (var e = 0; e < this._children[te]; e++) {
                    var i = this._children[e];
                    t.addToMap(i), i instanceof r && i.addChildrenToStorage(t)
                }
            },
            delChildrenFromStorage: function (t) {
                for (var e = 0; e < this._children[te]; e++) {
                    var i = this._children[e];
                    t.delFromMap(i.id), i instanceof r && i.delChildrenFromStorage(t)
                }
            },
            dirty: function () {
                return this.__dirty = !0, this.__zr && this.__zr.refresh(), this
            },
            getBoundingRect: function (t) {
                for (var e = null, i = new n(0, 0, 0, 0), r = t || this._children, a = [], o = 0; o < r[te]; o++) {
                    var s = r[o];
                    if (!s[ie] && !s.invisible) {
                        var l = s[S](),
                            u = s.getLocalTransform(a);
                        u ? (i.copy(l), i[c](u), e = e || i.clone(), e.union(i)) : (e = e || l.clone(), e.union(l))
                    }
                }
                return e || i
            }
        }, e.inherits(r, i), r
    }), e("zrender/graphic/Image", [me, "./Displayable", "../core/BoundingRect", "../core/util", "../core/LRU"], function (t) {
        function e(t) {
            i.call(this, t)
        }
        var i = t("./Displayable"),
            n = t("../core/BoundingRect"),
            r = t("../core/util"),
            a = t("../core/LRU"),
            o = new a(50);
        return e[he] = {
            constructor: e,
            type: "image",
            brush: function (t, e) {
                var i, n = this.style,
                    r = n.image;
                if (n.bind(t, this, e), i = typeof r === ce ? this._image : r, !i && r) {
                    var a = o.get(r);
                    if (!a) return i = new Image, i.onload = function () {
                        i.onload = null;
                        for (var t = 0; t < a.pending[te]; t++) a.pending[t].dirty()
                    }, a = {
                        image: i,
                        pending: [this]
                    }, i.src = r, o.put(r, a), void (this._image = i);
                    if (i = a.image, this._image = i, !i.width || !i[ue]) return void a.pending.push(this)
                }
                if (i) {
                    var s = n.width || i.width,
                        l = n[ue] || i[ue],
                        u = n.x || 0,
                        c = n.y || 0;
                    if (!i.width || !i[ue]) return;
                    if (this.setTransform(t), n.sWidth && n.sHeight) {
                        var h = n.sx || 0,
                            f = n.sy || 0;
                        t.drawImage(i, h, f, n.sWidth, n.sHeight, u, c, s, l)
                    } else if (n.sx && n.sy) {
                        var h = n.sx,
                            f = n.sy,
                            d = s - h,
                            p = l - f;
                        t.drawImage(i, h, f, d, p, u, c, s, l)
                    } else t.drawImage(i, u, c, s, l);
                    null == n.width && (n.width = s), null == n[ue] && (n[ue] = l), this.restoreTransform(t), null != n.text && this.drawRectText(t, this[S]())
                }
            },
            getBoundingRect: function () {
                var t = this.style;
                return this._rect || (this._rect = new n(t.x || 0, t.y || 0, t.width || 0, t[ue] || 0)), this._rect
            }
        }, r.inherits(e, i), e
    }), e("zrender/graphic/Text", [me, "./Displayable", "../core/util", "../contain/text"], function (t) {
        var e = t("./Displayable"),
            i = t("../core/util"),
            n = t("../contain/text"),
            r = function (t) {
                e.call(this, t)
            };
        return r[he] = {
            constructor: r,
            type: "text",
            brush: function (t, e) {
                var i = this.style,
                    r = i.x || 0,
                    a = i.y || 0,
                    o = i.text;
                if (null != o && (o += ""), i.bind(t, this, e), o) {
                    this.setTransform(t);
                    var s, l = i.textAlign,
                        u = i.textFont || i.font;
                    if (i.textVerticalAlign) {
                        var c = n[S](o, u, i.textAlign, "top");
                        switch (s = T, i.textVerticalAlign) {
                            case T:
                                a -= c[ue] / 2 - c.lineHeight / 2;
                                break;
                            case ee:
                                a -= c[ue] - c.lineHeight / 2;
                                break;
                            default:
                                a += c.lineHeight / 2
                        }
                    } else s = i.textBaseline;
                    t.font = u || "12px sans-serif", t.textAlign = l || "left", t.textAlign !== l && (t.textAlign = "left"), t.textBaseline = s || "alphabetic", t.textBaseline !== s && (t.textBaseline = "alphabetic");
                    for (var h = n.measureText("", t.font).width, f = o.split("\n"), d = 0; d < f[te]; d++) i.hasFill() && t.fillText(f[d], r, a), i.hasStroke() && t.strokeText(f[d], r, a), a += h;
                    this.restoreTransform(t)
                }
            },
            getBoundingRect: function () {
                if (!this._rect) {
                    var t = this.style,
                        e = t.textVerticalAlign,
                        i = n[S](t.text + "", t.textFont || t.font, t.textAlign, e ? "top" : t.textBaseline);
                    switch (e) {
                        case T:
                            i.y -= i[ue] / 2;
                            break;
                        case ee:
                            i.y -= i[ue]
                    }
                    i.x += t.x || 0, i.y += t.y || 0, this._rect = i
                }
                return this._rect
            }
        }, i.inherits(r, e), r
    }), e("zrender/graphic/shape/Circle", [me, "../Path"], function (t) {
        return t("../Path")[H]({
            type: "circle",
            shape: {
                cx: 0,
                cy: 0,
                r: 0
            },
            buildPath: function (t, e, n) {
                n && t[i](e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
            }
        })
    }), e("zrender/graphic/shape/Sector", [me, "../../core/env", "../Path"], function (t) {
        var e = t("../../core/env"),
            n = t("../Path"),
            r = [
                ["shadowBlur", 0],
                ["shadowColor", "#000"],
                ["shadowOffsetX", 0],
                ["shadowOffsetY", 0]
            ];
        return n[H]({
            type: "sector",
            shape: {
                cx: 0,
                cy: 0,
                r0: 0,
                r: 0,
                startAngle: 0,
                endAngle: 2 * Math.PI,
                clockwise: !0
            },
            brush: e.browser.ie && e.browser.version >= 11 ? function () {
                var t, e = this.__clipPaths,
                    i = this.style;
                if (e)
                    for (var a = 0; a < e[te]; a++) {
                        var o = e[a] && e[a].shape;
                        if (o && o.startAngle === o.endAngle) {
                            for (var s = 0; s < r[te]; s++) r[s][2] = i[r[s][0]], i[r[s][0]] = r[s][1];
                            t = !0;
                            break
                        }
                    }
                if (n[he].brush.apply(this, arguments), t)
                    for (var s = 0; s < r[te]; s++) i[r[s][0]] = r[s][2]
            } : n[he].brush,
            buildPath: function (t, e) {
                var n = e.cx,
                    r = e.cy,
                    a = Math.max(e.r0 || 0, 0),
                    o = Math.max(e.r, 0),
                    s = e.startAngle,
                    l = e.endAngle,
                    u = e.clockwise,
                    c = Math.cos(s),
                    h = Math.sin(s);
                t[i](c * a + n, h * a + r), t.lineTo(c * o + n, h * o + r), t.arc(n, r, o, s, l, !u), t.lineTo(Math.cos(l) * a + n, Math.sin(l) * a + r), 0 !== a && t.arc(n, r, a, l, s, u), t.closePath()
            }
        })
    }), e("zrender/graphic/shape/Ring", [me, "../Path"], function (t) {
        return t("../Path")[H]({
            type: "ring",
            shape: {
                cx: 0,
                cy: 0,
                r: 0,
                r0: 0
            },
            buildPath: function (t, e) {
                var n = e.cx,
                    r = e.cy,
                    a = 2 * Math.PI;
                t[i](n + e.r, r), t.arc(n, r, e.r, 0, a, !1), t[i](n + e.r0, r), t.arc(n, r, e.r0, 0, a, !0)
            }
        })
    }), e("zrender/graphic/shape/Polygon", [me, "../helper/poly", "../Path"], function (t) {
        var e = t("../helper/poly");
        return t("../Path")[H]({
            type: "polygon",
            shape: {
                points: null,
                smooth: !1,
                smoothConstraint: null
            },
            buildPath: function (t, i) {
                e.buildPath(t, i, !0)
            }
        })
    }), e("zrender/graphic/shape/Polyline", [me, "../helper/poly", "../Path"], function (t) {
        var e = t("../helper/poly");
        return t("../Path")[H]({
            type: "polyline",
            shape: {
                points: null,
                smooth: !1,
                smoothConstraint: null
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function (t, i) {
                e.buildPath(t, i, !1)
            }
        })
    }), e("zrender/graphic/shape/Rect", [me, "../helper/roundRect", "../Path"], function (t) {
        var e = t("../helper/roundRect");
        return t("../Path")[H]({
            type: "rect",
            shape: {
                r: 0,
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            buildPath: function (t, i) {
                var n = i.x,
                    r = i.y,
                    a = i.width,
                    o = i[ue];
                i.r ? e.buildPath(t, i) : t.rect(n, r, a, o), t.closePath()
            }
        })
    }), e("zrender/graphic/shape/Line", [me, "../Path"], function (t) {
        return t("../Path")[H]({
            type: "line",
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                percent: 1
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function (t, e) {
                var n = e.x1,
                    r = e.y1,
                    a = e.x2,
                    o = e.y2,
                    s = e.percent;
                0 !== s && (t[i](n, r), 1 > s && (a = n * (1 - s) + a * s, o = r * (1 - s) + o * s), t.lineTo(a, o))
            },
            pointAt: function (t) {
                var e = this.shape;
                return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
            }
        })
    }), e("zrender/graphic/shape/BezierCurve", [me, "../../core/curve", "../../core/vector", "../Path"], function (t) {
        function e(t, e, i) {
            var n = t.cpx2,
                r = t.cpy2;
            return null === n || null === r ? [(i ? c : l)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? c : l)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? u : s)(t.x1, t.cpx1, t.x2, e), (i ? u : s)(t.y1, t.cpy1, t.y2, e)]
        }
        var n = t("../../core/curve"),
            r = t("../../core/vector"),
            a = n.quadraticSubdivide,
            o = n.cubicSubdivide,
            s = n.quadraticAt,
            l = n.cubicAt,
            u = n.quadraticDerivativeAt,
            c = n.cubicDerivativeAt,
            h = [];
        return t("../Path")[H]({
            type: "bezier-curve",
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                cpx1: 0,
                cpy1: 0,
                percent: 1
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function (t, e) {
                var n = e.x1,
                    r = e.y1,
                    s = e.x2,
                    l = e.y2,
                    u = e.cpx1,
                    c = e.cpy1,
                    f = e.cpx2,
                    d = e.cpy2,
                    p = e.percent;
                0 !== p && (t[i](n, r), null == f || null == d ? (1 > p && (a(n, u, s, p, h), u = h[1], s = h[2], a(r, c, l, p, h), c = h[1], l = h[2]), t.quadraticCurveTo(u, c, s, l)) : (1 > p && (o(n, u, f, s, p, h), u = h[1], f = h[2], s = h[3], o(r, c, d, l, p, h), c = h[1], d = h[2], l = h[3]), t.bezierCurveTo(u, c, f, d, s, l)))
            },
            pointAt: function (t) {
                return e(this.shape, t, !1)
            },
            tangentAt: function (t) {
                var i = e(this.shape, t, !0);
                return r.normalize(i, i)
            }
        })
    }), e("zrender/graphic/shape/Arc", [me, "../Path"], function (t) {
        return t("../Path")[H]({
            type: "arc",
            shape: {
                cx: 0,
                cy: 0,
                r: 0,
                startAngle: 0,
                endAngle: 2 * Math.PI,
                clockwise: !0
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function (t, e) {
                var n = e.cx,
                    r = e.cy,
                    a = Math.max(e.r, 0),
                    o = e.startAngle,
                    s = e.endAngle,
                    l = e.clockwise,
                    u = Math.cos(o),
                    c = Math.sin(o);
                t[i](u * a + n, c * a + r), t.arc(n, r, a, o, s, !l)
            }
        })
    }), e("zrender/graphic/CompoundPath", [me, "./Path"], function (t) {
        var e = t("./Path");
        return e[H]({
            type: "compound",
            shape: {
                paths: null
            },
            _updatePathDirty: function () {
                for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e[te]; i++) t = t || e[i].__dirtyPath;
                this.__dirtyPath = t, this.__dirty = this.__dirty || t
            },
            beforeBrush: function () {
                this._updatePathDirty();
                for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t[te]; i++) t[i].path.setScale(e[0], e[1])
            },
            buildPath: function (t, e) {
                for (var i = e.paths || [], n = 0; n < i[te]; n++) i[n].buildPath(t, i[n].shape, !0)
            },
            afterBrush: function () {
                for (var t = this.shape.paths, e = 0; e < t[te]; e++) t[e].__dirtyPath = !1
            },
            getBoundingRect: function () {
                return this._updatePathDirty(), e[he][S].call(this)
            }
        })
    }), e("zrender/graphic/LinearGradient", [me, "../core/util", "./Gradient"], function (t) {
        var e = t("../core/util"),
            i = t("./Gradient"),
            n = function (t, e, n, r, a, o) {
                this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == n ? 1 : n, this.y2 = null == r ? 0 : r, this.type = "linear", this.global = o || !1, i.call(this, a)
            };
        return n[he] = {
            constructor: n
        }, e.inherits(n, i), n
    }), e("zrender/graphic/RadialGradient", [me, "../core/util", "./Gradient"], function (t) {
        var e = t("../core/util"),
            i = t("./Gradient"),
            n = function (t, e, n, r, a) {
                this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == n ? .5 : n, this.type = "radial", this.global = a || !1, i.call(this, r)
            };
        return n[he] = {
            constructor: n
        }, e.inherits(n, i), n
    }), e("zrender/core/BoundingRect", [me, "./vector", "./matrix"], function (t) {
        function e(t, e, i, n) {
            0 > i && (t += i, i = -i), 0 > n && (e += n, n = -n), this.x = t, this.y = e, this.width = i, this[ue] = n
        }
        var i = t("./vector"),
            n = t("./matrix"),
            r = i[c],
            a = Math.min,
            o = Math.max;
        return e[he] = {
            constructor: e,
            union: function (t) {
                var e = a(t.x, this.x),
                    i = a(t.y, this.y);
                this.width = o(t.x + t.width, this.x + this.width) - e, this[ue] = o(t.y + t[ue], this.y + this[ue]) - i, this.x = e, this.y = i
            },
            applyTransform: function () {
                var t = [],
                    e = [],
                    i = [],
                    n = [];
                return function (s) {
                    if (s) {
                        t[0] = i[0] = this.x, t[1] = n[1] = this.y, e[0] = n[0] = this.x + this.width, e[1] = i[1] = this.y + this[ue], r(t, t, s), r(e, e, s), r(i, i, s), r(n, n, s), this.x = a(t[0], e[0], i[0], n[0]), this.y = a(t[1], e[1], i[1], n[1]);
                        var l = o(t[0], e[0], i[0], n[0]),
                            u = o(t[1], e[1], i[1], n[1]);
                        this.width = l - this.x, this[ue] = u - this.y
                    }
                }
            }(),
            calculateTransform: function (t) {
                var e = this,
                    i = t.width / e.width,
                    r = t[ue] / e[ue],
                    a = n[X]();
                return n.translate(a, a, [-e.x, -e.y]), n.scale(a, a, [i, r]), n.translate(a, a, [t.x, t.y]), a
            },
            intersect: function (t) {
                if (!t) return !1;
                t instanceof e || (t = e[X](t));
                var i = this,
                    n = i.x,
                    r = i.x + i.width,
                    a = i.y,
                    o = i.y + i[ue],
                    s = t.x,
                    l = t.x + t.width,
                    u = t.y,
                    c = t.y + t[ue];
                return !(s > r || n > l || u > o || a > c)
            },
            contain: function (t, e) {
                var i = this;
                return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i[ue]
            },
            clone: function () {
                return new e(this.x, this.y, this.width, this[ue])
            },
            copy: function (t) {
                this.x = t.x, this.y = t.y, this.width = t.width, this[ue] = t[ue]
            },
            plain: function () {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this[ue]
                }
            }
        }, e[X] = function (t) {
            return new e(t.x, t.y, t.width, t[ue])
        }, e
    }), e("zrender/contain/text", [me, "../core/util", "../core/BoundingRect"], function (t) {
        function e(t, e) {
            var i = t + ":" + e;
            if (o[i]) return o[i];
            for (var n = (t + "").split("\n"), r = 0, a = 0, s = n[te]; s > a; a++) r = Math.max(d.measureText(n[a], e).width, r);
            return l > u && (l = 0, o = {}), l++, o[i] = r, r
        }

        function i(t, i, n, r) {
            var a = ((t || "") + "").split("\n")[te],
                o = e(t, i),
                s = e("", i),
                l = a * s,
                u = new h(0, 0, o, l);
            switch (u.lineHeight = s, r) {
                case ee:
                case "alphabetic":
                    u.y -= s;
                    break;
                case T:
                    u.y -= s / 2
            }
            switch (n) {
                case "end":
                case "right":
                    u.x -= u.width;
                    break;
                case M:
                    u.x -= u.width / 2
            }
            return u
        }

        function n(t, e, i, n) {
            var r = e.x,
                a = e.y,
                o = e[ue],
                s = e.width,
                l = i[ue],
                u = o / 2 - l / 2,
                c = "left";
            switch (t) {
                case "left":
                    r -= n, a += u, c = "right";
                    break;
                case "right":
                    r += n + s, a += u, c = "left";
                    break;
                case "top":
                    r += s / 2, a -= n + l, c = M;
                    break;
                case ee:
                    r += s / 2, a += o + n, c = M;
                    break;
                case "inside":
                    r += s / 2, a += u, c = M;
                    break;
                case "insideLeft":
                    r += n, a += u, c = "left";
                    break;
                case "insideRight":
                    r += s - n, a += u, c = "right";
                    break;
                case "insideTop":
                    r += s / 2, a += n, c = M;
                    break;
                case "insideBottom":
                    r += s / 2, a += o - l - n, c = M;
                    break;
                case "insideTopLeft":
                    r += n, a += n, c = "left";
                    break;
                case "insideTopRight":
                    r += s - n, a += n, c = "right";
                    break;
                case "insideBottomLeft":
                    r += n, a += o - l - n;
                    break;
                case "insideBottomRight":
                    r += s - n, a += o - l - n, c = "right"
            }
            return {
                x: r,
                y: a,
                textAlign: c,
                textBaseline: "top"
            }
        }

        function r(t, i, n, r, o) {
            if (!i) return "";
            o = o || {}, r = f(r, "...");
            for (var s = f(o.maxIterations, 2), l = f(o.minChar, 0), u = e("", n), c = e("a", n), h = f(o.placeholder, ""), d = i = Math.max(0, i - 1), p = 0; l > p && d >= c; p++) d -= c;
            var m = e(r);
            m > d && (r = "", m = 0), d = i - m;
            for (var v = (t + "").split("\n"), p = 0, g = v[te]; g > p; p++) {
                var y = v[p],
                    _ = e(y, n);
                if (!(i >= _)) {
                    for (var x = 0; ; x++) {
                        if (d >= _ || x >= s) {
                            y += r;
                            break
                        }
                        var b = 0 === x ? a(y, d, c, u) : _ > 0 ? Math.floor(y[te] * d / _) : 0;
                        y = y.substr(0, b), _ = e(y, n)
                    }
                    "" === y && (y = h), v[p] = y
                }
            }
            return v.join("\n")
        }

        function a(t, e, i, n) {
            for (var r = 0, a = 0, o = t[te]; o > a && e > r; a++) {
                var s = t.charCodeAt(a);
                r += s >= 0 && 127 >= s ? i : n
            }
            return a
        }
        var o = {},
            l = 0,
            u = 5e3,
            c = t("../core/util"),
            h = t("../core/BoundingRect"),
            f = c[s],
            d = {
                getWidth: e,
                getBoundingRect: i,
                adjustTextPositionOnRect: n,
                truncateText: r,
                measureText: function (t, e) {
                    var i = c.getContext();
                    return i.font = e || "12px sans-serif", i.measureText(t)
                }
            };
        return d
    }), e("echarts/coord/axisHelper", [me, "../scale/Ordinal", "../scale/Interval", "../scale/Time", "../scale/Log", "../scale/Scale", "../util/number", de, "zrender/contain/text"], function (t) {
        var e = t("../scale/Ordinal"),
            i = t("../scale/Interval");
        t("../scale/Time"), t("../scale/Log");
        var n = t("../scale/Scale"),
            r = t("../util/number"),
            o = t(de),
            s = t("zrender/contain/text"),
            l = {};
        return l.getScaleExtent = function (t, e) {
            var i, n, s, l = t.scale,
                u = l.type,
                c = e.getMin(),
                h = e.getMax(),
                f = null != c,
                d = null != h,
                m = l[_]();
            return u === p ? i = (e.get("data") || [])[te] : (n = e.get("boundaryGap"), o[z](n) || (n = [n || 0, n || 0]), n[0] = r[a](n[0], 1), n[1] = r[a](n[1], 1), s = m[1] - m[0]), null == c && (c = u === p ? i ? 0 : 0 / 0 : m[0] - n[0] * s), null == h && (h = u === p ? i ? i - 1 : 0 / 0 : m[1] + n[1] * s), "dataMin" === c && (c = m[0]), "dataMax" === h && (h = m[1]), (null == c || !isFinite(c)) && (c = 0 / 0), (null == h || !isFinite(h)) && (h = 0 / 0), t.setBlank(o.eqNaN(c) || o.eqNaN(h)), e.getNeedCrossZero() && (c > 0 && h > 0 && !f && (c = 0), 0 > c && 0 > h && !d && (h = 0)), [c, h]
        }, l.niceScaleExtent = function (t, e) {
            var i = t.scale,
                n = l.getScaleExtent(t, e),
                r = null != e.getMin(),
                a = null != e.getMax(),
                o = e.get("splitNumber");
            "log" === i.type && (i.base = e.get("logBase")), i.setExtent(n[0], n[1]), i.niceExtent(o, r, a);
            var s = e.get("minInterval");
            if (isFinite(s) && !r && !a && "interval" === i.type) {
                var u = i.getInterval(),
                    c = Math.max(Math.abs(u), s) / u;
                n = i[_]();
                var h = (n[1] + n[0]) / 2;
                i.setExtent(c * (n[0] - h) + h, c * (n[1] - h) + h), i.niceExtent(o)
            }
            var u = e.get("interval");
            null != u && i.setInterval && i.setInterval(u)
        }, l.createScaleByModel = function (t, r) {
            if (r = r || t.get("type")) switch (r) {
                case "category":
                    return new e(t.getCategories(), [1 / 0, -1 / 0]);
                case "value":
                    return new i;
                default:
                    return (n.getClass(r) || i)[X](t)
            }
        }, l.ifAxisCrossZero = function (t) {
            var e = t.scale[_](),
                i = e[0],
                n = e[1];
            return !(i > 0 && n > 0 || 0 > i && 0 > n)
        }, l.getAxisLabelInterval = function (t, e, i, n) {
            var r, a = 0,
                o = 0,
                l = 1;
            e[te] > 40 && (l = Math.floor(e[te] / 40));
            for (var u = 0; u < t[te]; u += l) {
                var c = t[u],
                    h = s[S](e[u], i, M, "top");
                h[n ? "x" : "y"] += c, h[n ? "width" : ue] *= 1.3, r ? r.intersect(h) ? (o++, a = Math.max(a, o)) : (r.union(h), o = 0) : r = h.clone()
            }
            return 0 === a && l > 1 ? l : (a + 1) * l - 1
        }, l.getFormattedLabels = function (t, e) {
            var i = t.scale,
                n = i.getTicksLabels(),
                r = i[y]();
            return typeof e === ce ? (e = function (t) {
                return function (e) {
                    return t[I]("{value}", null != e ? e : "")
                }
            }(e), o.map(n, e)) : typeof e === L ? o.map(r, function (n, r) {
                return e("category" === t.type ? i.getLabel(n) : n, r)
            }, this) : n
        }, l
    }), e("echarts/coord/cartesian/Cartesian2D", [me, de, "./Cartesian"], function (t) {
        function e(t) {
            n.call(this, t)
        }
        var i = t(de),
            n = t("./Cartesian");
        return e[he] = {
            constructor: e,
            type: "cartesian2d",
            dimensions: ["x", "y"],
            getBaseAxis: function () {
                return this.getAxesByScale(p)[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
            },
            containPoint: function (t) {
                var e = this.getAxis("x"),
                    i = this.getAxis("y");
                return e[x](e.toLocalCoord(t[0])) && i[x](i.toLocalCoord(t[1]))
            },
            containData: function (t) {
                return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1])
            },
            dataToPoints: function (t, e) {
                return t.mapArray(["x", "y"], function (t, e) {
                    return this[r]([t, e])
                }, e, this)
            },
            dataToPoint: function (t, e) {
                var i = this.getAxis("x"),
                    n = this.getAxis("y");
                return [i.toGlobalCoord(i.dataToCoord(t[0], e)), n.toGlobalCoord(n.dataToCoord(t[1], e))]
            },
            pointToData: function (t, e) {
                var i = this.getAxis("x"),
                    n = this.getAxis("y");
                return [i.coordToData(i.toLocalCoord(t[0]), e), n.coordToData(n.toLocalCoord(t[1]), e)]
            },
            getOtherAxis: function (t) {
                return this.getAxis("x" === t.dim ? "y" : "x")
            }
        }, i.inherits(e, n), e
    }), e("echarts/coord/cartesian/Axis2D", [me, de, "../Axis", "./axisLabelInterval"], function (t) {
        var e = t(de),
            i = t("../Axis"),
            n = t("./axisLabelInterval"),
            r = function (t, e, n, r, a) {
                i.call(this, t, e, n), this.type = r || "value", this[w] = a || ee
            };
        return r[he] = {
            constructor: r,
            index: 0,
            onZero: !1,
            model: null,
            isHorizontal: function () {
                var t = this[w];
                return "top" === t || t === ee
            },
            getGlobalExtent: function () {
                var t = this[_]();
                return t[0] = this.toGlobalCoord(t[0]), t[1] = this.toGlobalCoord(t[1]), t
            },
            getLabelInterval: function () {
                var t = this._labelInterval;
                return t || (t = this._labelInterval = n(this)), t
            },
            isLabelIgnored: function (t) {
                if ("category" === this.type) {
                    var e = this.getLabelInterval();
                    return typeof e === L && !e(t, this.scale.getLabel(t)) || t % (e + 1)
                }
            },
            toLocalCoord: null,
            toGlobalCoord: null
        }, e.inherits(r, i), r
    }), e("echarts/coord/cartesian/GridModel", [me, "./AxisModel", "../../model/Component"], function (t) {
        t("./AxisModel");
        var e = t("../../model/Component");
        return e[H]({
            type: "grid",
            dependencies: ["xAxis", "yAxis"],
            layoutMode: "box",
            coordinateSystem: null,
            defaultOption: {
                show: !1,
                zlevel: 0,
                z: 0,
                left: "10%",
                top: 60,
                right: "10%",
                bottom: 60,
                containLabel: !1,
                backgroundColor: "rgba(0,0,0,0)",
                borderWidth: 1,
                borderColor: "#ccc"
            }
        })
    }), e("echarts/data/DataDiffer", [me], function () {
        function t(t) {
            return t
        }

        function e(e, i, n, r) {
            this._old = e, this._new = i, this._oldKeyGetter = n || t, this._newKeyGetter = r || t
        }

        function i(t, e, i, n) {
            for (var r = 0; r < t[te]; r++) {
                var a = n(t[r], r),
                    o = e[a];
                null == o ? (i.push(a), e[a] = r) : (o[te] || (e[a] = o = [o]), o.push(r))
            }
        }
        return e[he] = {
            constructor: e,
            add: function (t) {
                return this._add = t, this
            },
            update: function (t) {
                return this._update = t, this
            },
            remove: function (t) {
                return this._remove = t, this
            },
            execute: function () {
                var t, e = this._old,
                    n = this._new,
                    r = this._oldKeyGetter,
                    a = this._newKeyGetter,
                    o = {},
                    s = {},
                    l = [],
                    u = [];
                for (i(e, o, l, r), i(n, s, u, a), t = 0; t < e[te]; t++) {
                    var c = l[t],
                        h = s[c];
                    if (null != h) {
                        var f = h[te];
                        f ? (1 === f && (s[c] = null), h = h.unshift()) : s[c] = null, this._update && this._update(h, t)
                    } else this._remove && this._remove(t)
                }
                for (var t = 0; t < u[te]; t++) {
                    var c = u[t];
                    if (s.hasOwnProperty(c)) {
                        var h = s[c];
                        if (null == h) continue;
                        if (h[te])
                            for (var d = 0, f = h[te]; f > d; d++) this._add && this._add(h[d]);
                        else this._add && this._add(h)
                    }
                }
            }
        }, e
    }), e("echarts/util/clazz", [me, de], function (t) {
        function e(t) {
            r.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal')
        }

        function i(t, e) {
            var i = r.slice(arguments, 2);
            return this.superClass[he][e].apply(t, i)
        }

        function n(t, e, i) {
            return this.superClass[he][e].apply(t, i)
        }
        var r = t(de),
            a = {},
            o = ".",
            s = "___EC__COMPONENT__CONTAINER___",
            l = "\x00ec_\x00";
        a.set = function (t, e, i) {
            return t[l + e] = i
        }, a.get = function (t, e) {
            return t[l + e]
        }, a.hasOwn = function (t, e) {
            return t.hasOwnProperty(l + e)
        };
        var u = a.parseClassType = function (t) {
            var e = {
                main: "",
                sub: ""
            };
            return t && (t = t.split(o), e.main = t[0] || "", e.sub = t[1] || ""), e
        };
        return a.enableClassExtend = function (t, e) {
            t.$constructor = t, t[H] = function (t) {
                var e = this,
                    a = function () {
                        t.$constructor ? t.$constructor.apply(this, arguments) : e.apply(this, arguments)
                    };
                return r[H](a[he], t), a[H] = this[H], a.superCall = i, a.superApply = n, r.inherits(a, this), a.superClass = e, a
            }
        }, a.enableClassManagement = function (t, i) {
            function n(t) {
                var e = a[t.main];
                return e && e[s] || (e = a[t.main] = {}, e[s] = !0), e
            }
            i = i || {};
            var a = {};
            if (t.registerClass = function (t, i) {
                if (i)
                    if (e(i), i = u(i), i.sub) {
                        if (i.sub !== s) {
                            var r = n(i);
                            r[i.sub] = t
                        }
                    } else a[i.main] = t;
                return t
            }, t.getClass = function (t, e, i) {
                var n = a[t];
                if (n && n[s] && (n = e ? n[e] : null), i && !n) throw new Error(e ? "Component " + t + "." + (e || "") + " not exists. Load it first." : t + ".type should be specified.");
                return n
            }, t.getClassesByMainType = function (t) {
                t = u(t);
                var e = [],
                    i = a[t.main];
                return i && i[s] ? r.each(i, function (t, i) {
                    i !== s && e.push(t)
                }) : e.push(i), e
            }, t.hasClass = function (t) {
                return t = u(t), !!a[t.main]
            }, t.getAllClassMainTypes = function () {
                var t = [];
                return r.each(a, function (e, i) {
                    t.push(i)
                }), t
            }, t.hasSubTypes = function (t) {
                t = u(t);
                var e = a[t.main];
                return e && e[s]
            }, t.parseClassType = u, i.registerWhenExtend) {
                var o = t[H];
                o && (t[H] = function (e) {
                    var i = o.call(this, e);
                    return t.registerClass(i, e.type)
                })
            }
            return t
        }, a.setReadOnly = function () { }, a
    }), e("echarts/model/mixin/lineStyle", [me, "./makeStyleMapper"], function (t) {
        var e = t("./makeStyleMapper")([
            ["lineWidth", "width"],
            [u, "color"],
            [b],
            ["shadowBlur"],
            ["shadowOffsetX"],
            ["shadowOffsetY"],
            ["shadowColor"]
        ]);
        return {
            getLineStyle: function (t) {
                var i = e.call(this, t),
                    n = this.getLineDash(i.lineWidth);
                return n && (i.lineDash = n), i
            },
            getLineDash: function (t) {
                null == t && (t = 1);
                var e = this.get("type"),
                    i = Math.max(t, 2),
                    n = 4 * t;
                return "solid" === e || null == e ? null : "dashed" === e ? [n, n] : [i, i]
            }
        }
    }), e("echarts/model/mixin/areaStyle", [me, "./makeStyleMapper"], function (t) {
        return {
            getAreaStyle: t("./makeStyleMapper")([
                ["fill", "color"],
                ["shadowBlur"],
                ["shadowOffsetX"],
                ["shadowOffsetY"],
                [b],
                ["shadowColor"]
            ])
        }
    }), e("echarts/model/mixin/textStyle", [me, "zrender/contain/text"], function (t) {
        function e(t, e) {
            return t && t[d](e)
        }
        var i = t("zrender/contain/text");
        return {
            getTextColor: function () {
                var t = this[m];
                return this[d]("color") || t && t.get("textStyle.color")
            },
            getFont: function () {
                var t = this[m],
                    i = t && t[ae](A);
                return [this[d]("fontStyle") || e(i, "fontStyle"), this[d]("fontWeight") || e(i, "fontWeight"), (this[d]("fontSize") || e(i, "fontSize") || 12) + "px", this[d]("fontFamily") || e(i, "fontFamily") || "sans-serif"].join(" ")
            },
            getTextRect: function (t) {
                return i[S](t, this[C](), this[d]("align"), this[d]("baseline"))
            },
            truncateText: function (t, e, n, r) {
                return i.truncateText(t, e, this[C](), n, r)
            }
        }
    }), e("echarts/model/mixin/itemStyle", [me, "./makeStyleMapper"], function (t) {
        var e = t("./makeStyleMapper")([
            ["fill", "color"],
            [u, "borderColor"],
            ["lineWidth", "borderWidth"],
            [b],
            ["shadowBlur"],
            ["shadowOffsetX"],
            ["shadowOffsetY"],
            ["shadowColor"],
            ["textPosition"],
            ["textAlign"]
        ]);
        return {
            getItemStyle: function (t) {
                var i = e.call(this, t),
                    n = this.getBorderLineDash();
                return n && (i.lineDash = n), i
            },
            getBorderLineDash: function () {
                var t = this.get("borderType");
                return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
            }
        }
    }), e("echarts/component/marker/MarkerModel", [me, "../../util/model", de, pe, "../../util/format", "../../echarts"], function (t) {
        function e(t) {
            i.defaultEmphasis(t.label, i.LABEL_OPTIONS)
        }
        var i = t("../../util/model"),
            n = t(de),
            r = t(pe),
            a = t("../../util/format"),
            o = a.addCommas,
            s = a.encodeHTML,
            l = t("../../echarts").extendComponentModel({
                type: "marker",
                dependencies: [W, "grid", "polar", "geo"],
                init: function (t, e, i, n) {
                    this.mergeDefaultAndTheme(t, i), this.mergeOption(t, i, n.createdBySelf, !0)
                },
                isAnimationEnabled: function () {
                    if (r.node) return !1;
                    var t = this.__hostSeries;
                    return this[d](le) && t && t.isAnimationEnabled()
                },
                mergeOption: function (t, i, r, a) {
                    var o = this.constructor,
                        s = this.mainType + "Model";
                    r || i[Z](function (t) {
                        var r = t.get(this.mainType),
                            l = t[s];
                        return r && r.data ? (l ? l.mergeOption(r, i, !0) : (a && e(r), n.each(r.data, function (t) {
                            t instanceof Array ? (e(t[0]), e(t[1])) : e(t)
                        }), l = new o(r, this, i), n[H](l, {
                            mainType: this.mainType,
                            seriesIndex: t[R],
                            name: t.name,
                            createdBySelf: !0
                        }), l.__hostSeries = t), void (t[s] = l)) : void (t[s] = null)
                    }, this)
                },
                formatTooltip: function (t) {
                    var e = this[Q](),
                        i = this.getRawValue(t),
                        r = n[z](i) ? n.map(i, o).join(", ") : o(i),
                        a = e.getName(t),
                        l = s(this.name);
                    return (null != i || a) && (l += "<br />"), a && (l += s(a), null != i && (l += " : ")), null != i && (l += s(r)), l
                },
                getData: function () {
                    return this._data
                },
                setData: function (t) {
                    this._data = t
                }
            });
        return n.mixin(l, i.dataFormatMixin), l
    }), e("zrender/core/PathProxy", [me, "./curve", "./vector", "./bbox", "./BoundingRect", "../config"], function (t) {
        var e = t("./curve"),
            n = t("./vector"),
            r = t("./bbox"),
            a = t("./BoundingRect"),
            o = t("../config").devicePixelRatio,
            s = {
                M: 1,
                L: 2,
                C: 3,
                Q: 4,
                A: 5,
                Z: 6,
                R: 7
            },
            l = [],
            c = [],
            h = [],
            f = [],
            d = Math.min,
            p = Math.max,
            m = Math.cos,
            v = Math.sin,
            y = Math.sqrt,
            _ = Math.abs,
            x = typeof Float32Array != g,
            b = function () {
                this.data = [], this._len = 0, this._ctx = null, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._ux = 0, this._uy = 0
            };
        return b[he] = {
            constructor: b,
            _lineDash: null,
            _dashOffset: 0,
            _dashIdx: 0,
            _dashSum: 0,
            setScale: function (t, e) {
                this._ux = _(1 / o / t) || 0, this._uy = _(1 / o / e) || 0
            },
            getContext: function () {
                return this._ctx
            },
            beginPath: function (t) {
                return this._ctx = t, t && t.beginPath(), t && (this.dpr = t.dpr), this._len = 0, this._lineDash && (this._lineDash = null, this._dashOffset = 0), this
            },
            moveTo: function (t, e) {
                return this.addData(s.M, t, e), this._ctx && this._ctx[i](t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this
            },
            lineTo: function (t, e) {
                var i = _(t - this._xi) > this._ux || _(e - this._yi) > this._uy || this._len < 5;
                return this.addData(s.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this
            },
            bezierCurveTo: function (t, e, i, n, r, a) {
                return this.addData(s.C, t, e, i, n, r, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, r, a) : this._ctx.bezierCurveTo(t, e, i, n, r, a)), this._xi = r, this._yi = a, this
            },
            quadraticCurveTo: function (t, e, i, n) {
                return this.addData(s.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this
            },
            arc: function (t, e, i, n, r, a) {
                return this.addData(s.A, t, e, i, i, n, r - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, r, a), this._xi = m(r) * i + t, this._yi = v(r) * i + t, this
            },
            arcTo: function (t, e, i, n, r) {
                return this._ctx && this._ctx.arcTo(t, e, i, n, r), this
            },
            rect: function (t, e, i, n) {
                return this._ctx && this._ctx.rect(t, e, i, n), this.addData(s.R, t, e, i, n), this
            },
            closePath: function () {
                this.addData(s.Z);
                var t = this._ctx,
                    e = this._x0,
                    i = this._y0;
                return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this
            },
            fill: function (t) {
                t && t.fill(), this.toStatic()
            },
            stroke: function (t) {
                t && t[u](), this.toStatic()
            },
            setLineDash: function (t) {
                if (t instanceof Array) {
                    this._lineDash = t, this._dashIdx = 0;
                    for (var e = 0, i = 0; i < t[te]; i++) e += t[i];
                    this._dashSum = e
                }
                return this
            },
            setLineDashOffset: function (t) {
                return this._dashOffset = t, this
            },
            len: function () {
                return this._len
            },
            setData: function (t) {
                var e = t[te];
                this.data && this.data[te] == e || !x || (this.data = new Float32Array(e));
                for (var i = 0; e > i; i++) this.data[i] = t[i];
                this._len = e
            },
            appendPath: function (t) {
                t instanceof Array || (t = [t]);
                for (var e = t[te], i = 0, n = this._len, r = 0; e > r; r++) i += t[r].len();
                x && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
                for (var r = 0; e > r; r++)
                    for (var a = t[r].data, o = 0; o < a[te]; o++) this.data[n++] = a[o];
                this._len = n
            },
            addData: function (t) {
                var e = this.data;
                this._len + arguments[te] > e[te] && (this._expandData(), e = this.data);
                for (var i = 0; i < arguments[te]; i++) e[this._len++] = arguments[i];
                this._prevCmd = t
            },
            _expandData: function () {
                if (!(this.data instanceof Array)) {
                    for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
                    this.data = t
                }
            },
            _needsDash: function () {
                return this._lineDash
            },
            _dashedLineTo: function (t, e) {
                var n, r, a = this._dashSum,
                    o = this._dashOffset,
                    s = this._lineDash,
                    l = this._ctx,
                    u = this._xi,
                    c = this._yi,
                    h = t - u,
                    f = e - c,
                    m = y(h * h + f * f),
                    v = u,
                    g = c,
                    _ = s[te];
                for (h /= m, f /= m, 0 > o && (o = a + o), o %= a, v -= o * h, g -= o * f; h > 0 && t >= v || 0 > h && v >= t || 0 == h && (f > 0 && e >= g || 0 > f && g >= e);) r = this._dashIdx, n = s[r], v += h * n, g += f * n, this._dashIdx = (r + 1) % _, h > 0 && u > v || 0 > h && v > u || f > 0 && c > g || 0 > f && g > c || l[r % 2 ? i : "lineTo"](h >= 0 ? d(v, t) : p(v, t), f >= 0 ? d(g, e) : p(g, e));
                h = v - t, f = g - e, this._dashOffset = -y(h * h + f * f)
            },
            _dashedBezierTo: function (t, n, r, a, o, s) {
                var l, u, c, h, f, d = this._dashSum,
                    p = this._dashOffset,
                    m = this._lineDash,
                    v = this._ctx,
                    g = this._xi,
                    _ = this._yi,
                    x = e.cubicAt,
                    b = 0,
                    w = this._dashIdx,
                    M = m[te],
                    T = 0;
                for (0 > p && (p = d + p), p %= d, l = 0; 1 > l; l += .1) u = x(g, t, r, o, l + .1) - x(g, t, r, o, l), c = x(_, n, a, s, l + .1) - x(_, n, a, s, l), b += y(u * u + c * c);
                for (; M > w && (T += m[w], !(T > p)); w++);
                for (l = (T - p) / b; 1 >= l;) h = x(g, t, r, o, l), f = x(_, n, a, s, l), w % 2 ? v[i](h, f) : v.lineTo(h, f), l += m[w] / b, w = (w + 1) % M;
                w % 2 !== 0 && v.lineTo(o, s), u = o - h, c = s - f, this._dashOffset = -y(u * u + c * c)
            },
            _dashedQuadraticTo: function (t, e, i, n) {
                var r = i,
                    a = n;
                i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, r, a)
            },
            toStatic: function () {
                var t = this.data;
                t instanceof Array && (t[te] = this._len, x && (this.data = new Float32Array(t)))
            },
            getBoundingRect: function () {
                l[0] = l[1] = h[0] = h[1] = Number.MAX_VALUE, c[0] = c[1] = f[0] = f[1] = -Number.MAX_VALUE;
                for (var t = this.data, e = 0, i = 0, o = 0, u = 0, d = 0; d < t[te];) {
                    var p = t[d++];
                    switch (1 == d && (e = t[d], i = t[d + 1], o = e, u = i), p) {
                        case s.M:
                            o = t[d++], u = t[d++], e = o, i = u, h[0] = o, h[1] = u, f[0] = o, f[1] = u;
                            break;
                        case s.L:
                            r.fromLine(e, i, t[d], t[d + 1], h, f), e = t[d++], i = t[d++];
                            break;
                        case s.C:
                            r.fromCubic(e, i, t[d++], t[d++], t[d++], t[d++], t[d], t[d + 1], h, f), e = t[d++], i = t[d++];
                            break;
                        case s.Q:
                            r.fromQuadratic(e, i, t[d++], t[d++], t[d], t[d + 1], h, f), e = t[d++], i = t[d++];
                            break;
                        case s.A:
                            var g = t[d++],
                                y = t[d++],
                                _ = t[d++],
                                x = t[d++],
                                b = t[d++],
                                w = t[d++] + b,
                                M = (t[d++], 1 - t[d++]);
                            1 == d && (o = m(b) * _ + g, u = v(b) * x + y), r.fromArc(g, y, _, x, b, w, M, h, f), e = m(w) * _ + g, i = v(w) * x + y;
                            break;
                        case s.R:
                            o = e = t[d++], u = i = t[d++];
                            var T = t[d++],
                                S = t[d++];
                            r.fromLine(o, u, o + T, u + S, h, f);
                            break;
                        case s.Z:
                            e = o, i = u
                    }
                    n.min(l, l, h), n.max(c, c, f)
                }
                return 0 === d && (l[0] = l[1] = c[0] = c[1] = 0), new a(l[0], l[1], c[0] - l[0], c[1] - l[1])
            },
            rebuildPath: function (t) {
                for (var e, n, r, a, o, l, u = this.data, c = this._ux, h = this._uy, f = this._len, d = 0; f > d;) {
                    var p = u[d++];
                    switch (1 == d && (r = u[d], a = u[d + 1], e = r, n = a), p) {
                        case s.M:
                            e = r = u[d++], n = a = u[d++], t[i](r, a);
                            break;
                        case s.L:
                            o = u[d++], l = u[d++], (_(o - r) > c || _(l - a) > h || d === f - 1) && (t.lineTo(o, l), r = o, a = l);
                            break;
                        case s.C:
                            t.bezierCurveTo(u[d++], u[d++], u[d++], u[d++], u[d++], u[d++]), r = u[d - 2], a = u[d - 1];
                            break;
                        case s.Q:
                            t.quadraticCurveTo(u[d++], u[d++], u[d++], u[d++]), r = u[d - 2], a = u[d - 1];
                            break;
                        case s.A:
                            var g = u[d++],
                                y = u[d++],
                                x = u[d++],
                                b = u[d++],
                                w = u[d++],
                                M = u[d++],
                                T = u[d++],
                                S = u[d++],
                                C = x > b ? x : b,
                                A = x > b ? 1 : x / b,
                                P = x > b ? b / x : 1,
                                k = Math.abs(x - b) > .001,
                                L = w + M;
                            k ? (t.translate(g, y), t.rotate(T), t.scale(A, P), t.arc(0, 0, C, w, L, 1 - S), t.scale(1 / A, 1 / P), t.rotate(-T), t.translate(-g, -y)) : t.arc(g, y, C, w, L, 1 - S), 1 == d && (e = m(w) * x + g, n = v(w) * b + y), r = m(L) * x + g, a = v(L) * b + y;
                            break;
                        case s.R:
                            e = r = u[d], n = a = u[d + 1], t.rect(u[d++], u[d++], u[d++], u[d++]);
                            break;
                        case s.Z:
                            t.closePath(), r = e, a = n
                    }
                }
            }
        }, b.CMD = s, b
    }), e("zrender/tool/transformPath", [me, "../core/PathProxy", "../core/vector"], function (t) {
        function e(t, e) {
            var n, l, u, c, h, f, d = t.data,
                p = i.M,
                m = i.C,
                v = i.L,
                g = i.R,
                y = i.A,
                _ = i.Q;
            for (u = 0, c = 0; u < d[te];) {
                switch (n = d[u++], c = u, l = 0, n) {
                    case p:
                        l = 1;
                        break;
                    case v:
                        l = 1;
                        break;
                    case m:
                        l = 3;
                        break;
                    case _:
                        l = 2;
                        break;
                    case y:
                        var x = e[4],
                            b = e[5],
                            w = o(e[0] * e[0] + e[1] * e[1]),
                            M = o(e[2] * e[2] + e[3] * e[3]),
                            T = s(-e[1] / M, e[0] / w);
                        d[u++] += x, d[u++] += b, d[u++] *= w, d[u++] *= M, d[u++] += T, d[u++] += T, u += 2, c = u;
                        break;
                    case g:
                        f[0] = d[u++], f[1] = d[u++], r(f, f, e), d[c++] = f[0], d[c++] = f[1], f[0] += d[u++], f[1] += d[u++], r(f, f, e), d[c++] = f[0], d[c++] = f[1]
                }
                for (h = 0; l > h; h++) {
                    var f = a[h];
                    f[0] = d[u++], f[1] = d[u++], r(f, f, e), d[c++] = f[0], d[c++] = f[1]
                }
            }
        }
        var i = t("../core/PathProxy").CMD,
            n = t("../core/vector"),
            r = n[c],
            a = [
                [],
                [],
                []
            ],
            o = Math.sqrt,
            s = Math.atan2;
        return e
    }), e("zrender/graphic/Displayable", [me, "../core/util", "./Style", "../Element", "./mixin/RectText"], function (t) {
        function e(t) {
            t = t || {}, r.call(this, t);
            for (var e in t) t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
            this.style = new n(t.style), this._rect = null, this.__clipPaths = []
        }
        var i = t("../core/util"),
            n = t("./Style"),
            r = t("../Element"),
            a = t("./mixin/RectText");
        return e[he] = {
            constructor: e,
            type: "displayable",
            __dirty: !0,
            invisible: !1,
            z: 0,
            z2: 0,
            zlevel: 0,
            draggable: !1,
            dragging: !1,
            silent: !1,
            culling: !1,
            cursor: "pointer",
            rectHover: !1,
            progressive: -1,
            beforeBrush: function () { },
            afterBrush: function () { },
            brush: function () { },
            getBoundingRect: function () { },
            contain: function (t, e) {
                return this.rectContain(t, e)
            },
            traverse: function (t, e) {
                t.call(e, this)
            },
            rectContain: function (t, e) {
                var i = this.transformCoordToLocal(t, e),
                    n = this[S]();
                return n[x](i[0], i[1])
            },
            dirty: function () {
                this.__dirty = !0, this._rect = null, this.__zr && this.__zr.refresh()
            },
            animateStyle: function (t) {
                return this.animate("style", t)
            },
            attrKV: function (t, e) {
                "style" !== t ? r[he].attrKV.call(this, t, e) : this.style.set(e)
            },
            setStyle: function (t, e) {
                return this.style.set(t, e), this.dirty(!1), this
            },
            useStyle: function (t) {
                return this.style = new n(t), this.dirty(!1), this
            }
        }, i.inherits(e, r), i.mixin(e, a), e
    }), e("zrender/contain/path", [me, "../core/PathProxy", "./line", "./cubic", "./quadratic", "./arc", "./util", "../core/curve", "./windingLine"], function (t) {
        function e(t, e) {
            return Math.abs(t - e) < g
        }

        function i() {
            var t = _[0];
            _[0] = _[1], _[1] = t
        }

        function n(t, e, n, r, a, o, s, l, u, c) {
            if (c > e && c > r && c > o && c > l || e > c && r > c && o > c && l > c) return 0;
            var h = d.cubicRootAt(e, r, o, l, c, y);
            if (0 === h) return 0;
            for (var f, p, m = 0, v = -1, g = 0; h > g; g++) {
                var x = y[g],
                    b = 0 === x || 1 === x ? .5 : 1,
                    w = d.cubicAt(t, n, a, s, x);
                u > w || (0 > v && (v = d.cubicExtrema(e, r, o, l, _), _[1] < _[0] && v > 1 && i(), f = d.cubicAt(e, r, o, l, _[0]), v > 1 && (p = d.cubicAt(e, r, o, l, _[1]))), m += 2 == v ? x < _[0] ? e > f ? b : -b : x < _[1] ? f > p ? b : -b : p > l ? b : -b : x < _[0] ? e > f ? b : -b : f > l ? b : -b)
            }
            return m
        }

        function r(t, e, i, n, r, a, o, s) {
            if (s > e && s > n && s > a || e > s && n > s && a > s) return 0;
            var l = d.quadraticRootAt(e, n, a, s, y);
            if (0 === l) return 0;
            var u = d.quadraticExtremum(e, n, a);
            if (u >= 0 && 1 >= u) {
                for (var c = 0, h = d.quadraticAt(e, n, a, u), f = 0; l > f; f++) {
                    var p = 0 === y[f] || 1 === y[f] ? .5 : 1,
                        m = d.quadraticAt(t, i, r, y[f]);
                    o > m || (c += y[f] < u ? e > h ? p : -p : h > a ? p : -p)
                }
                return c
            }
            var p = 0 === y[0] || 1 === y[0] ? .5 : 1,
                m = d.quadraticAt(t, i, r, y[0]);
            return o > m ? 0 : e > a ? p : -p
        }

        function a(t, e, i, n, r, a, o, s) {
            if (s -= e, s > i || -i > s) return 0;
            var l = Math.sqrt(i * i - s * s);
            y[0] = -l, y[1] = l;
            var u = Math.abs(n - r);
            if (1e-4 > u) return 0;
            if (1e-4 > u % v) {
                n = 0, r = v;
                var c = a ? 1 : -1;
                return o >= y[0] + t && o <= y[1] + t ? c : 0
            }
            if (a) {
                var l = n;
                n = f(r), r = f(l)
            } else n = f(n), r = f(r);
            n > r && (r += v);
            for (var h = 0, d = 0; 2 > d; d++) {
                var p = y[d];
                if (p + t > o) {
                    var m = Math.atan2(s, p),
                        c = a ? 1 : -1;
                    0 > m && (m = v + m), (m >= n && r >= m || m + v >= n && r >= m + v) && (m > Math.PI / 2 && m < 1.5 * Math.PI && (c = -c), h += c)
                }
            }
            return h
        }

        function o(t, i, o, l, f) {
            for (var d = 0, v = 0, g = 0, y = 0, _ = 0, x = 0; x < t[te];) {
                var b = t[x++];
                switch (b === s.M && x > 1 && (o || (d += p(v, g, y, _, l, f))), 1 == x && (v = t[x], g = t[x + 1], y = v, _ = g), b) {
                    case s.M:
                        y = t[x++], _ = t[x++], v = y, g = _;
                        break;
                    case s.L:
                        if (o) {
                            if (m(v, g, t[x], t[x + 1], i, l, f)) return !0
                        } else d += p(v, g, t[x], t[x + 1], l, f) || 0;
                        v = t[x++], g = t[x++];
                        break;
                    case s.C:
                        if (o) {
                            if (u.containStroke(v, g, t[x++], t[x++], t[x++], t[x++], t[x], t[x + 1], i, l, f)) return !0
                        } else d += n(v, g, t[x++], t[x++], t[x++], t[x++], t[x], t[x + 1], l, f) || 0;
                        v = t[x++], g = t[x++];
                        break;
                    case s.Q:
                        if (o) {
                            if (c.containStroke(v, g, t[x++], t[x++], t[x], t[x + 1], i, l, f)) return !0
                        } else d += r(v, g, t[x++], t[x++], t[x], t[x + 1], l, f) || 0;
                        v = t[x++], g = t[x++];
                        break;
                    case s.A:
                        var w = t[x++],
                            M = t[x++],
                            T = t[x++],
                            S = t[x++],
                            C = t[x++],
                            A = t[x++],
                            P = (t[x++], 1 - t[x++]),
                            k = Math.cos(C) * T + w,
                            L = Math.sin(C) * S + M;
                        x > 1 ? d += p(v, g, k, L, l, f) : (y = k, _ = L);
                        var z = (l - w) * S / T + w;
                        if (o) {
                            if (h.containStroke(w, M, S, C, C + A, P, i, z, f)) return !0
                        } else d += a(w, M, S, C, C + A, P, z, f);
                        v = Math.cos(C + A) * T + w, g = Math.sin(C + A) * S + M;
                        break;
                    case s.R:
                        y = v = t[x++], _ = g = t[x++];
                        var I = t[x++],
                            D = t[x++],
                            k = y + I,
                            L = _ + D;
                        if (o) {
                            if (m(y, _, k, _, i, l, f) || m(k, _, k, L, i, l, f) || m(k, L, y, L, i, l, f) || m(y, L, y, _, i, l, f)) return !0
                        } else d += p(k, _, k, L, l, f), d += p(y, L, y, _, l, f);
                        break;
                    case s.Z:
                        if (o) {
                            if (m(v, g, y, _, i, l, f)) return !0
                        } else d += p(v, g, y, _, l, f);
                        v = y, g = _
                }
            }
            return o || e(g, _) || (d += p(v, g, y, _, l, f) || 0), 0 !== d
        }
        var s = t("../core/PathProxy").CMD,
            l = t("./line"),
            u = t("./cubic"),
            c = t("./quadratic"),
            h = t("./arc"),
            f = t("./util").normalizeRadian,
            d = t("../core/curve"),
            p = t("./windingLine"),
            m = l.containStroke,
            v = 2 * Math.PI,
            g = 1e-4,
            y = [-1, -1, -1],
            _ = [-1, -1];
        return {
            contain: function (t, e, i) {
                return o(t, 0, !1, e, i)
            },
            containStroke: function (t, e, i, n) {
                return o(t, e, !0, i, n)
            }
        }
    }), e("zrender/graphic/Pattern", [me], function () {
        var t = function (t, e) {
            this.image = t, this.repeat = e, this.type = "pattern"
        };
        return t[he].getCanvasPattern = function (t) {
            return this._canvasPattern || (this._canvasPattern = t.createPattern(this.image, this.repeat))
        }, t
    }), e("echarts/scale/Ordinal", [me, de, "./Scale"], function (t) {
        var e = t(de),
            i = t("./Scale"),
            n = i[he],
            r = i[H]({
                type: "ordinal",
                init: function (t, e) {
                    this._data = t, this._extent = e || [0, t[te] - 1]
                },
                parse: function (t) {
                    return typeof t === ce ? e[J](this._data, t) : Math.round(t)
                },
                contain: function (t) {
                    return t = this.parse(t), n[x].call(this, t) && null != this._data[t]
                },
                normalize: function (t) {
                    return n.normalize.call(this, this.parse(t))
                },
                scale: function (t) {
                    return Math.round(n.scale.call(this, t))
                },
                getTicks: function () {
                    for (var t = [], e = this._extent, i = e[0]; i <= e[1];) t.push(i), i++;
                    return t
                },
                getLabel: function (t) {
                    return this._data[t]
                },
                count: function () {
                    return this._extent[1] - this._extent[0] + 1
                },
                unionExtentFromData: function (t, e) {
                    this.unionExtent(t.getDataExtent(e, !1))
                },
                niceTicks: e.noop,
                niceExtent: e.noop
            });
        return r[X] = function () {
            return new r
        }, r
    }), e("echarts/model/mixin/makeStyleMapper", [me, de], function (t) {
        var e = t(de);
        return function (t) {
            for (var i = 0; i < t[te]; i++) t[i][1] || (t[i][1] = t[i][0]);
            return function (i) {
                for (var n = {}, r = 0; r < t[te]; r++) {
                    var a = t[r][1];
                    if (!(i && e[J](i, a) >= 0)) {
                        var o = this[d](a);
                        null != o && (n[t[r][0]] = o)
                    }
                }
                return n
            }
        }
    }), e("zrender/graphic/Style", [me], function () {
        function t(t, e, i) {
            var n = e.x,
                r = e.x2,
                a = e.y,
                o = e.y2;
            e.global || (n = n * i.width + i.x, r = r * i.width + i.x, a = a * i[ue] + i.y, o = o * i[ue] + i.y);
            var s = t.createLinearGradient(n, a, r, o);
            return s
        }

        function e(t, e, i) {
            var n = i.width,
                r = i[ue],
                a = Math.min(n, r),
                o = e.x,
                s = e.y,
                l = e.r;
            e.global || (o = o * n + i.x, s = s * r + i.y, l *= a);
            var u = t.createRadialGradient(o, s, 0, o, s, l);
            return u
        }
        var i = [
            ["shadowBlur", 0],
            ["shadowOffsetX", 0],
            ["shadowOffsetY", 0],
            ["shadowColor", "#000"],
            ["lineCap", "butt"],
            ["lineJoin", "miter"],
            ["miterLimit", 10]
        ],
            n = function (t) {
                this.extendFrom(t)
            };
        n[he] = {
            constructor: n,
            fill: "#000000",
            stroke: null,
            opacity: 1,
            lineDash: null,
            lineDashOffset: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            lineWidth: 1,
            strokeNoScale: !1,
            text: null,
            textFill: "#000",
            textStroke: null,
            textPosition: "inside",
            textOffset: null,
            textBaseline: null,
            textAlign: null,
            textVerticalAlign: null,
            textDistance: 5,
            textShadowBlur: 0,
            textShadowOffsetX: 0,
            textShadowOffsetY: 0,
            textTransform: !1,
            textRotation: 0,
            blend: null,
            bind: function (t, e, n) {
                for (var r = this, a = n && n.style, o = !a, s = 0; s < i[te]; s++) {
                    var l = i[s],
                        c = l[0];
                    (o || r[c] !== a[c]) && (t[c] = r[c] || l[1])
                }
                if ((o || r.fill !== a.fill) && (t.fillStyle = r.fill), (o || r[u] !== a[u]) && (t.strokeStyle = r[u]), (o || r[b] !== a[b]) && (t.globalAlpha = null == r[b] ? 1 : r[b]), (o || r.blend !== a.blend) && (t.globalCompositeOperation = r.blend || "source-over"), this.hasStroke()) {
                    var h = r.lineWidth;
                    t.lineWidth = h / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1)
                }
            },
            hasFill: function () {
                var t = this.fill;
                return null != t && "none" !== t
            },
            hasStroke: function () {
                var t = this[u];
                return null != t && "none" !== t && this.lineWidth > 0
            },
            extendFrom: function (t, e) {
                if (t) {
                    var i = this;
                    for (var n in t) !t.hasOwnProperty(n) || !e && i.hasOwnProperty(n) || (i[n] = t[n])
                }
            },
            set: function (t, e) {
                typeof t === ce ? this[t] = e : this.extendFrom(t, !0)
            },
            clone: function () {
                var t = new this.constructor;
                return t.extendFrom(this, !0), t
            },
            getGradient: function (i, n, r) {
                for (var a = "radial" === n.type ? e : t, o = a(i, n, r), s = n[j], l = 0; l < s[te]; l++) o.addColorStop(s[l].offset, s[l].color);
                return o
            }
        };
        for (var r = n[he], a = 0; a < i[te]; a++) {
            var o = i[a];
            o[0] in r || (r[o[0]] = o[1])
        }
        return n.getGradient = r.getGradient, n
    }), e("zrender/Element", [me, "./core/guid", "./mixin/Eventful", "./mixin/Transformable", "./mixin/Animatable", "./core/util"], function (t) {
        var e = t("./core/guid"),
            i = t("./mixin/Eventful"),
            n = t("./mixin/Transformable"),
            r = t("./mixin/Animatable"),
            a = t("./core/util"),
            o = function (t) {
                n.call(this, t), i.call(this, t), r.call(this, t), this.id = t.id || e()
            };
        return o[he] = {
            type: "element",
            name: "",
            __zr: null,
            ignore: !1,
            clipPath: null,
            drift: function (t, e) {
                switch (this.draggable) {
                    case "horizontal":
                        e = 0;
                        break;
                    case "vertical":
                        t = 0
                }
                var i = this.transform;
                i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty(!1)
            },
            beforeUpdate: function () { },
            afterUpdate: function () { },
            update: function () {
                this.updateTransform()
            },
            traverse: function () { },
            attrKV: function (t, e) {
                if (t === w || "scale" === t || "origin" === t) {
                    if (e) {
                        var i = this[t];
                        i || (i = this[t] = []), i[0] = e[0], i[1] = e[1]
                    }
                } else this[t] = e
            },
            hide: function () {
                this[ie] = !0, this.__zr && this.__zr.refresh()
            },
            show: function () {
                this[ie] = !1, this.__zr && this.__zr.refresh()
            },
            attr: function (t, e) {
                if (typeof t === ce) this.attrKV(t, e);
                else if (a[oe](t))
                    for (var i in t) t.hasOwnProperty(i) && this.attrKV(i, t[i]);
                return this.dirty(!1), this
            },
            setClipPath: function (t) {
                var e = this.__zr;
                e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1)
            },
            removeClipPath: function () {
                var t = this.clipPath;
                t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1))
            },
            addSelfToZr: function (t) {
                this.__zr = t;
                var e = this.animators;
                if (e)
                    for (var i = 0; i < e[te]; i++) t[le].addAnimator(e[i]);
                this.clipPath && this.clipPath.addSelfToZr(t)
            },
            removeSelfFromZr: function (t) {
                this.__zr = null;
                var e = this.animators;
                if (e)
                    for (var i = 0; i < e[te]; i++) t[le].removeAnimator(e[i]);
                this.clipPath && this.clipPath.removeSelfFromZr(t)
            }
        }, a.mixin(o, r), a.mixin(o, n), a.mixin(o, i), o
    }), e("zrender/graphic/mixin/RectText", [me, "../../contain/text", "../../core/BoundingRect"], function (t) {
        function e(t, e) {
            return typeof t === ce ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
        }
        var i = t("../../contain/text"),
            n = t("../../core/BoundingRect"),
            r = new n,
            a = function () { };
        return a[he] = {
            constructor: a,
            drawRectText: function (t, n, a) {
                var o = this.style,
                    s = o.text;
                if (null != s && (s += ""), s) {
                    t.save();
                    var l, u, h = o.textPosition,
                        f = o.textOffset,
                        d = o.textDistance,
                        p = o.textAlign,
                        m = o.textFont || o.font,
                        v = o.textBaseline,
                        g = o.textVerticalAlign;
                    a = a || i[S](s, m, p, v);
                    var y = this.transform;
                    if (o.textTransform ? this.setTransform(t) : y && (r.copy(n), r[c](y), n = r), h instanceof Array) {
                        if (l = n.x + e(h[0], n.width), u = n.y + e(h[1], n[ue]), p = p || "left", v = v || "top", g) {
                            switch (g) {
                                case T:
                                    u -= a[ue] / 2 - a.lineHeight / 2;
                                    break;
                                case ee:
                                    u -= a[ue] - a.lineHeight / 2;
                                    break;
                                default:
                                    u += a.lineHeight / 2
                            }
                            v = T
                        }
                    } else {
                        var _ = i.adjustTextPositionOnRect(h, n, a, d);
                        l = _.x, u = _.y, p = p || _.textAlign, v = v || _.textBaseline
                    }
                    f && (l += f[0], u += f[1]), t.textAlign = p || "left", t.textBaseline = v || "alphabetic";
                    var x = o.textFill,
                        b = o.textStroke;
                    x && (t.fillStyle = x), b && (t.strokeStyle = b), t.font = m || "12px sans-serif", t.shadowBlur = o.textShadowBlur, t.shadowColor = o.textShadowColor || "transparent", t.shadowOffsetX = o.textShadowOffsetX, t.shadowOffsetY = o.textShadowOffsetY;
                    var w = s.split("\n");
                    o.textRotation && (y && t.translate(y[4], y[5]), t.rotate(o.textRotation), y && t.translate(-y[4], -y[5]));
                    for (var M = 0; M < w[te]; M++) x && t.fillText(w[M], l, u), b && t.strokeText(w[M], l, u), u += a.lineHeight;
                    t.restore()
                }
            }
        }, a
    }), e("echarts/coord/cartesian/Cartesian", [me, de], function (t) {
        function e(t) {
            return this._axes[t]
        }
        var i = t(de),
            n = function (t) {
                this._axes = {}, this._dimList = [], this.name = t || ""
            };
        return n[he] = {
            constructor: n,
            type: "cartesian",
            getAxis: function (t) {
                return this._axes[t]
            },
            getAxes: function () {
                return i.map(this._dimList, e, this)
            },
            getAxesByScale: function (t) {
                return t = t[fe](), i.filter(this.getAxes(), function (e) {
                    return e.scale.type === t
                })
            },
            addAxis: function (t) {
                var e = t.dim;
                this._axes[e] = t, this._dimList.push(e)
            },
            dataToCoord: function (t) {
                return this._dataCoordConvert(t, "dataToCoord")
            },
            coordToData: function (t) {
                return this._dataCoordConvert(t, "coordToData")
            },
            _dataCoordConvert: function (t, e) {
                for (var i = this._dimList, n = t instanceof Array ? [] : {}, r = 0; r < i[te]; r++) {
                    var a = i[r],
                        o = this._axes[a];
                    n[a] = o[e](t[a])
                }
                return n
            }
        }, n
    }), e("echarts/util/component", [me, de, "./clazz"], function (t) {
        var e = t(de),
            i = t("./clazz"),
            n = i.parseClassType,
            r = 0,
            a = {},
            o = "_";
        return a.getUID = function (t) {
            return [t || "", r++, Math.random()].join(o)
        }, a.enableSubTypeDefaulter = function (t) {
            var e = {};
            return t.registerSubTypeDefaulter = function (t, i) {
                t = n(t), e[t.main] = i
            }, t.determineSubType = function (i, r) {
                var a = r.type;
                if (!a) {
                    var o = n(i).main;
                    t.hasSubTypes(i) && e[o] && (a = e[o](r))
                }
                return a
            }, t
        }, a.enableTopologicalTravel = function (t, i) {
            function n(t) {
                var n = {},
                    o = [];
                return e.each(t, function (s) {
                    var l = r(n, s),
                        u = l.originalDeps = i(s),
                        c = a(u, t);
                    l.entryCount = c[te], 0 === l.entryCount && o.push(s), e.each(c, function (t) {
                        e[J](l.predecessor, t) < 0 && l.predecessor.push(t);
                        var i = r(n, t);
                        e[J](i.successor, t) < 0 && i.successor.push(s)
                    })
                }), {
                    graph: n,
                    noEntryList: o
                }
            }

            function r(t, e) {
                return t[e] || (t[e] = {
                    predecessor: [],
                    successor: []
                }), t[e]
            }

            function a(t, i) {
                var n = [];
                return e.each(t, function (t) {
                    e[J](i, t) >= 0 && n.push(t)
                }), n
            }
            t.topologicalTravel = function (t, i, r, a) {
                function o(t) {
                    u[t].entryCount--, 0 === u[t].entryCount && c.push(t)
                }

                function s(t) {
                    h[t] = !0, o(t)
                }
                if (t[te]) {
                    var l = n(i),
                        u = l.graph,
                        c = l.noEntryList,
                        h = {};
                    for (e.each(t, function (t) {
                        h[t] = !0
                    }); c[te];) {
                        var f = c.pop(),
                            d = u[f],
                            p = !!h[f];
                        p && (r.call(a, f, d.originalDeps.slice()), delete h[f]), e.each(d.successor, p ? s : o)
                    }
                    e.each(h, function () {
                        throw new Error("Circle dependency may exists")
                    })
                }
            }
        }, a
    }), e("echarts/model/mixin/boxLayout", [me], function () {
        return {
            getBoxLayoutParams: function () {
                return {
                    left: this.get("left"),
                    top: this.get("top"),
                    right: this.get("right"),
                    bottom: this.get(ee),
                    width: this.get("width"),
                    height: this.get(ue)
                }
            }
        }
    }), e("zrender/core/guid", [], function () {
        var t = 2311;
        return function () {
            return t++
        }
    }), e("zrender/mixin/Transformable", [me, "../core/matrix", "../core/vector"], function (t) {
        function e(t) {
            return t > a || -a > t
        }
        var i = t("../core/matrix"),
            n = t("../core/vector"),
            r = i.identity,
            a = 5e-5,
            o = function (t) {
                t = t || {}, t[w] || (this[w] = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null
            },
            s = o[he];
        s.transform = null, s.needLocalTransform = function () {
            return e(this.rotation) || e(this[w][0]) || e(this[w][1]) || e(this.scale[0] - 1) || e(this.scale[1] - 1)
        }, s.updateTransform = function () {
            var t = this[l],
                e = t && t.transform,
                n = this.needLocalTransform(),
                a = this.transform;
            return n || e ? (a = a || i[X](), n ? this.getLocalTransform(a) : r(a), e && (n ? i.mul(a, t.transform, a) : i.copy(a, t.transform)), this.transform = a, this.invTransform = this.invTransform || i[X](), void i.invert(this.invTransform, a)) : void (a && r(a))
        }, s.getLocalTransform = function (t) {
            t = t || [], r(t);
            var e = this.origin,
                n = this.scale,
                a = this.rotation,
                o = this[w];
            return e && (t[4] -= e[0], t[5] -= e[1]), i.scale(t, t, n), a && i.rotate(t, t, a), e && (t[4] += e[0], t[5] += e[1]), t[4] += o[0], t[5] += o[1], t
        }, s.setTransform = function (t) {
            var e = this.transform,
                i = t.dpr || 1;
            e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0)
        }, s.restoreTransform = function (t) {
            var e = (this.transform, t.dpr || 1);
            t.setTransform(e, 0, 0, e, 0, 0)
        };
        var u = [];
        return s.decomposeTransform = function () {
            if (this.transform) {
                var t = this[l],
                    n = this.transform;
                t && t.transform && (i.mul(u, t.invTransform, n), n = u);
                var r = n[0] * n[0] + n[1] * n[1],
                    a = n[2] * n[2] + n[3] * n[3],
                    o = this[w],
                    s = this.scale;
                e(r - 1) && (r = Math.sqrt(r)), e(a - 1) && (a = Math.sqrt(a)), n[0] < 0 && (r = -r), n[3] < 0 && (a = -a), o[0] = n[4], o[1] = n[5], s[0] = r, s[1] = a, this.rotation = Math.atan2(-n[1] / a, n[0] / r)
            }
        }, s.getGlobalScale = function () {
            var t = this.transform;
            if (!t) return [1, 1];
            var e = Math.sqrt(t[0] * t[0] + t[1] * t[1]),
                i = Math.sqrt(t[2] * t[2] + t[3] * t[3]);
            return t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), [e, i]
        }, s.transformCoordToLocal = function (t, e) {
            var i = [t, e],
                r = this.invTransform;
            return r && n[c](i, i, r), i
        }, s.transformCoordToGlobal = function (t, e) {
            var i = [t, e],
                r = this.transform;
            return r && n[c](i, i, r), i
        }, o
    }), e("zrender/mixin/Animatable", [me, "../animation/Animator", "../core/util", "../core/log"], function (t) {
        var e = t("../animation/Animator"),
            i = t("../core/util"),
            n = i.isString,
            r = i.isFunction,
            a = i[oe],
            o = t("../core/log"),
            s = function () {
                this.animators = []
            };
        return s[he] = {
            constructor: s,
            animate: function (t, n) {
                var r, a = !1,
                    s = this,
                    l = this.__zr;
                if (t) {
                    var u = t.split("."),
                        c = s;
                    a = "shape" === u[0];
                    for (var h = 0, f = u[te]; f > h; h++) c && (c = c[u[h]]);
                    c && (r = c)
                } else r = s;
                if (!r) return void o('Property "' + t + '" is not existed in element ' + s.id);
                var d = s.animators,
                    p = new e(r, n);
                return p.during(function () {
                    s.dirty(a)
                }).done(function () {
                    d[F](i[J](d, p), 1)
                }), d.push(p), l && l[le].addAnimator(p), p
            },
            stopAnimation: function (t) {
                for (var e = this.animators, i = e[te], n = 0; i > n; n++) e[n].stop(t);
                return e[te] = 0, this
            },
            animateTo: function (t, e, i, a, o) {
                function s() {
                    u--, u || o && o()
                }
                n(i) ? (o = a, a = i, i = 0) : r(a) ? (o = a, a = "linear", i = 0) : r(i) ? (o = i, i = 0) : r(e) ? (o = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow("", this, t, e, i, a, o);
                var l = this.animators.slice(),
                    u = l[te];
                u || o && o();
                for (var c = 0; c < l[te]; c++) l[c].done(s).start(a)
            },
            _animateToShallow: function (t, e, n, r, o) {
                var s = {},
                    l = 0;
                for (var u in n)
                    if (n.hasOwnProperty(u))
                        if (null != e[u]) a(n[u]) && !i.isArrayLike(n[u]) ? this._animateToShallow(t ? t + "." + u : u, e[u], n[u], r, o) : (s[u] = n[u], l++);
                        else if (null != n[u])
                            if (t) {
                                var c = {};
                                c[t] = {}, c[t][u] = n[u], this.attr(c)
                            } else this.attr(u, n[u]);
                return l > 0 && this.animate(t, !1).when(null == r ? 500 : r, s).delay(o || 0), this
            }
        }, s
    }), e("echarts/coord/Axis", [me, "../util/number", de], function (t) {
        function e(t, e) {
            var i = t[1] - t[0],
                n = e,
                r = i / n / 2;
            t[0] += r, t[1] -= r
        }
        var i = t("../util/number"),
            n = i.linearMap,
            r = t(de),
            a = [0, 1],
            o = function (t, e, i) {
                this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1
            };
        return o[he] = {
            constructor: o,
            contain: function (t) {
                var e = this._extent,
                    i = Math.min(e[0], e[1]),
                    n = Math.max(e[0], e[1]);
                return t >= i && n >= t
            },
            containData: function (t) {
                return this[x](this.dataToCoord(t))
            },
            getExtent: function () {
                var t = this._extent.slice();
                return t
            },
            getPixelPrecision: function (t) {
                return i.getPixelPrecision(t || this.scale[_](), this._extent)
            },
            setExtent: function (t, e) {
                var i = this._extent;
                i[0] = t, i[1] = e
            },
            dataToCoord: function (t, i) {
                var r = this._extent,
                    o = this.scale;
                return t = o.normalize(t), this.onBand && o.type === p && (r = r.slice(), e(r, o.count())), n(t, a, r, i)
            },
            coordToData: function (t, i) {
                var r = this._extent,
                    o = this.scale;
                this.onBand && o.type === p && (r = r.slice(), e(r, o.count()));
                var s = n(t, r, a, i);
                return this.scale.scale(s)
            },
            getTicksCoords: function (t) {
                if (this.onBand && !t) {
                    for (var e = this.getBands(), i = [], n = 0; n < e[te]; n++) i.push(e[n][0]);
                    return e[n - 1] && i.push(e[n - 1][1]), i
                }
                return r.map(this.scale[y](), this.dataToCoord, this)
            },
            getLabelsCoords: function () {
                return r.map(this.scale[y](), this.dataToCoord, this)
            },
            getBands: function () {
                for (var t = this[_](), e = [], i = this.scale.count(), n = t[0], r = t[1], a = r - n, o = 0; i > o; o++) e.push([a * o / i + n, a * (o + 1) / i + n]);
                return e
            },
            getBandWidth: function () {
                var t = this._extent,
                    e = this.scale[_](),
                    i = e[1] - e[0] + (this.onBand ? 1 : 0);
                0 === i && (i = 1);
                var n = Math.abs(t[1] - t[0]);
                return Math.abs(n) / i
            },
            isBlank: function () {
                return this._isBlank
            },
            setBlank: function (t) {
                this._isBlank = t
            }
        }, o
    }), e("echarts/coord/cartesian/axisLabelInterval", [me, de, "../axisHelper"], function (t) {
        var e = t(de),
            i = t("../axisHelper");
        return function (t) {
            var n = t.model,
                r = n[ae]("axisLabel"),
                a = r.get("interval");
            return "category" !== t.type || "auto" !== a ? "auto" === a ? 0 : a : i.getAxisLabelInterval(e.map(t.scale[y](), t.dataToCoord, t), n.getFormattedLabels(), r[ae](A)[C](), t.isHorizontal())
        }
    }), e("echarts/chart/gauge/PointerPath", [me, "zrender/graphic/Path"], function (t) {
        return t("zrender/graphic/Path")[H]({
            type: "echartsGaugePointer",
            shape: {
                angle: 0,
                width: 10,
                r: 10,
                x: 0,
                y: 0
            },
            buildPath: function (t, e) {
                var n = Math.cos,
                    r = Math.sin,
                    a = e.r,
                    o = e.width,
                    s = e.angle,
                    l = e.x - n(s) * o * (o >= a / 3 ? 1 : 2),
                    u = e.y - r(s) * o * (o >= a / 3 ? 1 : 2);
                s = e.angle - Math.PI / 2, t[i](l, u), t.lineTo(e.x + n(s) * o, e.y + r(s) * o), t.lineTo(e.x + n(e.angle) * a, e.y + r(e.angle) * a), t.lineTo(e.x - n(s) * o, e.y - r(s) * o), t.lineTo(l, u)
            }
        })
    }), e("zrender/animation/Animator", [me, "./Clip", "../tool/color", "../core/util"], function (t) {
        function e(t, e) {
            return t[e]
        }

        function i(t, e, i) {
            t[e] = i
        }

        function n(t, e, i) {
            return (e - t) * i + t
        }

        function r(t, e, i) {
            return i > .5 ? e : t
        }

        function a(t, e, i, r, a) {
            var o = t[te];
            if (1 == a)
                for (var s = 0; o > s; s++) r[s] = n(t[s], e[s], i);
            else
                for (var l = t[0][te], s = 0; o > s; s++)
                    for (var u = 0; l > u; u++) r[s][u] = n(t[s][u], e[s][u], i)
        }

        function o(t, e, i) {
            var n = t[te],
                r = e[te];
            if (n !== r) {
                var a = n > r;
                if (a) t[te] = r;
                else
                    for (var o = n; r > o; o++) t.push(1 === i ? e[o] : g.call(e[o]))
            }
            for (var s = t[0] && t[0][te], o = 0; o < t[te]; o++)
                if (1 === i) isNaN(t[o]) && (t[o] = e[o]);
                else
                    for (var l = 0; s > l; l++) isNaN(t[o][l]) && (t[o][l] = e[o][l])
        }

        function s(t, e, i) {
            if (t === e) return !0;
            var n = t[te];
            if (n !== e[te]) return !1;
            if (1 === i) {
                for (var r = 0; n > r; r++)
                    if (t[r] !== e[r]) return !1
            } else
                for (var a = t[0][te], r = 0; n > r; r++)
                    for (var o = 0; a > o; o++)
                        if (t[r][o] !== e[r][o]) return !1;
            return !0
        }

        function l(t, e, i, n, r, a, o, s, l) {
            var c = t[te];
            if (1 == l)
                for (var h = 0; c > h; h++) s[h] = u(t[h], e[h], i[h], n[h], r, a, o);
            else
                for (var f = t[0][te], h = 0; c > h; h++)
                    for (var d = 0; f > d; d++) s[h][d] = u(t[h][d], e[h][d], i[h][d], n[h][d], r, a, o)
        }

        function u(t, e, i, n, r, a, o) {
            var s = .5 * (i - t),
                l = .5 * (n - e);
            return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
        }

        function c(t) {
            if (v(t)) {
                var e = t[te];
                if (v(t[0])) {
                    for (var i = [], n = 0; e > n; n++) i.push(g.call(t[n]));
                    return i
                }
                return g.call(t)
            }
            return t
        }

        function h(t) {
            return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")"
        }

        function f(t, e, i, c, f) {
            var m = t._getter,
                g = t._setter,
                y = "spline" === e,
                _ = c[te];
            if (_) {
                var x, b = c[0].value,
                    w = v(b),
                    M = !1,
                    T = !1,
                    S = w && v(b[0]) ? 2 : 1;
                c.sort(function (t, e) {
                    return t.time - e.time
                }), x = c[_ - 1].time;
                for (var C = [], A = [], P = c[0].value, k = !0, L = 0; _ > L; L++) {
                    C.push(c[L].time / x);
                    var z = c[L].value;
                    if (w && s(z, P, S) || !w && z === P || (k = !1), P = z, typeof z == ce) {
                        var I = p.parse(z);
                        I ? (z = I, M = !0) : T = !0
                    }
                    A.push(z)
                }
                if (!k) {
                    for (var D = A[_ - 1], L = 0; _ - 1 > L; L++) w ? o(A[L], D, S) : !isNaN(A[L]) || isNaN(D) || T || M || (A[L] = D);
                    w && o(m(t._target, f), D, S);
                    var O, B, E, R, N, F, G = 0,
                        V = 0;
                    if (M) var H = [0, 0, 0, 0];
                    var q = function (t, e) {
                        var i;
                        if (0 > e) i = 0;
                        else if (V > e) {
                            for (O = Math.min(G + 1, _ - 1), i = O; i >= 0 && !(C[i] <= e); i--);
                            i = Math.min(i, _ - 2)
                        } else {
                            for (i = G; _ > i && !(C[i] > e); i++);
                            i = Math.min(i - 1, _ - 2)
                        }
                        G = i, V = e;
                        var o = C[i + 1] - C[i];
                        if (0 !== o)
                            if (B = (e - C[i]) / o, y)
                                if (R = A[i], E = A[0 === i ? i : i - 1], N = A[i > _ - 2 ? _ - 1 : i + 1], F = A[i > _ - 3 ? _ - 1 : i + 2], w) l(E, R, N, F, B, B * B, B * B * B, m(t, f), S);
                                else {
                                    var s;
                                    if (M) s = l(E, R, N, F, B, B * B, B * B * B, H, 1), s = h(H);
                                    else {
                                        if (T) return r(R, N, B);
                                        s = u(E, R, N, F, B, B * B, B * B * B)
                                    }
                                    g(t, f, s)
                                }
                            else if (w) a(A[i], A[i + 1], B, m(t, f), S);
                            else {
                                var s;
                                if (M) a(A[i], A[i + 1], B, H, 1), s = h(H);
                                else {
                                    if (T) return r(A[i], A[i + 1], B);
                                    s = n(A[i], A[i + 1], B)
                                }
                                g(t, f, s)
                            }
                    },
                        W = new d({
                            target: t._target,
                            life: x,
                            loop: t._loop,
                            delay: t._delay,
                            onframe: q,
                            ondestroy: i
                        });
                    return e && "spline" !== e && (W.easing = e), W
                }
            }
        }
        var d = t("./Clip"),
            p = t("../tool/color"),
            m = t("../core/util"),
            v = m.isArrayLike,
            g = Array[he].slice,
            y = function (t, n, r, a) {
                this._tracks = {}, this._target = t, this._loop = n || !1, this._getter = r || e, this._setter = a || i, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = []
            };
        return y[he] = {
            when: function (t, e) {
                var i = this._tracks;
                for (var n in e)
                    if (e.hasOwnProperty(n)) {
                        if (!i[n]) {
                            i[n] = [];
                            var r = this._getter(this._target, n);
                            if (null == r) continue;
                            0 !== t && i[n].push({
                                time: 0,
                                value: c(r)
                            })
                        }
                        i[n].push({
                            time: t,
                            value: e[n]
                        })
                    } return this
            },
            during: function (t) {
                return this._onframeList.push(t), this
            },
            _doneCallback: function () {
                this._tracks = {}, this._clipList[te] = 0;
                for (var t = this._doneList, e = t[te], i = 0; e > i; i++) t[i].call(this)
            },
            start: function (t) {
                var e, i = this,
                    n = 0,
                    r = function () {
                        n--, n || i._doneCallback()
                    };
                for (var a in this._tracks)
                    if (this._tracks.hasOwnProperty(a)) {
                        var o = f(this, t, r, this._tracks[a], a);
                        o && (this._clipList.push(o), n++, this[le] && this[le].addClip(o), e = o)
                    } if (e) {
                        var s = e.onframe;
                        e.onframe = function (t, e) {
                            s(t, e);
                            for (var n = 0; n < i._onframeList[te]; n++) i._onframeList[n](t, e)
                        }
                    }
                return n || this._doneCallback(), this
            },
            stop: function (t) {
                for (var e = this._clipList, i = this[le], n = 0; n < e[te]; n++) {
                    var r = e[n];
                    t && r.onframe(this._target, 1), i && i.removeClip(r)
                }
                e[te] = 0
            },
            delay: function (t) {
                return this._delay = t, this
            },
            done: function (t) {
                return t && this._doneList.push(t), this
            },
            getClips: function () {
                return this._clipList
            }
        }, y
    }), e("zrender/core/log", [me, "../config"], function (t) {
        var e = t("../config");
        return function () {
            if (0 !== e.debugMode)
                if (1 == e.debugMode)
                    for (var t in arguments) throw new Error(arguments[t]);
                else if (e.debugMode > 1)
                    for (var t in arguments) console.log(arguments[t])
        }
    }), e("echarts/coord/cartesian/AxisModel", [me, "../../model/Component", de, "../axisModelCreator", "../axisModelCommonMixin"], function (t) {
        function e(t, e) {
            return e.type || (e.data ? "category" : "value")
        }
        var i = t("../../model/Component"),
            n = t(de),
            r = t("../axisModelCreator"),
            a = i[H]({
                type: "cartesian2dAxis",
                axis: null,
                init: function () {
                    a.superApply(this, "init", arguments), this.resetRange()
                },
                mergeOption: function () {
                    a.superApply(this, "mergeOption", arguments), this.resetRange()
                },
                restoreData: function () {
                    a.superApply(this, "restoreData", arguments), this.resetRange()
                },
                getCoordSysModel: function () {
                    return this[m].queryComponents({
                        mainType: "grid",
                        index: this.option.gridIndex,
                        id: this.option.gridId
                    })[0]
                }
            });
        n.merge(a[he], t("../axisModelCommonMixin"));
        var o = {
            offset: 0
        };
        return r("x", a, e, o), r("y", a, e, o), a
    }), e("zrender/animation/Clip", [me, "./easing"], function (t) {
        function e(t) {
            this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null == t.loop ? !1 : t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart
        }
        var i = t("./easing");
        return e[he] = {
            constructor: e,
            step: function (t) {
                this._initialized || (this._startTime = t + this._delay, this._initialized = !0);
                var e = (t - this._startTime) / this._life;
                if (!(0 > e)) {
                    e = Math.min(e, 1);
                    var n = this.easing,
                        r = typeof n == ce ? i[n] : n,
                        a = typeof r === L ? r(e) : e;
                    return this.fire("frame", a), 1 == e ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, "destroy") : null
                }
            },
            restart: function (t) {
                var e = (t - this._startTime) % this._life;
                this._startTime = t - e + this.gap, this._needsRemove = !1
            },
            fire: function (t, e) {
                t = "on" + t, this[t] && this[t](this._target, e)
            }
        }, e
    }), e("echarts/coord/axisModelCreator", [me, "./axisDefault", de, "../model/Component", "../util/layout"], function (t) {
        var e = t("./axisDefault"),
            i = t(de),
            n = t("../model/Component"),
            r = t("../util/layout"),
            a = ["value", "category", "time", "log"];
        return function (t, o, s, l) {
            i.each(a, function (n) {
                o[H]({
                    type: t + "Axis." + n,
                    mergeDefaultAndTheme: function (e, a) {
                        var o = this.layoutMode,
                            l = o ? r.getLayoutParams(e) : {},
                            u = a.getTheme();
                        i.merge(e, u.get(n + "Axis")), i.merge(e, this.getDefaultOption()), e.type = s(t, e), o && r.mergeLayoutParam(e, l, o)
                    },
                    defaultOption: i.mergeAll([{}, e[n + "Axis"], l], !0)
                })
            }), n.registerSubTypeDefaulter(t + "Axis", i.curry(s, t))
        }
    }), e("echarts/coord/axisModelCommonMixin", [me, de, "./axisHelper"], function (t) {
        function e(t) {
            return i[oe](t) && null != t.value ? t.value : t
        }
        var i = t(de),
            n = t("./axisHelper");
        return {
            getFormattedLabels: function () {
                return n.getFormattedLabels(this.axis, this.get("axisLabel.formatter"))
            },
            getCategories: function () {
                return "category" === this.get("type") && i.map(this.get("data"), e)
            },
            getMin: function (t) {
                var e = this.option,
                    n = t || null == e.rangeStart ? e.min : e.rangeStart;
                return null == n || "dataMin" === n || i.eqNaN(n) || (n = this.axis.scale.parse(n)), n
            },
            getMax: function (t) {
                var e = this.option,
                    n = t || null == e.rangeEnd ? e.max : e.rangeEnd;
                return null == n || "dataMax" === n || i.eqNaN(n) || (n = this.axis.scale.parse(n)), n
            },
            getNeedCrossZero: function () {
                var t = this.option;
                return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale
            },
            getCoordSysModel: i.noop,
            setRange: function (t, e) {
                this.option.rangeStart = t, this.option.rangeEnd = e
            },
            resetRange: function () {
                this.option.rangeStart = this.option.rangeEnd = null
            }
        }
    }), e("zrender/animation/easing", [], function () {
        var t = {
            linear: function (t) {
                return t
            },
            quadraticIn: function (t) {
                return t * t
            },
            quadraticOut: function (t) {
                return t * (2 - t)
            },
            quadraticInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
            },
            cubicIn: function (t) {
                return t * t * t
            },
            cubicOut: function (t) {
                return --t * t * t + 1
            },
            cubicInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
            },
            quarticIn: function (t) {
                return t * t * t * t
            },
            quarticOut: function (t) {
                return 1 - --t * t * t * t
            },
            quarticInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
            },
            quinticIn: function (t) {
                return t * t * t * t * t
            },
            quinticOut: function (t) {
                return --t * t * t * t * t + 1
            },
            quinticInOut: function (t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
            },
            sinusoidalIn: function (t) {
                return 1 - Math.cos(t * Math.PI / 2)
            },
            sinusoidalOut: function (t) {
                return Math.sin(t * Math.PI / 2)
            },
            sinusoidalInOut: function (t) {
                return .5 * (1 - Math.cos(Math.PI * t))
            },
            exponentialIn: function (t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1)
            },
            exponentialOut: function (t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
            },
            exponentialInOut: function (t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
            },
            circularIn: function (t) {
                return 1 - Math.sqrt(1 - t * t)
            },
            circularOut: function (t) {
                return Math.sqrt(1 - --t * t)
            },
            circularInOut: function (t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            },
            elasticIn: function (t) {
                var e, i = .1,
                    n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n)))
            },
            elasticOut: function (t) {
                var e, i = .1,
                    n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / n) + 1)
            },
            elasticInOut: function (t) {
                var e, i = .1,
                    n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) * .5 + 1)
            },
            backIn: function (t) {
                var e = 1.70158;
                return t * t * ((e + 1) * t - e)
            },
            backOut: function (t) {
                var e = 1.70158;
                return --t * t * ((e + 1) * t + e) + 1
            },
            backInOut: function (t) {
                var e = 2.5949095;
                return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
            },
            bounceIn: function (e) {
                return 1 - t.bounceOut(1 - e)
            },
            bounceOut: function (t) {
                return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            },
            bounceInOut: function (e) {
                return .5 > e ? .5 * t.bounceIn(2 * e) : .5 * t.bounceOut(2 * e - 1) + .5
            }
        };
        return t
    }), e("echarts/coord/axisDefault", [me, de], function (t) {
        var e = t(de),
            i = {
                show: !0,
                zlevel: 0,
                z: 0,
                inverse: !1,
                name: "",
                nameLocation: "end",
                nameRotate: null,
                nameTruncate: {
                    maxWidth: null,
                    ellipsis: "...",
                    placeholder: "."
                },
                nameTextStyle: {},
                nameGap: 15,
                silent: !1,
                triggerEvent: !1,
                tooltip: {
                    show: !1
                },
                axisLine: {
                    show: !0,
                    onZero: !0,
                    lineStyle: {
                        color: "#333",
                        width: 1,
                        type: "solid"
                    }
                },
                axisTick: {
                    show: !0,
                    inside: !1,
                    length: 5,
                    lineStyle: {
                        width: 1
                    }
                },
                axisLabel: {
                    show: !0,
                    inside: !1,
                    rotate: 0,
                    margin: 8,
                    textStyle: {
                        fontSize: 12
                    }
                },
                splitLine: {
                    show: !0,
                    lineStyle: {
                        color: ["#ccc"],
                        width: 1,
                        type: "solid"
                    }
                },
                splitArea: {
                    show: !1,
                    areaStyle: {
                        color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
                    }
                }
            },
            n = e.merge({
                boundaryGap: !0,
                splitLine: {
                    show: !1
                },
                axisTick: {
                    alignWithLabel: !1,
                    interval: "auto"
                },
                axisLabel: {
                    interval: "auto"
                }
            }, i),
            r = e.merge({
                boundaryGap: [0, 0],
                splitNumber: 5
            }, i),
            a = e[V]({
                scale: !0,
                min: "dataMin",
                max: "dataMax"
            }, r),
            o = e[V]({
                logBase: 10
            }, r);
        return o.scale = !0, {
            categoryAxis: n,
            valueAxis: r,
            timeAxis: a,
            logAxis: o
        }
    }), e("zrender/config", [], function () {
        var t = 1;
        typeof window !== g && (t = Math.max(window.devicePixelRatio || 1, 1));
        var e = {
            debugMode: 0,
            devicePixelRatio: t
        };
        return e
    }), e("echarts/chart/bar/BaseBarSeries", [me, "../../model/Series", "../helper/createListFromArray"], function (t) {
        var e = t("../../model/Series"),
            i = t("../helper/createListFromArray");
        return e[H]({
            type: "series.__base_bar__",
            getInitialData: function (t, e) {
                return i(t.data, this, e)
            },
            getMarkerPosition: function (t) {
                var e = this[K];
                if (e) {
                    var i = e[r](t, !0),
                        n = this[Q](),
                        a = n.getLayout("offset"),
                        o = n.getLayout("size"),
                        s = e.getBaseAxis().isHorizontal() ? 0 : 1;
                    return i[s] += a + o / 2, i
                }
                return [0 / 0, 0 / 0]
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                barMinHeight: 0,
                itemStyle: {
                    normal: {},
                    emphasis: {}
                }
            }
        })
    }), e("zrender/core/curve", [me, "./vector"], function (t) {
        function e(t) {
            return t > -x && x > t
        }

        function i(t) {
            return t > x || -x > t
        }

        function n(t, e, i, n, r) {
            var a = 1 - r;
            return a * a * (a * t + 3 * r * e) + r * r * (r * n + 3 * a * i)
        }

        function r(t, e, i, n, r) {
            var a = 1 - r;
            return 3 * (((e - t) * a + 2 * (i - e) * r) * a + (n - i) * r * r)
        }

        function a(t, i, n, r, a, o) {
            var s = r + 3 * (i - n) - t,
                l = 3 * (n - 2 * i + t),
                u = 3 * (i - t),
                c = t - a,
                h = l * l - 3 * s * u,
                f = l * u - 9 * s * c,
                d = u * u - 3 * l * c,
                p = 0;
            if (e(h) && e(f))
                if (e(l)) o[0] = 0;
                else {
                    var m = -u / l;
                    m >= 0 && 1 >= m && (o[p++] = m)
                }
            else {
                var v = f * f - 4 * h * d;
                if (e(v)) {
                    var g = f / h,
                        m = -l / s + g,
                        x = -g / 2;
                    m >= 0 && 1 >= m && (o[p++] = m), x >= 0 && 1 >= x && (o[p++] = x)
                } else if (v > 0) {
                    var b = _(v),
                        T = h * l + 1.5 * s * (-f + b),
                        S = h * l + 1.5 * s * (-f - b);
                    T = 0 > T ? -y(-T, M) : y(T, M), S = 0 > S ? -y(-S, M) : y(S, M);
                    var m = (-l - (T + S)) / (3 * s);
                    m >= 0 && 1 >= m && (o[p++] = m)
                } else {
                    var C = (2 * h * l - 3 * s * f) / (2 * _(h * h * h)),
                        A = Math.acos(C) / 3,
                        P = _(h),
                        k = Math.cos(A),
                        m = (-l - 2 * P * k) / (3 * s),
                        x = (-l + P * (k + w * Math.sin(A))) / (3 * s),
                        L = (-l + P * (k - w * Math.sin(A))) / (3 * s);
                    m >= 0 && 1 >= m && (o[p++] = m), x >= 0 && 1 >= x && (o[p++] = x), L >= 0 && 1 >= L && (o[p++] = L)
                }
            }
            return p
        }

        function o(t, n, r, a, o) {
            var s = 6 * r - 12 * n + 6 * t,
                l = 9 * n + 3 * a - 3 * t - 9 * r,
                u = 3 * n - 3 * t,
                c = 0;
            if (e(l)) {
                if (i(s)) {
                    var h = -u / s;
                    h >= 0 && 1 >= h && (o[c++] = h)
                }
            } else {
                var f = s * s - 4 * l * u;
                if (e(f)) o[0] = -s / (2 * l);
                else if (f > 0) {
                    var d = _(f),
                        h = (-s + d) / (2 * l),
                        p = (-s - d) / (2 * l);
                    h >= 0 && 1 >= h && (o[c++] = h), p >= 0 && 1 >= p && (o[c++] = p)
                }
            }
            return c
        }

        function s(t, e, i, n, r, a) {
            var o = (e - t) * r + t,
                s = (i - e) * r + e,
                l = (n - i) * r + i,
                u = (s - o) * r + o,
                c = (l - s) * r + s,
                h = (c - u) * r + u;
            a[0] = t, a[1] = o, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = n
        }

        function l(t, e, i, r, a, o, s, l, u, c, h) {
            var f, d, p, m, v, y = .005,
                x = 1 / 0;
            T[0] = u, T[1] = c;
            for (var w = 0; 1 > w; w += .05) S[0] = n(t, i, a, s, w), S[1] = n(e, r, o, l, w), m = g(T, S), x > m && (f = w, x = m);
            x = 1 / 0;
            for (var M = 0; 32 > M && !(b > y); M++) d = f - y, p = f + y, S[0] = n(t, i, a, s, d), S[1] = n(e, r, o, l, d), m = g(S, T), d >= 0 && x > m ? (f = d, x = m) : (C[0] = n(t, i, a, s, p), C[1] = n(e, r, o, l, p), v = g(C, T), 1 >= p && x > v ? (f = p, x = v) : y *= .5);
            return h && (h[0] = n(t, i, a, s, f), h[1] = n(e, r, o, l, f)), _(x)
        }

        function u(t, e, i, n) {
            var r = 1 - n;
            return r * (r * t + 2 * n * e) + n * n * i
        }

        function c(t, e, i, n) {
            return 2 * ((1 - n) * (e - t) + n * (i - e))
        }

        function h(t, n, r, a, o) {
            var s = t - 2 * n + r,
                l = 2 * (n - t),
                u = t - a,
                c = 0;
            if (e(s)) {
                if (i(l)) {
                    var h = -u / l;
                    h >= 0 && 1 >= h && (o[c++] = h)
                }
            } else {
                var f = l * l - 4 * s * u;
                if (e(f)) {
                    var h = -l / (2 * s);
                    h >= 0 && 1 >= h && (o[c++] = h)
                } else if (f > 0) {
                    var d = _(f),
                        h = (-l + d) / (2 * s),
                        p = (-l - d) / (2 * s);
                    h >= 0 && 1 >= h && (o[c++] = h), p >= 0 && 1 >= p && (o[c++] = p)
                }
            }
            return c
        }

        function f(t, e, i) {
            var n = t + i - 2 * e;
            return 0 === n ? .5 : (t - e) / n
        }

        function d(t, e, i, n, r) {
            var a = (e - t) * n + t,
                o = (i - e) * n + e,
                s = (o - a) * n + a;
            r[0] = t, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = i
        }

        function p(t, e, i, n, r, a, o, s, l) {
            var c, h = .005,
                f = 1 / 0;
            T[0] = o, T[1] = s;
            for (var d = 0; 1 > d; d += .05) {
                S[0] = u(t, i, r, d), S[1] = u(e, n, a, d);
                var p = g(T, S);
                f > p && (c = d, f = p)
            }
            f = 1 / 0;
            for (var m = 0; 32 > m && !(b > h); m++) {
                var v = c - h,
                    y = c + h;
                S[0] = u(t, i, r, v), S[1] = u(e, n, a, v);
                var p = g(S, T);
                if (v >= 0 && f > p) c = v, f = p;
                else {
                    C[0] = u(t, i, r, y), C[1] = u(e, n, a, y);
                    var x = g(C, T);
                    1 >= y && f > x ? (c = y, f = x) : h *= .5
                }
            }
            return l && (l[0] = u(t, i, r, c), l[1] = u(e, n, a, c)), _(f)
        }
        var m = t("./vector"),
            v = m[X],
            g = m.distSquare,
            y = Math.pow,
            _ = Math.sqrt,
            x = 1e-8,
            b = 1e-4,
            w = _(3),
            M = 1 / 3,
            T = v(),
            S = v(),
            C = v();
        return {
            cubicAt: n,
            cubicDerivativeAt: r,
            cubicRootAt: a,
            cubicExtrema: o,
            cubicSubdivide: s,
            cubicProjectPoint: l,
            quadraticAt: u,
            quadraticDerivativeAt: c,
            quadraticRootAt: h,
            quadraticExtremum: f,
            quadraticSubdivide: d,
            quadraticProjectPoint: p
        }
    }), e("zrender/core/bbox", [me, "./vector", "./curve"], function (t) {
        var e = t("./vector"),
            i = t("./curve"),
            n = {},
            r = Math.min,
            a = Math.max,
            o = Math.sin,
            s = Math.cos,
            l = e[X](),
            u = e[X](),
            c = e[X](),
            h = 2 * Math.PI;
        n.fromPoints = function (t, e, i) {
            if (0 !== t[te]) {
                var n, o = t[0],
                    s = o[0],
                    l = o[0],
                    u = o[1],
                    c = o[1];
                for (n = 1; n < t[te]; n++) o = t[n], s = r(s, o[0]), l = a(l, o[0]), u = r(u, o[1]), c = a(c, o[1]);
                e[0] = s, e[1] = u, i[0] = l, i[1] = c
            }
        }, n.fromLine = function (t, e, i, n, o, s) {
            o[0] = r(t, i), o[1] = r(e, n), s[0] = a(t, i), s[1] = a(e, n)
        };
        var f = [],
            d = [];
        return n.fromCubic = function (t, e, n, o, s, l, u, c, h, p) {
            var m, v = i.cubicExtrema,
                g = i.cubicAt,
                y = v(t, n, s, u, f);
            for (h[0] = 1 / 0, h[1] = 1 / 0, p[0] = -1 / 0, p[1] = -1 / 0, m = 0; y > m; m++) {
                var _ = g(t, n, s, u, f[m]);
                h[0] = r(_, h[0]), p[0] = a(_, p[0])
            }
            for (y = v(e, o, l, c, d), m = 0; y > m; m++) {
                var x = g(e, o, l, c, d[m]);
                h[1] = r(x, h[1]), p[1] = a(x, p[1])
            }
            h[0] = r(t, h[0]), p[0] = a(t, p[0]), h[0] = r(u, h[0]), p[0] = a(u, p[0]), h[1] = r(e, h[1]), p[1] = a(e, p[1]), h[1] = r(c, h[1]), p[1] = a(c, p[1])
        }, n.fromQuadratic = function (t, e, n, o, s, l, u, c) {
            var h = i.quadraticExtremum,
                f = i.quadraticAt,
                d = a(r(h(t, n, s), 1), 0),
                p = a(r(h(e, o, l), 1), 0),
                m = f(t, n, s, d),
                v = f(e, o, l, p);
            u[0] = r(t, s, m), u[1] = r(e, l, v), c[0] = a(t, s, m), c[1] = a(e, l, v)
        }, n.fromArc = function (t, i, n, r, a, f, d, p, m) {
            var v = e.min,
                g = e.max,
                y = Math.abs(a - f);
            if (1e-4 > y % h && y > 1e-4) return p[0] = t - n, p[1] = i - r, m[0] = t + n, void (m[1] = i + r);
            if (l[0] = s(a) * n + t, l[1] = o(a) * r + i, u[0] = s(f) * n + t, u[1] = o(f) * r + i, v(p, l, u), g(m, l, u), a %= h, 0 > a && (a += h), f %= h, 0 > f && (f += h), a > f && !d ? f += h : f > a && d && (a += h), d) {
                var _ = f;
                f = a, a = _
            }
            for (var x = 0; f > x; x += Math.PI / 2) x > a && (c[0] = s(x) * n + t, c[1] = o(x) * r + i, v(p, c, p), g(m, c, m))
        }, n
    }), e("echarts/chart/helper/createListFromArray", [me, "../../data/List", "../../data/helper/completeDimensions", de, "../../util/model", "../../CoordinateSystem"], function (t) {
        function e(t) {
            for (var e = 0; e < t[te] && null == t[e];) e++;
            return t[e]
        }

        function i(t) {
            var i = e(t);
            return null != i && !u[z](f(i))
        }

        function n(t, e, n) {
            t = t || [];
            var r = e.get(K),
                a = m[r],
                p = h.get(r),
                g = a && a(t, e, n),
                y = g && g.dimensions;
            y || (y = p && p.dimensions || ["x", "y"], y = l(y, t, y[v](["value"])));
            var _ = g ? g.categoryIndex : -1,
                x = new s(y, e),
                b = o(g, t),
                w = {},
                M = _ >= 0 && i(t) ? function (t, e, i, n) {
                    return c.isDataItemOption(t) && (x.hasItemOption = !0), n === _ ? i : d(f(t), y[n])
                } : function (t, e, i, n) {
                    var r = f(t),
                        a = d(r && r[n], y[n]);
                    c.isDataItemOption(t) && (x.hasItemOption = !0);
                    var o = g && g.categoryAxesModels;
                    return o && o[e] && typeof a === ce && (w[e] = w[e] || o[e].getCategories(), a = u[J](w[e], a), 0 > a && !isNaN(a) && (a = +a)), a
                };
            return x.hasItemOption = !1, x.initData(t, b, M), x
        }

        function r(t) {
            return "category" !== t && "time" !== t
        }

        function a(t) {
            return "category" === t ? p : "time" === t ? "time" : "float"
        }

        function o(t, e) {
            var i, n = [],
                r = t && t.dimensions[t.categoryIndex];
            if (r && (i = t.categoryAxesModels[r.name]), i) {
                var a = i.getCategories();
                if (a) {
                    var o = e[te];
                    if (u[z](e[0]) && e[0][te] > 1) {
                        n = [];
                        for (var s = 0; o > s; s++) n[s] = a[e[s][t.categoryIndex || 0]]
                    } else n = a.slice(0)
                }
            }
            return n
        }
        var s = t("../../data/List"),
            l = t("../../data/helper/completeDimensions"),
            u = t(de),
            c = t("../../util/model"),
            h = t("../../CoordinateSystem"),
            f = c.getDataItemValue,
            d = c.converDataValue,
            m = {
                cartesian2d: function (t, e, i) {
                    var n = u.map(["xAxis", "yAxis"], function (t) {
                        return i.queryComponents({
                            mainType: t,
                            index: e.get(t + "Index"),
                            id: e.get(t + "Id")
                        })[0]
                    }),
                        o = n[0],
                        s = n[1],
                        c = o.get("type"),
                        h = s.get("type"),
                        f = [{
                            name: "x",
                            type: a(c),
                            stackable: r(c)
                        }, {
                            name: "y",
                            type: a(h),
                            stackable: r(h)
                        }],
                        d = "category" === c,
                        p = "category" === h;
                    l(f, t, ["x", "y", "z"]);
                    var m = {};
                    return d && (m.x = o), p && (m.y = s), {
                        dimensions: f,
                        categoryIndex: d ? 0 : p ? 1 : -1,
                        categoryAxesModels: m
                    }
                },
                singleAxis: function (t, e, i) {
                    var n = i.queryComponents({
                        mainType: "singleAxis",
                        index: e.get("singleAxisIndex"),
                        id: e.get("singleAxisId")
                    })[0],
                        o = n.get("type"),
                        s = "category" === o,
                        u = [{
                            name: "single",
                            type: a(o),
                            stackable: r(o)
                        }];
                    l(u, t);
                    var c = {};
                    return s && (c.single = n), {
                        dimensions: u,
                        categoryIndex: s ? 0 : -1,
                        categoryAxesModels: c
                    }
                },
                polar: function (t, e, i) {
                    var n = i.queryComponents({
                        mainType: "polar",
                        index: e.get("polarIndex"),
                        id: e.get("polarId")
                    })[0],
                        o = n.findAxisModel("angleAxis"),
                        s = n.findAxisModel("radiusAxis"),
                        u = s.get("type"),
                        c = o.get("type"),
                        h = [{
                            name: "radius",
                            type: a(u),
                            stackable: r(u)
                        }, {
                            name: "angle",
                            type: a(c),
                            stackable: r(c)
                        }],
                        f = "category" === c,
                        d = "category" === u;
                    l(h, t, ["radius", "angle", "value"]);
                    var p = {};
                    return d && (p.radius = s), f && (p.angle = o), {
                        dimensions: h,
                        categoryIndex: f ? 1 : d ? 0 : -1,
                        categoryAxesModels: p
                    }
                },
                geo: function (t) {
                    return {
                        dimensions: l([{
                            name: "lng"
                        }, {
                            name: "lat"
                        }], t, ["lng", "lat", "value"])
                    }
                }
            };
        return n
    }), e("zrender/contain/line", [], function () {
        return {
            containStroke: function (t, e, i, n, r, a, o) {
                if (0 === r) return !1;
                var s = r,
                    l = 0,
                    u = t;
                if (o > e + s && o > n + s || e - s > o && n - s > o || a > t + s && a > i + s || t - s > a && i - s > a) return !1;
                if (t === i) return Math.abs(a - t) <= s / 2;
                l = (e - n) / (t - i), u = (t * n - i * e) / (t - i);
                var c = l * a - o + u,
                    h = c * c / (l * l + 1);
                return s / 2 * s / 2 >= h
            }
        }
    }), e("zrender/contain/cubic", [me, "../core/curve"], function (t) {
        var e = t("../core/curve");
        return {
            containStroke: function (t, i, n, r, a, o, s, l, u, c, h) {
                if (0 === u) return !1;
                var f = u;
                if (h > i + f && h > r + f && h > o + f && h > l + f || i - f > h && r - f > h && o - f > h && l - f > h || c > t + f && c > n + f && c > a + f && c > s + f || t - f > c && n - f > c && a - f > c && s - f > c) return !1;
                var d = e.cubicProjectPoint(t, i, n, r, a, o, s, l, c, h, null);
                return f / 2 >= d
            }
        }
    }), e("zrender/contain/quadratic", [me, "../core/curve"], function (t) {
        var e = t("../core/curve");
        return {
            containStroke: function (t, i, n, r, a, o, s, l, u) {
                if (0 === s) return !1;
                var c = s;
                if (u > i + c && u > r + c && u > o + c || i - c > u && r - c > u && o - c > u || l > t + c && l > n + c && l > a + c || t - c > l && n - c > l && a - c > l) return !1;
                var h = e.quadraticProjectPoint(t, i, n, r, a, o, l, u, null);
                return c / 2 >= h
            }
        }
    }), e("zrender/contain/arc", [me, "./util"], function (t) {
        var e = t("./util").normalizeRadian,
            i = 2 * Math.PI;
        return {
            containStroke: function (t, n, r, a, o, s, l, u, c) {
                if (0 === l) return !1;
                var h = l;
                u -= t, c -= n;
                var f = Math.sqrt(u * u + c * c);
                if (f - h > r || r > f + h) return !1;
                if (Math.abs(a - o) % i < 1e-4) return !0;
                if (s) {
                    var d = a;
                    a = e(o), o = e(d)
                } else a = e(a), o = e(o);
                a > o && (o += i);
                var p = Math.atan2(c, u);
                return 0 > p && (p += i), p >= a && o >= p || p + i >= a && o >= p + i
            }
        }
    }), e("zrender/contain/util", [me], function () {
        var t = 2 * Math.PI;
        return {
            normalizeRadian: function (e) {
                return e %= t, 0 > e && (e += t), e
            }
        }
    }), e("zrender/contain/windingLine", [], function () {
        return function (t, e, i, n, r, a) {
            if (a > e && a > n || e > a && n > a) return 0;
            if (n === e) return 0;
            var o = e > n ? 1 : -1,
                s = (a - e) / (n - e);
            (1 === s || 0 === s) && (o = e > n ? .5 : -.5);
            var l = s * (i - t) + t;
            return l > r ? o : 0
        }
    }), e("echarts/data/helper/completeDimensions", [me, de], function (t) {
        function e(t, e, a, o) {
            if (!e) return t;
            var s = i(e[0]),
                l = n[z](s) && s[te] || 1;
            a = a || [], o = o || "extra";
            for (var u = 0; l > u; u++)
                if (!t[u]) {
                    var c = a[u] || o + (u - a[te]);
                    t[u] = r(e, u) ? {
                        type: "ordinal",
                        name: c
                    } : c
                } return t
        }

        function i(t) {
            return n[z](t) ? t : n[oe](t) ? t.value : t
        }
        var n = t(de),
            r = e.guessOrdinal = function (t, e) {
                for (var r = 0, a = t[te]; a > r; r++) {
                    var o = i(t[r]);
                    if (!n[z](o)) return !1;
                    var o = o[e];
                    if (null != o && isFinite(o)) return !1;
                    if (n.isString(o) && "-" !== o) return !0
                }
                return !1
            };
        return e
    }), e("zrender/core/LRU", [me], function () {
        var t = function () {
            this.head = null, this.tail = null, this._len = 0
        },
            e = t[he];
        e.insert = function (t) {
            var e = new i(t);
            return this.insertEntry(e), e
        }, e.insertEntry = function (t) {
            this.head ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : this.head = this.tail = t, this._len++
        }, e[q] = function (t) {
            var e = t.prev,
                i = t.next;
            e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--
        }, e.len = function () {
            return this._len
        };
        var i = function (t) {
            this.value = t, this.next, this.prev
        },
            n = function (e) {
                this._list = new t, this._map = {}, this._maxSize = e || 10
            },
            r = n[he];
        return r.put = function (t, e) {
            var i = this._list,
                n = this._map;
            if (null == n[t]) {
                var r = i.len();
                if (r >= this._maxSize && r > 0) {
                    var a = i.head;
                    i[q](a), delete n[a.key]
                }
                var o = i.insert(e);
                o.key = t, n[t] = o
            }
        }, r.get = function (t) {
            var e = this._map[t],
                i = this._list;
            return null != e ? (e !== i.tail && (i[q](e), i.insertEntry(e)), e.value) : void 0
        }, r.clear = function () {
            this._list.clear(), this._map = {}
        }, n
    }), e("echarts/chart/bar/helper", [me, de, n], function (t) {
        function e(t, e, i, n, a) {
            r.setText(t, e, i), t.text = n, "outside" === t.textPosition && (t.textPosition = a)
        }
        var i = t(de),
            r = t(n),
            a = {};
        return a.setLabel = function (t, n, r, a, o, l, u) {
            var c = r[ae]("label.normal"),
                h = r[ae]("label.emphasis");
            c.get("show") ? e(t, c, a, i[s](o.getFormattedLabel(l, "normal"), o.getRawValue(l)), u) : t.text = "", h.get("show") ? e(n, h, a, i[s](o.getFormattedLabel(l, "emphasis"), o.getRawValue(l)), u) : n.text = ""
        }, a
    }), e("echarts/chart/bar/barItemStyle", [me, "../../model/mixin/makeStyleMapper"], function (t) {
        var e = t("../../model/mixin/makeStyleMapper")([
            ["fill", "color"],
            [u, "borderColor"],
            ["lineWidth", "borderWidth"],
            [u, "barBorderColor"],
            ["lineWidth", "barBorderWidth"],
            [b],
            ["shadowBlur"],
            ["shadowOffsetX"],
            ["shadowOffsetY"],
            ["shadowColor"]
        ]);
        return {
            getBarItemStyle: function (t) {
                var i = e.call(this, t);
                if (this.getBorderLineDash) {
                    var n = this.getBorderLineDash();
                    n && (i.lineDash = n)
                }
                return i
            }
        }
    }), e("zrender/graphic/helper/poly", [me, "./smoothSpline", "./smoothBezier"], function (t) {
        var e = t("./smoothSpline"),
            n = t("./smoothBezier");
        return {
            buildPath: function (t, r, a) {
                var o = r.points,
                    s = r.smooth;
                if (o && o[te] >= 2) {
                    if (s && "spline" !== s) {
                        var l = n(o, s, a, r.smoothConstraint);
                        t[i](o[0][0], o[0][1]);
                        for (var u = o[te], c = 0;
                            (a ? u : u - 1) > c; c++) {
                            var h = l[2 * c],
                                f = l[2 * c + 1],
                                d = o[(c + 1) % u];
                            t.bezierCurveTo(h[0], h[1], f[0], f[1], d[0], d[1])
                        }
                    } else {
                        "spline" === s && (o = e(o, a)), t[i](o[0][0], o[0][1]);
                        for (var c = 1, p = o[te]; p > c; c++) t.lineTo(o[c][0], o[c][1])
                    }
                    a && t.closePath()
                }
            }
        }
    }), e("zrender/graphic/helper/smoothSpline", [me, "../../core/vector"], function (t) {
        function e(t, e, i, n, r, a, o) {
            var s = .5 * (i - t),
                l = .5 * (n - e);
            return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
        }
        var i = t("../../core/vector");
        return function (t, n) {
            for (var r = t[te], a = [], o = 0, s = 1; r > s; s++) o += i.distance(t[s - 1], t[s]);
            var l = o / 2;
            l = r > l ? r : l;
            for (var s = 0; l > s; s++) {
                var u, c, h, f = s / (l - 1) * (n ? r : r - 1),
                    d = Math.floor(f),
                    p = f - d,
                    m = t[d % r];
                n ? (u = t[(d - 1 + r) % r], c = t[(d + 1) % r], h = t[(d + 2) % r]) : (u = t[0 === d ? d : d - 1], c = t[d > r - 2 ? r - 1 : d + 1], h = t[d > r - 3 ? r - 1 : d + 2]);
                var v = p * p,
                    g = p * v;
                a.push([e(u[0], m[0], c[0], h[0], p, v, g), e(u[1], m[1], c[1], h[1], p, v, g)])
            }
            return a
        }
    }), e("zrender/graphic/helper/smoothBezier", [me, "../../core/vector"], function (t) {
        var e = t("../../core/vector"),
            i = e.min,
            n = e.max,
            r = e.scale,
            a = e.distance,
            o = e.add;
        return function (t, s, l, u) {
            var c, h, f, d, p = [],
                m = [],
                v = [],
                g = [];
            if (u) {
                f = [1 / 0, 1 / 0], d = [-1 / 0, -1 / 0];
                for (var y = 0, _ = t[te]; _ > y; y++) i(f, f, t[y]), n(d, d, t[y]);
                i(f, f, u[0]), n(d, d, u[1])
            }
            for (var y = 0, _ = t[te]; _ > y; y++) {
                var x = t[y];
                if (l) c = t[y ? y - 1 : _ - 1], h = t[(y + 1) % _];
                else {
                    if (0 === y || y === _ - 1) {
                        p.push(e.clone(t[y]));
                        continue
                    }
                    c = t[y - 1], h = t[y + 1]
                }
                e.sub(m, h, c), r(m, m, s);
                var b = a(x, c),
                    w = a(x, h),
                    M = b + w;
                0 !== M && (b /= M, w /= M), r(v, m, -b), r(g, m, w);
                var T = o([], x, v),
                    S = o([], x, g);
                u && (n(T, T, f), i(T, T, d), n(S, S, f), i(S, S, d)), p.push(T), p.push(S)
            }
            return l && p.push(p.shift()), p
        }
    }), e("zrender/graphic/helper/roundRect", [me], function () {
        return {
            buildPath: function (t, e) {
                var n, r, a, o, s = e.x,
                    l = e.y,
                    u = e.width,
                    c = e[ue],
                    h = e.r;
                0 > u && (s += u, u = -u), 0 > c && (l += c, c = -c), typeof h === k ? n = r = a = o = h : h instanceof Array ? 1 === h[te] ? n = r = a = o = h[0] : 2 === h[te] ? (n = a = h[0], r = o = h[1]) : 3 === h[te] ? (n = h[0], r = o = h[1], a = h[2]) : (n = h[0], r = h[1], a = h[2], o = h[3]) : n = r = a = o = 0;
                var f;
                n + r > u && (f = n + r, n *= u / f, r *= u / f), a + o > u && (f = a + o, a *= u / f, o *= u / f), r + a > c && (f = r + a, r *= c / f, a *= c / f), n + o > c && (f = n + o, n *= c / f, o *= c / f), t[i](s + n, l), t.lineTo(s + u - r, l), 0 !== r && t.quadraticCurveTo(s + u, l, s + u, l + r), t.lineTo(s + u, l + c - a), 0 !== a && t.quadraticCurveTo(s + u, l + c, s + u - a, l + c), t.lineTo(s + o, l + c), 0 !== o && t.quadraticCurveTo(s, l + c, s, l + c - o), t.lineTo(s, l + n), 0 !== n && t.quadraticCurveTo(s, l, s + n, l)
            }
        }
    }), e("zrender/graphic/Gradient", [me], function () {
        var t = function (t) {
            this[j] = t || []
        };
        return t[he] = {
            constructor: t,
            addColorStop: function (t, e) {
                this[j].push({
                    offset: t,
                    color: e
                })
            }
        }, t
    }), e("zrender/Handler", [me, "./core/util", "./mixin/Draggable", "./mixin/Eventful"], function (t) {
        function e(t, e, i) {
            return {
                type: t,
                event: i,
                target: e,
                cancelBubble: !1,
                offsetX: i.zrX,
                offsetY: i.zrY,
                gestureEvent: i.gestureEvent,
                pinchX: i.pinchX,
                pinchY: i.pinchY,
                pinchScale: i.pinchScale,
                wheelDelta: i.zrDelta,
                zrByTouch: i.zrByTouch
            }
        }

        function i() { }

        function n(t, e, i) {
            if (t[t.rectHover ? "rectContain" : x](e, i)) {
                for (var n = t; n;) {
                    if (n[se] || n.clipPath && !n.clipPath[x](e, i)) return !1;
                    n = n[l]
                }
                return !0
            }
            return !1
        }
        var r = t("./core/util"),
            a = t("./mixin/Draggable"),
            o = t("./mixin/Eventful");
        i[he].dispose = function () { };
        var s = ["click", "dblclick", "mousewheel", N, "mouseup", "mousedown", "mousemove", "contextmenu"],
            u = function (t, e, n, l) {
                o.call(this), this.storage = t, this.painter = e, this.painterRoot = l, n = n || new i, this.proxy = n, n.handler = this, this._hovered, this._lastTouchMoment, this._lastX, this._lastY, a.call(this), r.each(s, function (t) {
                    n.on && n.on(t, this[t], this)
                }, this)
            };
        return u[he] = {
            constructor: u,
            mousemove: function (t) {
                var e = t.zrX,
                    i = t.zrY,
                    n = this.findHover(e, i, null),
                    r = this._hovered,
                    a = this.proxy;
                this._hovered = n, a.setCursor && a.setCursor(n ? n.cursor : "default"), r && n !== r && r.__zr && this.dispatchToElement(r, N, t), this.dispatchToElement(n, "mousemove", t), n && n !== r && this.dispatchToElement(n, "mouseover", t)
            },
            mouseout: function (t) {
                this.dispatchToElement(this._hovered, N, t);
                var e, i = t.toElement || t.relatedTarget;
                do i = i && i.parentNode; while (i && 9 != i.nodeType && !(e = i === this.painterRoot));
                !e && this[G]("globalout", {
                    event: t
                })
            },
            resize: function () {
                this._hovered = null
            },
            dispatch: function (t, e) {
                var i = this[t];
                i && i.call(this, e)
            },
            dispose: function () {
                this.proxy.dispose(), this.storage = this.proxy = this.painter = null
            },
            setCursorStyle: function (t) {
                var e = this.proxy;
                e.setCursor && e.setCursor(t)
            },
            dispatchToElement: function (t, i, n) {
                for (var r = "on" + i, a = e(i, t, n), o = t; o && (o[r] && (a.cancelBubble = o[r].call(o, a)), o[G](i, a), o = o[l], !a.cancelBubble););
                a.cancelBubble || (this[G](i, a), this.painter && this.painter.eachOtherLayer(function (t) {
                    typeof t[r] == L && t[r].call(t, a), t[G] && t[G](i, a)
                }))
            },
            findHover: function (t, e, i) {
                for (var r = this.storage.getDisplayList(), a = r[te] - 1; a >= 0; a--)
                    if (!r[a][se] && r[a] !== i && !r[a][ie] && n(r[a], t, e)) return r[a]
            }
        }, r.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (t) {
            u[he][t] = function (e) {
                var i = this.findHover(e.zrX, e.zrY, null);
                if ("mousedown" === t) this._downel = i, this._upel = i;
                else if ("mosueup" === t) this._upel = i;
                else if ("click" === t && this._downel !== this._upel) return;
                this.dispatchToElement(i, t, e)
            }
        }), r.mixin(u, o), r.mixin(u, a), u
    }), e("zrender/Storage", [me, "./core/util", "./core/env", "./container/Group", "./core/timsort"], function (t) {
        function e(t, e) {
            return t[D] === e[D] ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t[D] - e[D]
        }
        var i = t("./core/util"),
            n = t("./core/env"),
            r = t("./container/Group"),
            a = t("./core/timsort"),
            o = function () {
                this._elements = {}, this._roots = [], this._displayList = [], this._displayListLen = 0
            };
        return o[he] = {
            constructor: o,
            traverse: function (t, e) {
                for (var i = 0; i < this._roots[te]; i++) this._roots[i][B](t, e)
            },
            getDisplayList: function (t, e) {
                return e = e || !1, t && this.updateDisplayList(e), this._displayList
            },
            updateDisplayList: function (t) {
                this._displayListLen = 0;
                for (var i = this._roots, r = this._displayList, o = 0, s = i[te]; s > o; o++) this._updateAndAddDisplayable(i[o], null, t);
                r[te] = this._displayListLen, n.canvasSupported && a(r, e)
            },
            _updateAndAddDisplayable: function (t, e, i) {
                if (!t[ie] || i) {
                    t.beforeUpdate(), t.__dirty && t[U](), t.afterUpdate();
                    var n = t.clipPath;
                    if (n) {
                        e = e ? e.slice() : [];
                        for (var r = n, a = t; r;) r[l] = a, r.updateTransform(), e.push(r), a = r, r = r.clipPath
                    }
                    if (t.isGroup) {
                        for (var o = t._children, s = 0; s < o[te]; s++) {
                            var u = o[s];
                            t.__dirty && (u.__dirty = !0), this._updateAndAddDisplayable(u, e, i)
                        }
                        t.__dirty = !1
                    } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t
                }
            },
            addRoot: function (t) {
                this._elements[t.id] || (t instanceof r && t.addChildrenToStorage(this), this.addToMap(t), this._roots.push(t))
            },
            delRoot: function (t) {
                if (null == t) {
                    for (var e = 0; e < this._roots[te]; e++) {
                        var n = this._roots[e];
                        n instanceof r && n.delChildrenFromStorage(this)
                    }
                    return this._elements = {}, this._roots = [], this._displayList = [], void (this._displayListLen = 0)
                }
                if (t instanceof Array)
                    for (var e = 0, a = t[te]; a > e; e++) this.delRoot(t[e]);
                else {
                    var o;
                    o = typeof t == ce ? this._elements[t] : t;
                    var s = i[J](this._roots, o);
                    s >= 0 && (this.delFromMap(o.id), this._roots[F](s, 1), o instanceof r && o.delChildrenFromStorage(this))
                }
            },
            addToMap: function (t) {
                return t instanceof r && (t.__storage = this), t.dirty(!1), this._elements[t.id] = t, this
            },
            get: function (t) {
                return this._elements[t]
            },
            delFromMap: function (t) {
                var e = this._elements,
                    i = e[t];
                return i && (delete e[t], i instanceof r && (i.__storage = null)), this
            },
            dispose: function () {
                this._elements = this._renderList = this._roots = null
            },
            displayableSortFunc: e
        }, o
    }), e("zrender/animation/Animation", [me, "../core/util", "../core/event", "./requestAnimationFrame", "./Animator"], function (t) {
        var e = t("../core/util"),
            i = t("../core/event").Dispatcher,
            n = t("./requestAnimationFrame"),
            r = t("./Animator"),
            a = function (t) {
                t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function () { }, this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, this._paused = !1, i.call(this)
            };
        return a[he] = {
            constructor: a,
            addClip: function (t) {
                this._clips.push(t)
            },
            addAnimator: function (t) {
                t[le] = this;
                for (var e = t.getClips(), i = 0; i < e[te]; i++) this.addClip(e[i])
            },
            removeClip: function (t) {
                var i = e[J](this._clips, t);
                i >= 0 && this._clips[F](i, 1)
            },
            removeAnimator: function (t) {
                for (var e = t.getClips(), i = 0; i < e[te]; i++) this.removeClip(e[i]);
                t[le] = null
            },
            _update: function () {
                for (var t = (new Date).getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i[te], r = [], a = [], o = 0; n > o; o++) {
                    var s = i[o],
                        l = s.step(t);
                    l && (r.push(l), a.push(s))
                }
                for (var o = 0; n > o;) i[o]._needsRemove ? (i[o] = i[n - 1], i.pop(), n--) : o++;
                n = r[te];
                for (var o = 0; n > o; o++) a[o].fire(r[o]);
                this._time = t, this.onframe(e), this[G]("frame", e), this.stage[U] && this.stage[U]()
            },
            _startLoop: function () {
                function t() {
                    e._running && (n(t), !e._paused && e._update())
                }
                var e = this;
                this._running = !0, n(t)
            },
            start: function () {
                this._time = (new Date).getTime(), this._pausedTime = 0, this._startLoop()
            },
            stop: function () {
                this._running = !1
            },
            pause: function () {
                this._paused || (this._pauseStart = (new Date).getTime(), this._paused = !0)
            },
            resume: function () {
                this._paused && (this._pausedTime += (new Date).getTime() - this._pauseStart, this._paused = !1)
            },
            clear: function () {
                this._clips = []
            },
            animate: function (t, e) {
                e = e || {};
                var i = new r(t, e.loop, e.getter, e.setter);
                return this.addAnimator(i), i
            }
        }, e.mixin(a, i), a
    }), e("zrender/dom/HandlerProxy", [me, "../core/event", "../core/util", "../mixin/Eventful", "../core/env", "../core/GestureMgr"], function (t) {
        function e(t) {
            return "mousewheel" === t && c.browser.firefox ? "DOMMouseScroll" : t
        }

        function i(t, e, i) {
            var n = t._gestureMgr;
            "start" === i && n.clear();
            var r = n.recognize(e, t.handler.findHover(e.zrX, e.zrY, null), t.dom);
            if ("end" === i && n.clear(), r) {
                var a = r.type;
                e.gestureEvent = a, t.handler.dispatchToElement(r.target, a, r.event)
            }
        }

        function n(t) {
            t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function () {
                t._touching = !1
            }, 700)
        }

        function r(t) {
            var e = t.pointerType;
            return "pen" === e || "touch" === e
        }

        function a(t) {
            function e(t, e) {
                return function () {
                    return e._touching ? void 0 : t.apply(e, arguments)
                }
            }
            l.each(y, function (e) {
                t._handlers[e] = l.bind(b[e], t)
            }), l.each(x, function (e) {
                t._handlers[e] = l.bind(b[e], t)
            }), l.each(g, function (i) {
                t._handlers[i] = e(b[i], t)
            })
        }

        function o(t) {
            function i(i, n) {
                l.each(i, function (i) {
                    f(t, e(i), n._handlers[i])
                }, n)
            }
            u.call(this), this.dom = t, this._touching = !1, this._touchTimer, this._gestureMgr = new h, this._handlers = {}, a(this), c.pointerEventsSupported ? i(x, this) : (c.touchEventsSupported && i(y, this), i(g, this))
        }
        var s = t("../core/event"),
            l = t("../core/util"),
            u = t("../mixin/Eventful"),
            c = t("../core/env"),
            h = t("../core/GestureMgr"),
            f = s.addEventListener,
            d = s.removeEventListener,
            p = s.normalizeEvent,
            m = 300,
            g = ["click", "dblclick", "mousewheel", N, "mouseup", "mousedown", "mousemove", "contextmenu"],
            y = ["touchstart", "touchend", "touchmove"],
            _ = {
                pointerdown: 1,
                pointerup: 1,
                pointermove: 1,
                pointerout: 1
            },
            x = l.map(g, function (t) {
                var e = t[I]("mouse", "pointer");
                return _[e] ? e : t
            }),
            b = {
                mousemove: function (t) {
                    t = p(this.dom, t), this[G]("mousemove", t)
                },
                mouseout: function (t) {
                    t = p(this.dom, t);
                    var e = t.toElement || t.relatedTarget;
                    if (e != this.dom)
                        for (; e && 9 != e.nodeType;) {
                            if (e === this.dom) return;
                            e = e.parentNode
                        }
                    this[G](N, t)
                },
                touchstart: function (t) {
                    t = p(this.dom, t), t.zrByTouch = !0, this._lastTouchMoment = new Date, i(this, t, "start"), b.mousemove.call(this, t), b.mousedown.call(this, t), n(this)
                },
                touchmove: function (t) {
                    t = p(this.dom, t), t.zrByTouch = !0, i(this, t, "change"), b.mousemove.call(this, t), n(this)
                },
                touchend: function (t) {
                    t = p(this.dom, t), t.zrByTouch = !0, i(this, t, "end"), b.mouseup.call(this, t), +new Date - this._lastTouchMoment < m && b.click.call(this, t), n(this)
                },
                pointerdown: function (t) {
                    b.mousedown.call(this, t)
                },
                pointermove: function (t) {
                    r(t) || b.mousemove.call(this, t)
                },
                pointerup: function (t) {
                    b.mouseup.call(this, t)
                },
                pointerout: function (t) {
                    r(t) || b[N].call(this, t)
                }
            };
        l.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (t) {
            b[t] = function (e) {
                e = p(this.dom, e), this[G](t, e)
            }
        });
        var w = o[he];
        return w.dispose = function () {
            for (var t = g[v](y), i = 0; i < t[te]; i++) {
                var n = t[i];
                d(this.dom, e(n), this._handlers[n])
            }
        }, w.setCursor = function (t) {
            this.dom.style.cursor = t || "default"
        }, l.mixin(o, u), o
    }), e("zrender/Painter", [me, "./config", "./core/util", "./core/log", "./core/BoundingRect", "./core/timsort", "./Layer", "./animation/requestAnimationFrame", "./graphic/Image"], function (t) {
        function e(t) {
            return parseInt(t, 10)
        }

        function i(t) {
            return t ? t.isBuildin ? !0 : typeof t.resize !== L || typeof t.refresh !== L ? !1 : !0 : !1
        }

        function n(t) {
            t.__unusedCount++
        }

        function r(t) {
            1 == t.__unusedCount && t.clear()
        }

        function a(t, e, i) {
            return y.copy(t[S]()), t.transform && y[c](t.transform), _.width = e, _[ue] = i, !y.intersect(_)
        }

        function o(t, e) {
            if (t == e) return !1;
            if (!t || !e || t[te] !== e[te]) return !0;
            for (var i = 0; i < t[te]; i++)
                if (t[i] !== e[i]) return !0
        }

        function s(t, e) {
            for (var i = 0; i < t[te]; i++) {
                var n = t[i],
                    r = n.path;
                n.setTransform(e), r.beginPath(e), n.buildPath(r, n.shape), e.clip(), n.restoreTransform(e)
            }
        }

        function l(t, e) {
            var i = document.createElement("div");
            return i.style.cssText = ["position:relative", "overflow:hidden", "width:" + t + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", i
        }
        var u = t("./config"),
            h = t("./core/util"),
            f = t("./core/log"),
            d = t("./core/BoundingRect"),
            p = t("./core/timsort"),
            m = t("./Layer"),
            v = t("./animation/requestAnimationFrame"),
            g = 5,
            y = new d(0, 0, 0, 0),
            _ = new d(0, 0, 0, 0),
            x = function (t, e, i) {
                var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
                this._opts = i = h[H]({}, i || {}), this.dpr = i.devicePixelRatio || u.devicePixelRatio, this._singleCanvas = n, this.root = t;
                var r = t.style;
                r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = r["user-select"] = r["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e;
                var a = this._zlevelList = [],
                    o = this._layers = {};
                if (this._layerConfig = {}, n) {
                    var s = t.width,
                        c = t[ue];
                    this._width = s, this._height = c;
                    var f = new m(t, this, 1);
                    f.initContext(), o[0] = f, a.push(0), this._domRoot = t
                } else {
                    this._width = this._getSize(0), this._height = this._getSize(1);
                    var d = this._domRoot = l(this._width, this._height);
                    t.appendChild(d)
                }
                this.pathToImage = this._createPathToImage(), this._progressiveLayers = [], this._hoverlayer, this._hoverElements = []
            };
        return x[he] = {
            constructor: x,
            isSingleCanvas: function () {
                return this._singleCanvas
            },
            getViewportRoot: function () {
                return this._domRoot
            },
            refresh: function (t) {
                var e = this.storage.getDisplayList(!0),
                    i = this._zlevelList;
                this._paintList(e, t);
                for (var n = 0; n < i[te]; n++) {
                    var r = i[n],
                        a = this._layers[r];
                    !a.isBuildin && a.refresh && a.refresh()
                }
                return this.refreshHover(), this._progressiveLayers[te] && this._startProgessive(), this
            },
            addHover: function (t, e) {
                if (!t.__hoverMir) {
                    var i = new t.constructor({
                        style: t.style,
                        shape: t.shape
                    });
                    i.__from = t, t.__hoverMir = i, i[O](e), this._hoverElements.push(i)
                }
            },
            removeHover: function (t) {
                var e = t.__hoverMir,
                    i = this._hoverElements,
                    n = h[J](i, e);
                n >= 0 && i[F](n, 1), t.__hoverMir = null
            },
            clearHover: function () {
                for (var t = this._hoverElements, e = 0; e < t[te]; e++) {
                    var i = t[e].__from;
                    i && (i.__hoverMir = null)
                }
                t[te] = 0
            },
            refreshHover: function () {
                var t = this._hoverElements,
                    e = t[te],
                    i = this._hoverlayer;
                if (i && i.clear(), e) {
                    p(t, this.storage.displayableSortFunc), i || (i = this._hoverlayer = this.getLayer(1e5));
                    var n = {};
                    i.ctx.save();
                    for (var r = 0; e > r;) {
                        var a = t[r],
                            o = a.__from;
                        o && o.__zr ? (r++, o.invisible || (a.transform = o.transform, a.invTransform = o.invTransform, a.__clipPaths = o.__clipPaths, this._doPaintEl(a, i, !0, n))) : (t[F](r, 1), o.__hoverMir = null, e--)
                    }
                    i.ctx.restore()
                }
            },
            _startProgessive: function () {
                function t() {
                    i === e._progressiveToken && e.storage && (e._doPaintList(e.storage.getDisplayList()), e._furtherProgressive ? (e._progress++, v(t)) : e._progressiveToken = -1)
                }
                var e = this;
                if (e._furtherProgressive) {
                    var i = e._progressiveToken = +new Date;
                    e._progress++, v(t)
                }
            },
            _clearProgressive: function () {
                this._progressiveToken = -1, this._progress = 0, h.each(this._progressiveLayers, function (t) {
                    t.__dirty && t.clear()
                })
            },
            _paintList: function (t, e) {
                null == e && (e = !1), this._updateLayerStatus(t), this._clearProgressive(), this.eachBuildinLayer(n), this._doPaintList(t, e), this.eachBuildinLayer(r)
            },
            _doPaintList: function (t, e) {
                function i(t) {
                    var e = a.dpr || 1;
                    a.save(), a.globalAlpha = 1, a.shadowBlur = 0, n.__dirty = !0, a.setTransform(1, 0, 0, 1, 0, 0), a.drawImage(t.dom, 0, 0, c * e, d * e), a.restore()
                }
                for (var n, r, a, o, s, l, u = 0, c = this._width, d = this._height, p = this._progress, m = 0, v = t[te]; v > m; m++) {
                    var y = t[m],
                        _ = this._singleCanvas ? 0 : y[D],
                        x = y.__frame;
                    if (0 > x && s && (i(s), s = null), r !== _ && (a && a.restore(), o = {}, r = _, n = this.getLayer(r), n.isBuildin || f("ZLevel " + r + " has been used by unkown layer " + n.id), a = n.ctx, a.save(), n.__unusedCount = 0, (n.__dirty || e) && n.clear()), n.__dirty || e) {
                        if (x >= 0) {
                            if (!s) {
                                if (s = this._progressiveLayers[Math.min(u++, g - 1)], s.ctx.save(), s.renderScope = {}, s && s.__progress > s.__maxProgress) {
                                    m = s.__nextIdxNotProg - 1;
                                    continue
                                }
                                l = s.__progress, s.__dirty || (p = l), s.__progress = p + 1
                            }
                            x === p && this._doPaintEl(y, s, !0, s.renderScope)
                        } else this._doPaintEl(y, n, e, o);
                        y.__dirty = !1
                    }
                }
                s && i(s), a && a.restore(), this._furtherProgressive = !1, h.each(this._progressiveLayers, function (t) {
                    t.__maxProgress >= t.__progress && (this._furtherProgressive = !0)
                }, this)
            },
            _doPaintEl: function (t, e, i, n) {
                var r = e.ctx,
                    l = t.transform;
                if (!(!e.__dirty && !i || t.invisible || 0 === t.style[b] || l && !l[0] && !l[3] || t.culling && a(t, this._width, this._height))) {
                    var u = t.__clipPaths;
                    (n.prevClipLayer !== e || o(u, n.prevElClipPaths)) && (n.prevElClipPaths && (n.prevClipLayer.ctx.restore(), n.prevClipLayer = n.prevElClipPaths = null, n.prevEl = null), u && (r.save(), s(u, r), n.prevClipLayer = e, n.prevElClipPaths = u)), t.beforeBrush && t.beforeBrush(r), t.brush(r, n.prevEl || null), n.prevEl = t, t.afterBrush && t.afterBrush(r)
                }
            },
            getLayer: function (t) {
                if (this._singleCanvas) return this._layers[0];
                var e = this._layers[t];
                return e || (e = new m("zr_" + t, this, this.dpr), e.isBuildin = !0, this._layerConfig[t] && h.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()), e
            },
            insertLayer: function (t, e) {
                var n = this._layers,
                    r = this._zlevelList,
                    a = r[te],
                    o = null,
                    s = -1,
                    l = this._domRoot;
                if (n[t]) return void f("ZLevel " + t + " has been used already");
                if (!i(e)) return void f("Layer of zlevel " + t + " is not valid");
                if (a > 0 && t > r[0]) {
                    for (s = 0; a - 1 > s && !(r[s] < t && r[s + 1] > t); s++);
                    o = n[r[s]]
                }
                if (r[F](s + 1, 0, t), o) {
                    var u = o.dom;
                    u.nextSibling ? l.insertBefore(e.dom, u.nextSibling) : l.appendChild(e.dom)
                } else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
                n[t] = e
            },
            eachLayer: function (t, e) {
                var i, n, r = this._zlevelList;
                for (n = 0; n < r[te]; n++) i = r[n], t.call(e, this._layers[i], i)
            },
            eachBuildinLayer: function (t, e) {
                var i, n, r, a = this._zlevelList;
                for (r = 0; r < a[te]; r++) n = a[r], i = this._layers[n], i.isBuildin && t.call(e, i, n)
            },
            eachOtherLayer: function (t, e) {
                var i, n, r, a = this._zlevelList;
                for (r = 0; r < a[te]; r++) n = a[r], i = this._layers[n], i.isBuildin || t.call(e, i, n)
            },
            getLayers: function () {
                return this._layers
            },
            _updateLayerStatus: function (t) {
                var e = this._layers,
                    i = this._progressiveLayers,
                    n = {},
                    r = {};
                this.eachBuildinLayer(function (t, e) {
                    n[e] = t.elCount, t.elCount = 0, t.__dirty = !1
                }), h.each(i, function (t, e) {
                    r[e] = t.elCount, t.elCount = 0, t.__dirty = !1
                });
                for (var a, o, s = 0, l = 0, u = 0, c = t[te]; c > u; u++) {
                    var f = t[u],
                        d = this._singleCanvas ? 0 : f[D],
                        p = e[d],
                        v = f.progressive;
                    if (p && (p.elCount++, p.__dirty = p.__dirty || f.__dirty), v >= 0) {
                        o !== v && (o = v, l++);
                        var y = f.__frame = l - 1;
                        if (!a) {
                            var _ = Math.min(s, g - 1);
                            a = i[_], a || (a = i[_] = new m("progressive", this, this.dpr), a.initContext()), a.__maxProgress = 0
                        }
                        a.__dirty = a.__dirty || f.__dirty, a.elCount++, a.__maxProgress = Math.max(a.__maxProgress, y), a.__maxProgress >= a.__progress && (p.__dirty = !0)
                    } else f.__frame = -1, a && (a.__nextIdxNotProg = u, s++, a = null)
                }
                a && (s++, a.__nextIdxNotProg = u), this.eachBuildinLayer(function (t, e) {
                    n[e] !== t.elCount && (t.__dirty = !0)
                }), i[te] = Math.min(s, g), h.each(i, function (t, e) {
                    r[e] !== t.elCount && (f.__dirty = !0), t.__dirty && (t.__progress = 0)
                })
            },
            clear: function () {
                return this.eachBuildinLayer(this._clearLayer), this
            },
            _clearLayer: function (t) {
                t.clear()
            },
            configLayer: function (t, e) {
                if (e) {
                    var i = this._layerConfig;
                    i[t] ? h.merge(i[t], e, !0) : i[t] = e;
                    var n = this._layers[t];
                    n && h.merge(n, i[t], !0)
                }
            },
            delLayer: function (t) {
                var e = this._layers,
                    i = this._zlevelList,
                    n = e[t];
                n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i[F](h[J](i, t), 1))
            },
            resize: function (t, e) {
                var i = this._domRoot;
                i.style.display = "none";
                var n = this._opts;
                if (null != t && (n.width = t), null != e && (n[ue] = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width != t || e != this._height) {
                    i.style.width = t + "px", i.style[ue] = e + "px";
                    for (var r in this._layers) this._layers.hasOwnProperty(r) && this._layers[r].resize(t, e);
                    h.each(this._progressiveLayers, function (i) {
                        i.resize(t, e)
                    }), this.refresh(!0)
                }
                return this._width = t, this._height = e, this
            },
            clearLayer: function (t) {
                var e = this._layers[t];
                e && e.clear()
            },
            dispose: function () {
                this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null
            },
            getRenderedCanvas: function (t) {
                if (t = t || {}, this._singleCanvas) return this._layers[0].dom;
                var e = new m("image", this, t.pixelRatio || this.dpr);
                e.initContext(), e.clearColor = t.backgroundColor, e.clear();
                for (var i = this.storage.getDisplayList(!0), n = {}, r = 0; r < i[te]; r++) {
                    var a = i[r];
                    this._doPaintEl(a, e, !0, n)
                }
                return e.dom
            },
            getWidth: function () {
                return this._width
            },
            getHeight: function () {
                return this._height
            },
            _getSize: function (t) {
                var i = this._opts,
                    n = ["width", ue][t],
                    r = ["clientWidth", "clientHeight"][t],
                    a = ["paddingLeft", "paddingTop"][t],
                    o = ["paddingRight", "paddingBottom"][t];
                if (null != i[n] && "auto" !== i[n]) return parseFloat(i[n]);
                var s = this.root,
                    l = document.defaultView.getComputedStyle(s);
                return (s[r] || e(l[n]) || e(s.style[n])) - (e(l[a]) || 0) - (e(l[o]) || 0) | 0
            },
            _pathToImage: function (e, i, n, r, a) {
                var o = document.createElement("canvas"),
                    s = o.getContext("2d");
                o.width = n * a, o[ue] = r * a, s.clearRect(0, 0, n * a, r * a);
                var l = {
                    position: i[w],
                    rotation: i.rotation,
                    scale: i.scale
                };
                i[w] = [0, 0, 0], i.rotation = 0, i.scale = [1, 1], i && i.brush(s);
                var u = t("./graphic/Image"),
                    c = new u({
                        id: e,
                        style: {
                            x: 0,
                            y: 0,
                            image: o
                        }
                    });
                return null != l[w] && (c[w] = i[w] = l[w]), null != l.rotation && (c.rotation = i.rotation = l.rotation), null != l.scale && (c.scale = i.scale = l.scale), c
            },
            _createPathToImage: function () {
                var t = this;
                return function (e, i, n, r) {
                    return t._pathToImage(e, i, n, r, t.dpr)
                }
            }
        }, x
    }), e("zrender/mixin/Draggable", [me], function () {
        function t() {
            this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this)
        }
        return t[he] = {
            constructor: t,
            _dragStart: function (t) {
                var e = t.target;
                e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(e, "dragstart", t.event))
            },
            _drag: function (t) {
                var e = this._draggingTarget;
                if (e) {
                    var i = t.offsetX,
                        n = t.offsetY,
                        r = i - this._x,
                        a = n - this._y;
                    this._x = i, this._y = n, e.drift(r, a, t), this.dispatchToElement(e, "drag", t.event);
                    var o = this.findHover(i, n, e),
                        s = this._dropTarget;
                    this._dropTarget = o, e !== o && (s && o !== s && this.dispatchToElement(s, "dragleave", t.event), o && o !== s && this.dispatchToElement(o, "dragenter", t.event))
                }
            },
            _dragEnd: function (t) {
                var e = this._draggingTarget;
                e && (e.dragging = !1), this.dispatchToElement(e, "dragend", t.event), this._dropTarget && this.dispatchToElement(this._dropTarget, "drop", t.event), this._draggingTarget = null, this._dropTarget = null
            }
        }, t
    }), e("zrender/core/event", [me, "../mixin/Eventful", "./env"], function (t) {
        function e(t) {
            return t.getBoundingClientRect ? t.getBoundingClientRect() : {
                left: 0,
                top: 0
            }
        }

        function i(t, e, i, r) {
            return i = i || {}, r || !l.canvasSupported ? n(t, e, i) : l.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (i.zrX = e.layerX, i.zrY = e.layerY) : null != e.offsetX ? (i.zrX = e.offsetX, i.zrY = e.offsetY) : n(t, e, i), i
        }

        function n(t, i, n) {
            var r = e(t);
            n.zrX = i.clientX - r.left, n.zrY = i.clientY - r.top
        }

        function r(t, e, n) {
            if (e = e || window.event, null != e.zrX) return e;
            var r = e.type,
                a = r && r[J]("touch") >= 0;
            if (a) {
                var o = "touchend" != r ? e.targetTouches[0] : e.changedTouches[0];
                o && i(t, o, e, n)
            } else i(t, e, e, n), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
            return e
        }

        function a(t, e, i) {
            u ? t.addEventListener(e, i) : t.attachEvent("on" + e, i)
        }

        function o(t, e, i) {
            u ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i)
        }
        var s = t("../mixin/Eventful"),
            l = t("./env"),
            u = typeof window !== g && !!window.addEventListener,
            c = u ? function (t) {
                t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
            } : function (t) {
                t.returnValue = !1, t.cancelBubble = !0
            };
        return {
            clientToLocal: i,
            normalizeEvent: r,
            addEventListener: a,
            removeEventListener: o,
            stop: c,
            Dispatcher: s
        }
    }), e("zrender/animation/requestAnimationFrame", [me], function () {
        return typeof window !== g && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) {
            setTimeout(t, 16)
        }
    }), e("zrender/core/GestureMgr", [me, "./event"], function (t) {
        function e(t) {
            var e = t[1][0] - t[0][0],
                i = t[1][1] - t[0][1];
            return Math.sqrt(e * e + i * i)
        }

        function i(t) {
            return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
        }
        var n = t("./event"),
            r = function () {
                this._track = []
            };
        r[he] = {
            constructor: r,
            recognize: function (t, e, i) {
                return this._doTrack(t, e, i), this._recognize(t)
            },
            clear: function () {
                return this._track[te] = 0, this
            },
            _doTrack: function (t, e, i) {
                var r = t.touches;
                if (r) {
                    for (var a = {
                        points: [],
                        touches: [],
                        target: e,
                        event: t
                    }, o = 0, s = r[te]; s > o; o++) {
                        var l = r[o],
                            u = n.clientToLocal(i, l, {});
                        a.points.push([u.zrX, u.zrY]), a.touches.push(l)
                    }
                    this._track.push(a)
                }
            },
            _recognize: function (t) {
                for (var e in a)
                    if (a.hasOwnProperty(e)) {
                        var i = a[e](this._track, t);
                        if (i) return i
                    }
            }
        };
        var a = {
            pinch: function (t, n) {
                var r = t[te];
                if (r) {
                    var a = (t[r - 1] || {}).points,
                        o = (t[r - 2] || {}).points || a;
                    if (o && o[te] > 1 && a && a[te] > 1) {
                        var s = e(a) / e(o);
                        !isFinite(s) && (s = 1), n.pinchScale = s;
                        var l = i(a);
                        return n.pinchX = l[0], n.pinchY = l[1], {
                            type: "pinch",
                            target: t[0].target,
                            event: n
                        }
                    }
                }
            }
        };
        return r
    }), e("zrender/Layer", [me, "./core/util", "./config", "./graphic/Style", "./graphic/Pattern"], function (t) {
        function e() {
            return !1
        }

        function i(t, e, i, n) {
            var r = document.createElement(e),
                a = i[re](),
                o = i[ne](),
                s = r.style;
            return s[w] = "absolute", s.left = 0, s.top = 0, s.width = a + "px", s[ue] = o + "px", r.width = a * n, r[ue] = o * n, r.setAttribute("data-zr-dom-id", t), r
        }
        var n = t("./core/util"),
            r = t("./config"),
            a = t("./graphic/Style"),
            o = t("./graphic/Pattern"),
            s = function (t, a, o) {
                var s;
                o = o || r.devicePixelRatio, typeof t === ce ? s = i(t, "canvas", a, o) : n[oe](t) && (s = t, t = s.id), this.id = t, this.dom = s;
                var l = s.style;
                l && (s.onselectstart = e, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", l.padding = 0, l.margin = 0, l["border-width"] = 0), this.domBack = null, this.ctxBack = null, this.painter = a, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = o
            };
        return s[he] = {
            constructor: s,
            elCount: 0,
            __dirty: !0,
            initContext: function () {
                this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr
            },
            createBackBuffer: function () {
                var t = this.dpr;
                this.domBack = i("back-" + this.id, "canvas", this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 != t && this.ctxBack.scale(t, t)
            },
            resize: function (t, e) {
                var i = this.dpr,
                    n = this.dom,
                    r = n.style,
                    a = this.domBack;
                r.width = t + "px", r[ue] = e + "px", n.width = t * i, n[ue] = e * i, a && (a.width = t * i, a[ue] = e * i, 1 != i && this.ctxBack.scale(i, i))
            },
            clear: function (t) {
                var e = this.dom,
                    i = this.ctx,
                    n = e.width,
                    r = e[ue],
                    s = this.clearColor,
                    l = this.motionBlur && !t,
                    u = this.lastFrameAlpha,
                    c = this.dpr;
                if (l && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, n / c, r / c)), i.clearRect(0, 0, n, r), s) {
                    var h;
                    s[j] ? (h = s.__canvasGradient || a.getGradient(i, s, {
                        x: 0,
                        y: 0,
                        width: n,
                        height: r
                    }), s.__canvasGradient = h) : s.image && (h = o[he].getCanvasPattern.call(s, i)), i.save(), i.fillStyle = h || s, i.fillRect(0, 0, n, r), i.restore()
                }
                if (l) {
                    var f = this.domBack;
                    i.save(), i.globalAlpha = u, i.drawImage(f, 0, 0, n, r), i.restore()
                }
            }
        }, s
    }), e("echarts/preprocessor/helper/compatStyle", [me, de], function (t) {
        function e(t) {
            var e = t && t.itemStyle;
            e && i.each(n, function (n) {
                var r = e.normal,
                    a = e.emphasis;
                r && r[n] && (t[n] = t[n] || {}, t[n].normal ? i.merge(t[n].normal, r[n]) : t[n].normal = r[n], r[n] = null), a && a[n] && (t[n] = t[n] || {}, t[n].emphasis ? i.merge(t[n].emphasis, a[n]) : t[n].emphasis = a[n], a[n] = null)
            })
        }
        var i = t(de),
            n = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
        return function (t) {
            if (t) {
                e(t), e(t.markPoint), e(t.markLine);
                var n = t.data;
                if (n) {
                    for (var r = 0; r < n[te]; r++) e(n[r]);
                    var a = t.markPoint;
                    if (a && a.data)
                        for (var o = a.data, r = 0; r < o[te]; r++) e(o[r]);
                    var s = t.markLine;
                    if (s && s.data)
                        for (var l = s.data, r = 0; r < l[te]; r++) i[z](l[r]) ? (e(l[r][0]), e(l[r][1])) : e(l[r])
                }
            }
        }
    }), e("echarts/component/axis/AxisView", [me, de, n, "./AxisBuilder", "../../echarts"], function (t) {
        function e(t, e) {
            function i(t) {
                var e = n.getAxis(t);
                return e.toGlobalCoord(e.dataToCoord(0))
            }
            var n = t[K],
                r = e.axis,
                a = {},
                o = r[w],
                s = r.onZero ? "onZero" : o,
                l = r.dim,
                u = n.getRect(),
                c = [u.x, u.x + u.width, u.y, u.y + u[ue]],
                h = e.get("offset") || 0,
                f = {
                    x: {
                        top: c[2] - h,
                        bottom: c[3] + h
                    },
                    y: {
                        left: c[0] - h,
                        right: c[1] + h
                    }
                };
            f.x.onZero = Math.max(Math.min(i("y"), f.x[ee]), f.x.top), f.y.onZero = Math.max(Math.min(i("x"), f.y.right), f.y.left), a[w] = ["y" === l ? f.y[s] : c[0], "x" === l ? f.x[s] : c[3]], a.rotation = Math.PI / 2 * ("x" === l ? 0 : 1);
            var d = {
                top: -1,
                bottom: 1,
                left: -1,
                right: 1
            };
            a.labelDirection = a.tickDirection = a.nameDirection = d[o], r.onZero && (a.labelOffset = f[l][o] - f[l].onZero), e[ae]("axisTick").get("inside") && (a.tickDirection = -a.tickDirection), e[ae]("axisLabel").get("inside") && (a.labelDirection = -a.labelDirection);
            var p = e[ae]("axisLabel").get("rotate");
            return a.labelRotation = "top" === s ? -p : p, a.labelInterval = r.getLabelInterval(), a.z2 = 1, a
        }
        var i = t(de),
            r = t(n),
            a = t("./AxisBuilder"),
            o = a.ifIgnoreOnTick,
            s = a.getInterval,
            l = ["axisLine", "axisLabel", "axisTick", "axisName"],
            u = ["splitArea", "splitLine"],
            c = t("../../echarts").extendComponentView({
                type: "axis",
                render: function (t) {
                    this.group[P]();
                    var n = this._axisGroup;
                    if (this._axisGroup = new r.Group, this.group.add(this._axisGroup), t.get("show")) {
                        var o = t.getCoordSysModel(),
                            s = e(o, t),
                            c = new a(t, s);
                        i.each(l, c.add, c), this._axisGroup.add(c.getGroup()), i.each(u, function (e) {
                            t.get(e + ".show") && this["_" + e](t, o, s.labelInterval)
                        }, this), r.groupTransition(n, this._axisGroup, t)
                    }
                },
                _splitLine: function (t, e, n) {
                    var a = t.axis;
                    if (!a.isBlank()) {
                        var l = t[ae]("splitLine"),
                            u = l[ae]("lineStyle"),
                            c = u.get("color"),
                            h = s(l, n);
                        c = i[z](c) ? c : [c];
                        for (var f = e[K].getRect(), d = a.isHorizontal(), p = 0, m = a.getTicksCoords(), v = a.scale[y](), g = [], _ = [], x = u.getLineStyle(), b = 0; b < m[te]; b++)
                            if (!o(a, b, h)) {
                                var w = a.toGlobalCoord(m[b]);
                                d ? (g[0] = w, g[1] = f.y, _[0] = w, _[1] = f.y + f[ue]) : (g[0] = f.x, g[1] = w, _[0] = f.x + f.width, _[1] = w);
                                var M = p++ % c[te];
                                this._axisGroup.add(new r.Line(r.subPixelOptimizeLine({
                                    anid: "line_" + v[b],
                                    shape: {
                                        x1: g[0],
                                        y1: g[1],
                                        x2: _[0],
                                        y2: _[1]
                                    },
                                    style: i[V]({
                                        stroke: c[M]
                                    }, x),
                                    silent: !0
                                })))
                            }
                    }
                },
                _splitArea: function (t, e, n) {
                    var a = t.axis;
                    if (!a.isBlank()) {
                        var l = t[ae]("splitArea"),
                            u = l[ae]("areaStyle"),
                            c = u.get("color"),
                            h = e[K].getRect(),
                            f = a.getTicksCoords(),
                            d = a.scale[y](),
                            p = a.toGlobalCoord(f[0]),
                            m = a.toGlobalCoord(f[0]),
                            v = 0,
                            g = s(l, n),
                            _ = u.getAreaStyle();
                        c = i[z](c) ? c : [c];
                        for (var x = 1; x < f[te]; x++)
                            if (!o(a, x, g)) {
                                var b, w, M, T, S = a.toGlobalCoord(f[x]);
                                a.isHorizontal() ? (b = p, w = h.y, M = S - b, T = h[ue]) : (b = h.x, w = m, M = h.width, T = S - w);
                                var C = v++ % c[te];
                                this._axisGroup.add(new r.Rect({
                                    anid: "area_" + d[x],
                                    shape: {
                                        x: b,
                                        y: w,
                                        width: M,
                                        height: T
                                    },
                                    style: i[V]({
                                        fill: c[C]
                                    }, _),
                                    silent: !0
                                })), p = b + M, m = w + T
                            }
                    }
                }
            });
        c[H]({
            type: "xAxis"
        }), c[H]({
            type: "yAxis"
        })
    }), e("echarts/chart/helper/SymbolDraw", [me, n, "./Symbol"], function (t) {
        function e(t) {
            this.group = new r.Group, this._symbolCtor = t || a
        }

        function i(t, e, i) {
            var n = t.getItemLayout(e);
            return !(!n || isNaN(n[0]) || isNaN(n[1]) || i && i(e) || "none" === t[Y](e, "symbol"))
        }
        var r = t(n),
            a = t("./Symbol"),
            o = e[he];
        return o.updateData = function (t, e) {
            var n = this.group,
                a = t.hostModel,
                o = this._data,
                s = this._symbolCtor,
                l = {
                    itemStyle: a[ae]("itemStyle.normal").getItemStyle(["color"]),
                    hoverItemStyle: a[ae]("itemStyle.emphasis").getItemStyle(),
                    symbolRotate: a.get("symbolRotate"),
                    symbolOffset: a.get("symbolOffset"),
                    hoverAnimation: a.get("hoverAnimation"),
                    labelModel: a[ae]("label.normal"),
                    hoverLabelModel: a[ae]("label.emphasis")
                };
            t.diff(o).add(function (r) {
                var a = t.getItemLayout(r);
                if (i(t, r, e)) {
                    var o = new s(t, r, l);
                    o.attr(w, a), t.setItemGraphicEl(r, o), n.add(o)
                }
            })[U](function (u, c) {
                var h = o[f](c),
                    d = t.getItemLayout(u);
                return i(t, u, e) ? (h ? (h.updateData(t, u, l), r.updateProps(h, {
                    position: d
                }, a)) : (h = new s(t, u), h.attr(w, d)), n.add(h), void t.setItemGraphicEl(u, h)) : void n[q](h)
            })[q](function (t) {
                var e = o[f](t);
                e && e.fadeOut(function () {
                    n[q](e)
                })
            }).execute(), this._data = t
        }, o.updateLayout = function () {
            var t = this._data;
            t && t[h](function (e, i) {
                var n = t.getItemLayout(i);
                e.attr(w, n)
            })
        }, o[q] = function (t) {
            var e = this.group,
                i = this._data;
            i && (t ? i[h](function (t) {
                t.fadeOut(function () {
                    e[q](t)
                })
            }) : e[P]())
        }, e
    }), e("echarts/chart/helper/Symbol", [me, de, "../../util/symbol", n, "../../util/number"], function (t) {
        function e(t, e) {
            var i = t[Y](e, "symbolSize");
            return i instanceof Array ? i.slice() : [+i, +i]
        }

        function i(t) {
            return [t[0] / 2, t[1] / 2]
        }

        function r(t, e, i) {
            f.Group.call(this), this.updateData(t, e, i)
        }

        function u(t, e) {
            this[l].drift(t, e)
        }
        var c = t(de),
            h = t("../../util/symbol"),
            f = t(n),
            m = t("../../util/number"),
            v = r[he];
        v._createSymbol = function (t, e, n, r) {
            this[P]();
            var a = e.hostModel,
                o = e[Y](n, "color"),
                s = h.createSymbol(t, -1, -1, 2, 2, o);
            s.attr({
                z2: 100,
                culling: !0,
                scale: [0, 0]
            }), s.drift = u, f.initProps(s, {
                scale: i(r)
            }, a, n), this._symbolType = t, this.add(s)
        }, v.stopSymbolAnimation = function (t) {
            this.childAt(0).stopAnimation(t)
        }, v.getSymbolPath = function () {
            return this.childAt(0)
        }, v.getScale = function () {
            return this.childAt(0).scale
        }, v.highlight = function () {
            this.childAt(0)[G]("emphasis")
        }, v.downplay = function () {
            this.childAt(0)[G]("normal")
        }, v.setZ = function (t, e) {
            var i = this.childAt(0);
            i[D] = t, i.z = e
        }, v.setDraggable = function (t) {
            var e = this.childAt(0);
            e.draggable = t, e.cursor = t ? "move" : "pointer"
        }, v.updateData = function (t, n, r) {
            this[se] = !1;
            var a = t[Y](n, "symbol") || "circle",
                o = t.hostModel,
                s = e(t, n);
            if (a !== this._symbolType) this._createSymbol(a, t, n, s);
            else {
                var l = this.childAt(0);
                f.updateProps(l, {
                    scale: i(s)
                }, o, n)
            }
            this._updateCommon(t, n, s, r), this._seriesModel = o
        };
        var g = ["itemStyle", "normal"],
            y = ["itemStyle", "emphasis"],
            _ = ["label", "normal"],
            x = ["label", "emphasis"];
        return v._updateCommon = function (t, e, n, r) {
            var l = this.childAt(0),
                u = t.hostModel,
                h = t[Y](e, "color");
            "image" !== l.type && l.useStyle({
                strokeNoScale: !0
            }), r = r || null;
            var v = r && r.itemStyle,
                M = r && r.hoverItemStyle,
                T = r && r.symbolRotate,
                S = r && r.symbolOffset,
                C = r && r.labelModel,
                A = r && r.hoverLabelModel,
                P = r && r.hoverAnimation;
            if (!r || t.hasItemOption) {
                var k = t[o](e);
                v = k[ae](g).getItemStyle(["color"]), M = k[ae](y).getItemStyle(), T = k[d]("symbolRotate"), S = k[d]("symbolOffset"), C = k[ae](_), A = k[ae](x), P = k[d]("hoverAnimation")
            } else M = c[H]({}, M);
            var L = l.style;
            l.attr("rotation", (T || 0) * Math.PI / 180 || 0), S && l.attr(w, [m[a](S[0], n[0]), m[a](S[1], n[1])]), l.setColor(h), l[O](v);
            var z = t[Y](e, b);
            null != z && (L[b] = z);
            for (var I, D, B = t.dimensions.slice(); B[te] && (I = B.pop(), D = t.getDimensionInfo(I).type, D === p || "time" === D););
            null != I && C[d]("show") ? (f.setText(L, C, h), L.text = c[s](u.getFormattedLabel(e, "normal"), t.get(I, e))) : L.text = "", null != I && A[d]("show") ? (f.setText(M, A, h), M.text = c[s](u.getFormattedLabel(e, "emphasis"), t.get(I, e))) : M.text = "", l.off("mouseover").off(N).off("emphasis").off("normal"), l.hoverStyle = M, f.setHoverStyle(l);
            var E = i(n);
            if (P && u.isAnimationEnabled()) {
                var R = function () {
                    var t = E[1] / E[0];
                    this.animateTo({
                        scale: [Math.max(1.1 * E[0], E[0] + 3), Math.max(1.1 * E[1], E[1] + 3 * t)]
                    }, 400, "elasticOut")
                },
                    F = function () {
                        this.animateTo({
                            scale: E
                        }, 400, "elasticOut")
                    };
                l.on("mouseover", R).on(N, F).on("emphasis", R).on("normal", F)
            }
        }, v.fadeOut = function (t) {
            var e = this.childAt(0);
            this[se] = !0, e.style.text = "", f.updateProps(e, {
                scale: [0, 0]
            }, this._seriesModel, this[$], t)
        }, c.inherits(r, f.Group), r
    }), e("echarts/chart/line/lineAnimationDiff", [me], function () {
        function t(t) {
            return t >= 0 ? 1 : -1
        }

        function e(e, i, n) {
            for (var a, o = e.getBaseAxis(), s = e.getOtherAxis(o), l = o.onZero ? 0 : s.scale[_]()[0], u = s.dim, c = "x" === u || "radius" === u ? 1 : 0, h = i.stackedOn, f = i.get(u, n); h && t(h.get(u, n)) === t(f);) {
                a = h;
                break
            }
            var d = [];
            return d[c] = i.get(o.dim, n), d[1 - c] = a ? a.get(u, n, !0) : l, e[r](d)
        }

        function i(t, e) {
            var i = [];
            return e.diff(t).add(function (t) {
                i.push({
                    cmd: "+",
                    idx: t
                })
            })[U](function (t, e) {
                i.push({
                    cmd: "=",
                    idx: e,
                    idx1: t
                })
            })[q](function (t) {
                i.push({
                    cmd: "-",
                    idx: t
                })
            }).execute(), i
        }
        return function (t, n, a, o, s, l) {
            for (var u = i(t, n), c = [], h = [], f = [], d = [], p = [], m = [], v = [], g = l.dimensions, y = 0; y < u[te]; y++) {
                var _ = u[y],
                    x = !0;
                switch (_.cmd) {
                    case "=":
                        var b = t.getItemLayout(_.idx),
                            w = n.getItemLayout(_.idx1);
                        (isNaN(b[0]) || isNaN(b[1])) && (b = w.slice()), c.push(b), h.push(w), f.push(a[_.idx]), d.push(o[_.idx1]), v.push(n.getRawIndex(_.idx1));
                        break;
                    case "+":
                        var M = _.idx;
                        c.push(s[r]([n.get(g[0], M, !0), n.get(g[1], M, !0)])), h.push(n.getItemLayout(M).slice()), f.push(e(s, n, M)), d.push(o[M]), v.push(n.getRawIndex(M));
                        break;
                    case "-":
                        var M = _.idx,
                            T = t.getRawIndex(M);
                        T !== M ? (c.push(t.getItemLayout(M)), h.push(l[r]([t.get(g[0], M, !0), t.get(g[1], M, !0)])), f.push(a[M]), d.push(e(l, t, M)), v.push(T)) : x = !1
                }
                x && (p.push(_), m.push(m[te]))
            }
            m.sort(function (t, e) {
                return v[t] - v[e]
            });
            for (var S = [], C = [], A = [], P = [], k = [], y = 0; y < m[te]; y++) {
                var M = m[y];
                S[y] = c[M], C[y] = h[M], A[y] = f[M], P[y] = d[M], k[y] = p[M]
            }
            return {
                current: S,
                next: C,
                stackedOnCurrent: A,
                stackedOnNext: P,
                status: k
            }
        }
    }), e("echarts/chart/line/poly", [me, "zrender/graphic/Path", "zrender/core/vector"], function (t) {
        function e(t) {
            return isNaN(t[0]) || isNaN(t[1])
        }

        function n(t, n, r, a, p, m, v, g, y, _, x) {
            for (var b = 0, w = r, M = 0; a > M; M++) {
                var T = n[w];
                if (w >= p || 0 > w) break;
                if (e(T)) {
                    if (x) {
                        w += m;
                        continue
                    }
                    break
                }
                if (w === r) t[m > 0 ? i : "lineTo"](T[0], T[1]), c(f, T);
                else if (y > 0) {
                    var S = w + m,
                        C = n[S];
                    if (x)
                        for (; C && e(n[S]);) S += m, C = n[S];
                    var A = .5,
                        P = n[b],
                        C = n[S];
                    if (!C || e(C)) c(d, T);
                    else {
                        e(C) && !x && (C = T), o.sub(h, C, P);
                        var k, L;
                        if ("x" === _ || "y" === _) {
                            var z = "x" === _ ? 0 : 1;
                            k = Math.abs(T[z] - P[z]), L = Math.abs(T[z] - C[z])
                        } else k = o.dist(T, P), L = o.dist(T, C);
                        A = L / (L + k), u(d, T, h, -y * (1 - A))
                    }
                    s(f, f, g), l(f, f, v), s(d, d, g), l(d, d, v), t.bezierCurveTo(f[0], f[1], d[0], d[1], T[0], T[1]), u(f, T, h, y * A)
                } else t.lineTo(T[0], T[1]);
                b = w, w += m
            }
            return M
        }

        function r(t, e) {
            var i = [1 / 0, 1 / 0],
                n = [-1 / 0, -1 / 0];
            if (e)
                for (var r = 0; r < t[te]; r++) {
                    var a = t[r];
                    a[0] < i[0] && (i[0] = a[0]), a[1] < i[1] && (i[1] = a[1]), a[0] > n[0] && (n[0] = a[0]), a[1] > n[1] && (n[1] = a[1])
                }
            return {
                min: e ? i : n,
                max: e ? n : i
            }
        }
        var a = t("zrender/graphic/Path"),
            o = t("zrender/core/vector"),
            s = o.min,
            l = o.max,
            u = o.scaleAndAdd,
            c = o.copy,
            h = [],
            f = [],
            d = [];
        return {
            Polyline: a[H]({
                type: "ec-polyline",
                shape: {
                    points: [],
                    smooth: 0,
                    smoothConstraint: !0,
                    smoothMonotone: null,
                    connectNulls: !1
                },
                style: {
                    fill: null,
                    stroke: "#000"
                },
                buildPath: function (t, i) {
                    var a = i.points,
                        o = 0,
                        s = a[te],
                        l = r(a, i.smoothConstraint);
                    if (i.connectNulls) {
                        for (; s > 0 && e(a[s - 1]); s--);
                        for (; s > o && e(a[o]); o++);
                    }
                    for (; s > o;) o += n(t, a, o, s, s, 1, l.min, l.max, i.smooth, i.smoothMonotone, i.connectNulls) + 1
                }
            }),
            Polygon: a[H]({
                type: "ec-polygon",
                shape: {
                    points: [],
                    stackedOnPoints: [],
                    smooth: 0,
                    stackedOnSmooth: 0,
                    smoothConstraint: !0,
                    smoothMonotone: null,
                    connectNulls: !1
                },
                buildPath: function (t, i) {
                    var a = i.points,
                        o = i.stackedOnPoints,
                        s = 0,
                        l = a[te],
                        u = i.smoothMonotone,
                        c = r(a, i.smoothConstraint),
                        h = r(o, i.smoothConstraint);
                    if (i.connectNulls) {
                        for (; l > 0 && e(a[l - 1]); l--);
                        for (; l > s && e(a[s]); s++);
                    }
                    for (; l > s;) {
                        var f = n(t, a, s, l, l, 1, c.min, c.max, i.smooth, u, i.connectNulls);
                        n(t, o, s + f - 1, f, l, -1, h.min, h.max, i.stackedOnSmooth, u, i.connectNulls), s += f + 1, t.closePath()
                    }
                }
            })
        }
    }), e("echarts/util/symbol", [me, "./graphic", "zrender/core/BoundingRect"], function (t) {
        var e = t("./graphic"),
            n = t("zrender/core/BoundingRect"),
            r = e.extendShape({
                type: "triangle",
                shape: {
                    cx: 0,
                    cy: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function (t, e) {
                    var n = e.cx,
                        r = e.cy,
                        a = e.width / 2,
                        o = e[ue] / 2;
                    t[i](n, r - o), t.lineTo(n + a, r + o), t.lineTo(n - a, r + o), t.closePath()
                }
            }),
            a = e.extendShape({
                type: "diamond",
                shape: {
                    cx: 0,
                    cy: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function (t, e) {
                    var n = e.cx,
                        r = e.cy,
                        a = e.width / 2,
                        o = e[ue] / 2;
                    t[i](n, r - o), t.lineTo(n + a, r), t.lineTo(n, r + o), t.lineTo(n - a, r), t.closePath()
                }
            }),
            o = e.extendShape({
                type: "pin",
                shape: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function (t, e) {
                    var i = e.x,
                        n = e.y,
                        r = e.width / 5 * 3,
                        a = Math.max(r, e[ue]),
                        o = r / 2,
                        s = o * o / (a - o),
                        l = n - a + o + s,
                        u = Math.asin(s / o),
                        c = Math.cos(u) * o,
                        h = Math.sin(u),
                        f = Math.cos(u);
                    t.arc(i, l, o, Math.PI - u, 2 * Math.PI + u);
                    var d = .6 * o,
                        p = .7 * o;
                    t.bezierCurveTo(i + c - h * d, l + s + f * d, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - c + h * d, l + s + f * d, i - c, l + s), t.closePath()
                }
            }),
            s = e.extendShape({
                type: "arrow",
                shape: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function (t, e) {
                    var n = e[ue],
                        r = e.width,
                        a = e.x,
                        o = e.y,
                        s = r / 3 * 2;
                    t[i](a, o), t.lineTo(a + s, o + n), t.lineTo(a, o + n / 4 * 3), t.lineTo(a - s, o + n), t.lineTo(a, o), t.closePath()
                }
            }),
            l = {
                line: e.Line,
                rect: e.Rect,
                roundRect: e.Rect,
                square: e.Rect,
                circle: e.Circle,
                diamond: a,
                pin: o,
                arrow: s,
                triangle: r
            },
            c = {
                line: function (t, e, i, n, r) {
                    r.x1 = t, r.y1 = e + n / 2, r.x2 = t + i, r.y2 = e + n / 2
                },
                rect: function (t, e, i, n, r) {
                    r.x = t, r.y = e, r.width = i, r[ue] = n
                },
                roundRect: function (t, e, i, n, r) {
                    r.x = t, r.y = e, r.width = i, r[ue] = n, r.r = Math.min(i, n) / 4
                },
                square: function (t, e, i, n, r) {
                    var a = Math.min(i, n);
                    r.x = t, r.y = e, r.width = a, r[ue] = a
                },
                circle: function (t, e, i, n, r) {
                    r.cx = t + i / 2, r.cy = e + n / 2, r.r = Math.min(i, n) / 2
                },
                diamond: function (t, e, i, n, r) {
                    r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[ue] = n
                },
                pin: function (t, e, i, n, r) {
                    r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[ue] = n
                },
                arrow: function (t, e, i, n, r) {
                    r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[ue] = n
                },
                triangle: function (t, e, i, n, r) {
                    r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[ue] = n
                }
            },
            h = {};
        for (var f in l) l.hasOwnProperty(f) && (h[f] = new l[f]);
        var d = e.extendShape({
            type: "symbol",
            shape: {
                symbolType: "",
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            beforeBrush: function () {
                var t = this.style,
                    e = this.shape;
                "pin" === e.symbolType && "inside" === t.textPosition && (t.textPosition = ["50%", "40%"], t.textAlign = M, t.textVerticalAlign = T)
            },
            buildPath: function (t, e, i) {
                var n = e.symbolType,
                    r = h[n];
                "none" !== e.symbolType && (r || (n = "rect", r = h[n]), c[n](e.x, e.y, e.width, e[ue], r.shape), r.buildPath(t, r.shape, i))
            }
        }),
            p = function (t) {
                if ("image" !== this.type) {
                    var e = this.style,
                        i = this.shape;
                    i && "line" === i.symbolType ? e[u] = t : this.__isEmptyBrush ? (e[u] = t, e.fill = "#fff") : (e.fill && (e.fill = t), e[u] && (e[u] = t)), this.dirty(!1)
                }
            },
            m = {
                createSymbol: function (t, i, r, a, o, s) {
                    var l = 0 === t[J]("empty");
                    l && (t = t.substr(5, 1)[fe]() + t.substr(6));
                    var u;
                    return u = 0 === t[J]("image://") ? new e.Image({
                        style: {
                            image: t.slice(8),
                            x: i,
                            y: r,
                            width: a,
                            height: o
                        }
                    }) : 0 === t[J]("path://") ? e.makePath(t.slice(7), {}, new n(i, r, a, o)) : new d({
                        shape: {
                            symbolType: t,
                            x: i,
                            y: r,
                            width: a,
                            height: o
                        }
                    }), u.__isEmptyBrush = l, u.setColor = p, u.setColor(s), u
                }
            };
        return m
    }), e("echarts/component/helper/listComponent", [me, "../../util/layout", "../../util/format", n], function (t) {
        function e(t, e, n) {
            i.positionElement(t, e.getBoxLayoutParams(), {
                width: n[re](),
                height: n[ne]()
            }, e.get("padding"))
        }
        var i = t("../../util/layout"),
            r = t("../../util/format"),
            a = t(n);
        return {
            layout: function (t, n, r) {
                var a = i.getLayoutRect(n.getBoxLayoutParams(), {
                    width: r[re](),
                    height: r[ne]()
                }, n.get("padding"));
                i.box(n.get("orient"), t, n.get("itemGap"), a.width, a[ue]), e(t, n, r)
            },
            addBackground: function (t, e) {
                var i = r.normalizeCssArray(e.get("padding")),
                    n = t[S](),
                    o = e.getItemStyle(["color", b]);
                o.fill = e.get("backgroundColor");
                var s = new a.Rect({
                    shape: {
                        x: n.x - i[3],
                        y: n.y - i[0],
                        width: n.width + i[1] + i[3],
                        height: n[ue] + i[0] + i[2]
                    },
                    style: o,
                    silent: !0,
                    z2: -1
                });
                a.subPixelOptimizeRect(s), t.add(s)
            }
        }
    }), e("echarts/component/tooltip/TooltipContent", [me, de, "zrender/tool/color", "zrender/core/event", "../../util/format", pe], function (t) {
        function e(t) {
            var e = "cubic-bezier(0.23, 1, 0.32, 1)",
                i = "left " + t + "s " + e + ",top " + t + "s " + e;
            return a.map(f, function (t) {
                return t + "transition:" + i
            }).join(";")
        }

        function i(t) {
            var e = [],
                i = t.get("fontSize"),
                n = t.getTextColor();
            return n && e.push("color:" + n), e.push("font:" + t[C]()), i && e.push("line-height:" + Math.round(3 * i / 2) + "px"), u(["decoration", "align"], function (i) {
                var n = t.get(i);
                n && e.push("text-" + i + ":" + n)
            }), e.join(";")
        }

        function n(t) {
            t = t;
            var n = [],
                r = t.get("transitionDuration"),
                a = t.get("backgroundColor"),
                s = t[ae](A),
                f = t.get("padding");
            return r && n.push(e(r)), a && (h.canvasSupported ? n.push("background-Color:" + a) : (n.push("background-Color:#" + o.toHex(a)), n.push("filter:alpha(opacity=70)"))), u(["width", "color", "radius"], function (e) {
                var i = "border-" + e,
                    r = c(i),
                    a = t.get(r);
                null != a && n.push(i + ":" + a + ("color" === e ? "" : "px"))
            }), n.push(i(s)), null != f && n.push("padding:" + l.normalizeCssArray(f).join("px ") + "px"), n.join(";") + ";"
        }

        function r(t, e) {
            var i = document.createElement("div"),
                n = e.getZr();
            this.el = i, this._x = e[re]() / 2, this._y = e[ne]() / 2, t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout;
            var r = this;
            i.onmouseenter = function () {
                r.enterable && (clearTimeout(r._hideTimeout), r._show = !0), r._inContent = !0
            }, i.onmousemove = function (e) {
                if (e = e || window.event, !r.enterable) {
                    var i = n.handler;
                    s.normalizeEvent(t, e, !0), i.dispatch("mousemove", e)
                }
            }, i.onmouseleave = function () {
                r.enterable && r._show && r.hideLater(r._hideDelay), r._inContent = !1
            }
        }
        var a = t(de),
            o = t("zrender/tool/color"),
            s = t("zrender/core/event"),
            l = t("../../util/format"),
            u = a.each,
            c = l.toCamelCase,
            h = t(pe),
            f = ["", "-webkit-", "-moz-", "-o-"],
            d = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
        return r[he] = {
            constructor: r,
            enterable: !0,
            update: function () {
                var t = this._container,
                    e = t.currentStyle || document.defaultView.getComputedStyle(t),
                    i = t.style;
                "absolute" !== i[w] && "absolute" !== e[w] && (i[w] = "relative")
            },
            show: function (t) {
                clearTimeout(this._hideTimeout);
                var e = this.el;
                e.style.cssText = d + n(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), e.style.display = e.innerHTML ? "block" : "none", this._show = !0
            },
            setContent: function (t) {
                var e = this.el;
                e.innerHTML = t, e.style.display = t ? "block" : "none"
            },
            moveTo: function (t, e) {
                var i = this.el.style;
                i.left = t + "px", i.top = e + "px", this._x = t, this._y = e
            },
            hide: function () {
                this.el.style.display = "none", this._show = !1
            },
            hideLater: function (t) {
                !this._show || this._inContent && this.enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(a.bind(this.hide, this), t)) : this.hide())
            },
            isShow: function () {
                return this._show
            }
        }, r
    }), e("echarts/component/marker/markerHelper", [me, de, "../../util/number"], function (t) {
        function e(t) {
            return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y)))
        }

        function i(t) {
            return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y))
        }

        function n(t, e, i) {
            var n = -1;
            do n = Math.max(o.getPrecision(t.get(e, i)), n), t = t.stackedOn; while (t);
            return n
        }

        function r(t, e, i, r, a, o) {
            var s = [],
                l = p(e, r, t),
                u = e.indexOfNearest(r, l, !0);
            s[a] = e.get(i, u, !0), s[o] = e.get(r, u, !0);
            var c = n(e, r, u);
            return c >= 0 && (s[o] = +s[o].toFixed(c)), s
        }
        var a = t(de),
            o = t("../../util/number"),
            s = a[J],
            l = a.curry,
            u = {
                min: l(r, "min"),
                max: l(r, "max"),
                average: l(r, "average")
            },
            c = function (t, e) {
                var n = t[Q](),
                    r = t[K];
                if (e && !i(e) && !a[z](e.coord) && r) {
                    var o = r.dimensions,
                        l = h(e, n, r, t);
                    if (e = a.clone(e), e.type && u[e.type] && l.baseAxis && l.valueAxis) {
                        var c = s(o, l.baseAxis.dim),
                            f = s(o, l.valueAxis.dim);
                        e.coord = u[e.type](n, l.baseDataDim, l.valueDataDim, c, f), e.value = e.coord[f]
                    } else {
                        for (var d = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis], m = 0; 2 > m; m++)
                            if (u[d[m]]) {
                                var v = t.coordDimToDataDim(o[m])[0];
                                d[m] = p(n, v, d[m])
                            } e.coord = d
                    }
                }
                return e
            },
            h = function (t, e, i, n) {
                var r = {};
                return null != t.valueIndex || null != t.valueDim ? (r.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, r.valueAxis = i.getAxis(n.dataDimToCoordDim(r.valueDataDim)), r.baseAxis = i.getOtherAxis(r.valueAxis), r.baseDataDim = n.coordDimToDataDim(r.baseAxis.dim)[0]) : (r.baseAxis = n.getBaseAxis(), r.valueAxis = i.getOtherAxis(r.baseAxis), r.baseDataDim = n.coordDimToDataDim(r.baseAxis.dim)[0], r.valueDataDim = n.coordDimToDataDim(r.valueAxis.dim)[0]), r
            },
            f = function (t, i) {
                return t && t.containData && i.coord && !e(i) ? t.containData(i.coord) : !0
            },
            d = function (t, e, i, n) {
                return 2 > n ? t.coord && t.coord[n] : t.value
            },
            p = function (t, e, i) {
                if ("average" === i) {
                    var n = 0,
                        r = 0;
                    return t.each(e, function (t) {
                        isNaN(t) || (n += t, r++)
                    }, !0), n / r
                }
                return t.getDataExtent(e, !0)["max" === i ? 1 : 0]
            };
        return {
            dataTransform: c,
            dataFilter: f,
            dimValueGetter: d,
            getAxisInfo: h,
            numCalculate: p
        }
    }), e("echarts/component/marker/MarkerView", [me, "../../echarts"], function (t) {
        return t("../../echarts").extendComponentView({
            type: "marker",
            init: function () {
                this.markerGroupMap = {}
            },
            render: function (t, e, i) {
                var n = this.markerGroupMap;
                for (var r in n) n.hasOwnProperty(r) && (n[r].__keep = !1);
                var a = this.type + "Model";
                e[Z](function (t) {
                    var n = t[a];
                    n && this.renderSeries(t, n, e, i)
                }, this);
                for (var r in n) n.hasOwnProperty(r) && !n[r].__keep && this.group[q](n[r].group)
            },
            renderSeries: function () { }
        })
    }), e("echarts/component/axis/AxisBuilder", [me, de, "../../util/format", n, "../../model/Model", "../../util/number", "zrender/core/vector"], function (t) {
        function e(t) {
            var e = {
                componentType: t.mainType
            };
            return e[t.mainType + "Index"] = t.componentIndex, e
        }

        function i(t, e, i) {
            var n, r, a = d(e - t.rotation);
            return v(a) ? (r = i > 0 ? "top" : ee, n = M) : v(a - P) ? (r = i > 0 ? ee : "top", n = M) : (r = T, n = a > 0 && P > a ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), {
                rotation: a,
                textAlign: n,
                verticalAlign: r
            }
        }

        function r(t, e, i, n) {
            var r, a, o = d(i - t.rotation),
                s = n[0] > n[1],
                l = "start" === e && !s || "start" !== e && s;
            return v(o - P / 2) ? (a = l ? ee : "top", r = M) : v(o - 1.5 * P) ? (a = l ? "top" : ee, r = M) : (a = T, r = 1.5 * P > o && o > P / 2 ? l ? "left" : "right" : l ? "right" : "left"), {
                rotation: o,
                textAlign: r,
                verticalAlign: a
            }
        }

        function a(t) {
            var e = t.get("tooltip");
            return t.get(se) || !(t.get("triggerEvent") || e && e.show)
        }
        var o = t(de),
            l = t("../../util/format"),
            u = t(n),
            h = t("../../model/Model"),
            f = t("../../util/number"),
            d = f.remRadian,
            v = f.isRadianAroundZero,
            g = t("zrender/core/vector"),
            x = g[c],
            b = o[s],
            P = Math.PI,
            k = function (t, e) {
                this.opt = e, this.axisModel = t, o[V](e, {
                    labelOffset: 0,
                    nameDirection: 1,
                    tickDirection: 1,
                    labelDirection: 1,
                    silent: !0
                }), this.group = new u.Group;
                var i = new u.Group({
                    position: e[w].slice(),
                    rotation: e.rotation
                });
                i.updateTransform(), this._transform = i.transform, this._dumbGroup = i
            };
        k[he] = {
            constructor: k,
            hasBuilder: function (t) {
                return !!z[t]
            },
            add: function (t) {
                z[t].call(this)
            },
            getGroup: function () {
                return this.group
            }
        };
        var z = {
            axisLine: function () {
                var t = this.opt,
                    e = this.axisModel;
                if (e.get("axisLine.show")) {
                    var i = this.axisModel.axis[_](),
                        n = this._transform,
                        r = [i[0], 0],
                        a = [i[1], 0];
                    n && (x(r, r, n), x(a, a, n)), this.group.add(new u.Line(u.subPixelOptimizeLine({
                        anid: "line",
                        shape: {
                            x1: r[0],
                            y1: r[1],
                            x2: a[0],
                            y2: a[1]
                        },
                        style: o[H]({
                            lineCap: "round"
                        }, e[ae]("axisLine.lineStyle").getLineStyle()),
                        strokeContainThreshold: t.strokeContainThreshold || 5,
                        silent: !0,
                        z2: 1
                    })))
                }
            },
            axisTick: function () {
                var t = this.axisModel,
                    e = t.axis;
                if (t.get("axisTick.show") && !e.isBlank())
                    for (var i = t[ae]("axisTick"), n = this.opt, r = i[ae]("lineStyle"), a = i.get(te), s = D(i, n.labelInterval), l = e.getTicksCoords(i.get("alignWithLabel")), c = e.scale[y](), h = [], f = [], d = this._transform, p = 0; p < l[te]; p++)
                        if (!I(e, p, s)) {
                            var m = l[p];
                            h[0] = m, h[1] = 0, f[0] = m, f[1] = n.tickDirection * a, d && (x(h, h, d), x(f, f, d)), this.group.add(new u.Line(u.subPixelOptimizeLine({
                                anid: "tick_" + c[p],
                                shape: {
                                    x1: h[0],
                                    y1: h[1],
                                    x2: f[0],
                                    y2: f[1]
                                },
                                style: o[V](r.getLineStyle(), {
                                    stroke: t.get("axisLine.lineStyle.color")
                                }),
                                z2: 2,
                                silent: !0
                            })))
                        }
            },
            axisLabel: function () {
                function t(t, e) {
                    var i = t && t[S]().clone(),
                        n = e && e[S]().clone();
                    return i && n ? (i[c](t.getLocalTransform()), n[c](e.getLocalTransform()), i.intersect(n)) : void 0
                }
                var n = this.opt,
                    r = this.axisModel,
                    s = r.axis,
                    l = b(n.axisLabelShow, r.get("axisLabel.show"));
                if (l && !s.isBlank()) {
                    var f = r[ae]("axisLabel"),
                        d = f[ae](A),
                        p = f.get("margin"),
                        v = s.scale[y](),
                        g = r.getFormattedLabels(),
                        _ = b(n.labelRotation, f.get("rotate")) || 0;
                    _ = _ * P / 180;
                    var x = i(n, _, n.labelDirection),
                        w = r.get("data"),
                        M = [],
                        T = a(r),
                        k = r.get("triggerEvent");
                    if (o.each(v, function (t, i) {
                        if (!I(s, i, n.labelInterval)) {
                            var a = d;
                            w && w[t] && w[t][A] && (a = new h(w[t][A], d, r[m]));
                            var o = a.getTextColor() || r.get("axisLine.lineStyle.color"),
                                l = s.dataToCoord(t),
                                c = [l, n.labelOffset + n.labelDirection * p],
                                f = s.scale.getLabel(t),
                                v = new u.Text({
                                    anid: "label_" + t,
                                    style: {
                                        text: g[i],
                                        textAlign: a.get("align", !0) || x.textAlign,
                                        textVerticalAlign: a.get("baseline", !0) || x.verticalAlign,
                                        textFont: a[C](),
                                        fill: typeof o === L ? o(f) : o
                                    },
                                    position: c,
                                    rotation: x.rotation,
                                    silent: T,
                                    z2: 10
                                });
                            k && (v.eventData = e(r), v.eventData.targetType = "axisLabel", v.eventData.value = f), this._dumbGroup.add(v), v.updateTransform(), M.push(v), this.group.add(v), v.decomposeTransform()
                        }
                    }, this), null != r.getMin()) {
                        var z = M[0],
                            D = M[1];
                        t(z, D) && (z[ie] = !0)
                    }
                    if (null != r.getMax()) {
                        var O = M[M[te] - 1],
                            B = M[M[te] - 2];
                        t(B, O) && (O[ie] = !0)
                    }
                }
            },
            axisName: function () {
                var t = this.opt,
                    n = this.axisModel,
                    s = b(t.axisName, n.get("name"));
                if (s) {
                    var c, h = n.get("nameLocation"),
                        f = t.nameDirection,
                        d = n[ae]("nameTextStyle"),
                        p = n.get("nameGap") || 0,
                        m = this.axisModel.axis[_](),
                        v = m[0] > m[1] ? -1 : 1,
                        g = ["start" === h ? m[0] - v * p : "end" === h ? m[1] + v * p : (m[0] + m[1]) / 2, h === T ? t.labelOffset + f * p : 0],
                        y = n.get("nameRotate");
                    null != y && (y = y * P / 180);
                    var x;
                    h === T ? c = i(t, null != y ? y : t.rotation, f) : (c = r(t, h, y || 0, m), x = t.axisNameAvailableWidth, null != x && (x = Math.abs(x / Math.sin(c.rotation)), !isFinite(x) && (x = null)));
                    var w = d[C](),
                        M = n.get("nameTruncate", !0) || {},
                        S = M.ellipsis,
                        A = b(M.maxWidth, x),
                        k = null != S && null != A ? l.truncateText(s, A, w, S, {
                            minChar: 2,
                            placeholder: M.placeholder
                        }) : s,
                        L = n.get("tooltip", !0),
                        z = n.mainType,
                        I = {
                            componentType: z,
                            name: s,
                            $vars: ["name"]
                        };
                    I[z + "Index"] = n.componentIndex;
                    var D = new u.Text({
                        anid: "name",
                        __fullText: s,
                        __truncatedText: k,
                        style: {
                            text: k,
                            textFont: w,
                            fill: d.getTextColor() || n.get("axisLine.lineStyle.color"),
                            textAlign: c.textAlign,
                            textVerticalAlign: c.verticalAlign
                        },
                        position: g,
                        rotation: c.rotation,
                        silent: a(n),
                        z2: 1,
                        tooltip: L && L.show ? o[H]({
                            content: s,
                            formatter: function () {
                                return s
                            },
                            formatterParams: I
                        }, L) : null
                    });
                    n.get("triggerEvent") && (D.eventData = e(n), D.eventData.targetType = "axisName", D.eventData.name = s), this._dumbGroup.add(D), D.updateTransform(), this.group.add(D), D.decomposeTransform()
                }
            }
        },
            I = k.ifIgnoreOnTick = function (t, e, i) {
                var n, r = t.scale;
                return r.type === p && (typeof i === L ? (n = r[y]()[e], !i(n, r.getLabel(n))) : e % (i + 1))
            },
            D = k.getInterval = function (t, e) {
                var i = t.get("interval");
                return (null == i || "auto" == i) && (i = e), i
            };
        return k
    }), e("zrender", ["zrender/zrender"], function (t) {
        return t
    }), e("echarts", ["echarts/echarts"], function (t) {
        return t
    });
var ve = t("echarts");
return ve.graphic = t("echarts/util/graphic"), ve.number = t("echarts/util/number"), ve.format = t("echarts/util/format"), t("echarts/chart/bar"), t("echarts/chart/line"), t("echarts/chart/gauge"), t("echarts/component/grid"), t("echarts/component/title"), t("echarts/component/legend"), t("echarts/component/tooltip"), t("echarts/component/markPoint"), ve
                    });